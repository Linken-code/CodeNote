<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/CodeNote/2020/10/23/zone/html/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title">            <h1>使用Hexo＋Github搭建个人博客</h1>        </div>        <p></p>        <div class="list">            <p>只需简单三步，小白也能搭建属于自己的个人博客。</p>            <p>工具为hexo＋github，环境为windows10。如有错误，欢迎留言或联系作者，也欢迎大佬指正</p>            <p></p>            <h3 id="s1.1">1.1 Git安装</h3>            <p></p>            <p>安装教程</p>            <p></p>            <h3 id="s1.2">1.2 Node.js安装</h3>            <p></p>            <p>进入Node.js官网.下载左侧长期支持版并安装，无脑下一步即可</p>            <p></p>            <p>npm是一个包管理工具，nodejs已集成，但由于npm在国内比较慢，所以推荐安装cnpm淘宝镜像</p>            <p></p>            <div class="codeMirror">                <pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre>            </div>            <p></p>            <h3 id="s1.3">1.3 Checkout</h3>            <p></p>            <p>查看版本信息以检查是否安装成功</p>            <p></p>            <div class="codeMirror">                <pre><code>git --version</code></pre>            </div>            <p></p>            <p>若出现版本信息，则安装成功，若无版本信息，很有可能是你在安装时敲错命令，试着重新敲一遍，确保安装成功</p>            <p></p>            <p>以下同理</p>            <p></p>            <div class="codeMirror">                <pre><code>node -vnpm -vcnpm -v</code></pre>            </div>        </div>        <p></p>        <div class="list">            <h2 id="s2">2. 本地搭建</h2>            <p></p>            <h3 id="s2.1">2.1 hexo框架安装</h3>            <p></p>            <p>打开Git bush(即之前安装的git插件)，输入以下命令全局安装hexo</p>            <p></p>            <div class="codeMirror">                <pre><code>npm install -g hexo-cli</code></pre>            </div>            <p></p>            <p>同理，可以查看版本信息以确保安装成功</p>            <p></p>            <div class="codeMirror">                <pre><code>hexo -v</code></pre>            </div>            <p></p>            <h3 id="s2.2">2.2 初始化你的hexo博客</h3>            <p></p>            <p>在你的PC任意地方新建文件夹，然后右键选择用Git Bush打开，然后输入命令</p>            <p></p>            <div class="codeMirror">                <pre><code>hexo init</code></pre>            </div>            <p></p>            <h3 id="s2.3">2.3 本地启动博客</h3>            <p></p>            <div class="codeMirror">                <pre><code>hexo s</code></pre>            </div>            <p></p>            <p>现在你的博客已在本地4000端口启动<br>打开浏览器，输入localhost:4000加载你的博客<br>如图，hexo已经为我们创建了一篇名为《HelloWorld》的文章，并告知了我们hexo的基本命令</p>            <p></p>            <p></p>            <p>hexo生成站点目录结构</p>            <p></p>            <p>我们再来看一下这个目录结构，命令行打印出来：</p>            <p></p>            <img src="../image/hexo_articlex.png" alt="">            <p></p>            <h4>_config.yml</h4>            <p><strong>_config.yml是整个博客的配置文件</strong>，至于每项配置参数可以<strong><a href="https://hexo.io/zh-cn/docs/configuration" rel="nofollow noreferrer" target="_blank">Hexo官网文档</a></strong>有详细的介绍。</p>            <p></p>            <img src="../image/hexo_articlex2.png" alt="">            <p></p>            <h4><strong>package.json</strong></h4>            <p></p>            <p><strong>package.json</strong>是应用程序信息，打开此文件内容如下：</p>            <p></p>            <div class="codeMirror">                <pre><code>&#123;<span class="hljs-attr">"name"</span>: <span class="hljs-string">"hexo-site"</span>,<span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.0.0"</span>,<span class="hljs-attr">"private"</span>: <span class="hljs-literal">true</span>,<span class="hljs-attr">"scripts"</span>: &#123;  <span class="hljs-attr">"build"</span>: <span class="hljs-string">"hexo generate"</span>,  <span class="hljs-attr">"clean"</span>: <span class="hljs-string">"hexo clean"</span>,  <span class="hljs-attr">"deploy"</span>: <span class="hljs-string">"hexo deploy"</span>,  <span class="hljs-attr">"server"</span>: <span class="hljs-string">"hexo server"</span>&#125;,<span class="hljs-attr">"hexo"</span>: &#123;  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"4.2.0"</span>&#125;,<span class="hljs-attr">"dependencies"</span>: &#123;  <span class="hljs-attr">"hexo"</span>: <span class="hljs-string">"^4.0.0"</span>,  <span class="hljs-attr">"hexo-generator-archive"</span>: <span class="hljs-string">"^1.0.0"</span>,  <span class="hljs-attr">"hexo-generator-category"</span>: <span class="hljs-string">"^1.0.0"</span>,  <span class="hljs-attr">"hexo-generator-index"</span>: <span class="hljs-string">"^1.0.0"</span>,  <span class="hljs-attr">"hexo-generator-tag"</span>: <span class="hljs-string">"^1.0.0"</span>,  <span class="hljs-attr">"hexo-renderer-ejs"</span>: <span class="hljs-string">"^1.0.0"</span>,  <span class="hljs-attr">"hexo-renderer-stylus"</span>: <span class="hljs-string">"^1.1.0"</span>,  <span class="hljs-attr">"hexo-renderer-marked"</span>: <span class="hljs-string">"^2.0.0"</span>,  <span class="hljs-attr">"hexo-server"</span>: <span class="hljs-string">"^1.0.0"</span>&#125;&#125;</code></pre>            </div>            <p></p>            <p>一个json文件，可以得到hexo的版本信息，所有安装的依赖程序。并且在scripts字段下发现了几个刚才执行的命令，其实之前执行的几个命令实际是执行了对应的脚本。以下列出了Hexo中最重要的几个命令及其缩略形式，记住以下几个命令，就可以基本完成Hexo的操作。</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><code ><span >hexo</span> clean  = hexo c <span># 清除本地缓存，也就是清除public/文件夹和db.json文件。</span>hexo generate = hexo g <span># 将souce文件夹下的Markdown和HTML文件解析到了public文件夹下，并生成了db.json文件</span>                    hexo server = hexo s <span># 开启本地调试模式</span>                    hexo deploy = hexo d <span># 将本地资源部署到GithubPages</span>                    </code></pre>            </div>        </div>        <p></p>        <div class="list">            <h2 id="s3">3. 部署至远端</h2>            <p></p>            <p>现在我们已经完成了博客搭建，但是只能在本地的4000端口启动和查看，怎么样让别人也能访问呢<br>本着免费（白嫖）的原则，我们选用Github来进行托管以及部署</p>            <p></p>            <p>目前博客只能在本地浏览，还没有部署GitHubPages上。将博客发布到GitHubPages最直接的方式：使用git将本地博客文件夹关联到GitHub的远程仓库，并且把本地文件push到对应的仓库中。Hexo提供了一种更简便地方式，只需要在_config.yml中作相应的配置，通过命令行命令就可以很方便地把静态文件部署到对应的仓库中。</p>            <p></p>            <p></p>            <p></p>            <ul>                <li>安装一个hexo-git部署插件</li>                <div class="codeMirror">                    <pre><code>cnpm install hexo-deployer-git --save</code></pre>                </div>                <p></p>                <li>进入github，新建一个仓库（new a repository），注意！！仓库名为用户名.github.io<br>即：</li>                <div class="codeMirror">                    <pre><code>yourname.github.io</code></pre>                </div>                <p></p>                <p>注意将仓库设为public，这样别人才能访问</p>                <li>回到桌面，找到之前在本地创建的文件夹，打开博客根目录下的config.yml文件，找到deploy项，按照如下修改文件并保存</li>                <div class="codeMirror">                    <pre><code>deploy:type: gitrepo: https://github.com/yourname/yourmame.github.io.gitbranch: master</code></pre>                </div>                <p>yourname即你的github用户名</p>                <li>部署</li>                <div class="codeMirror">                    <pre><code>hexo d</code></pre>                </div>                <p></p>                <p>部署过程中会弹出来要求填写账户密码，填一下自己github账户密码即可，等待部署完成。</p>                <p>现在打开浏览器，输入yourname.github.io按下回车，即可访问你的博客主页！ 现在，快拿去和你的小伙伴分享吧哈哈哈                </p>            </ul>        </div>        <p></p>        <div class="list">            <h1>4. 参考文档</h1>            <p></p>            <p>Hexo中文官网</p>            <p></p>            <p>npm官方文档</p>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE/"/>
    <url>/CodeNote/2020/10/23/zone/html/%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title">            <h1>存储数据</h1>        </div>        <p></p>        <div class="list" id="s1">            <h2>1. Cookie</h2>            <p></p>            <p>cookie用于存储数据,当用户访问了某个网站(网页)的时候,可以通过cookie来访问客户端上存储的数据</p>            <p></p>            <p>注意:</p>            <p></p>            <ul>                <li>不同的浏览器存放的cookie位置不一样，也是不能通用的</li>                <li>cookie的存储是以域名形式进行区分的</li>                <li>cookie的数据可以设置名字的</li>                <li>一个域名下存放的cookie的个数是有限制的，不同的浏览器存放的个数不一样</li>                <li>每个cookie存放的内容大小也是有限制的，不同的浏览器存放大小不一样</li>            </ul>            <p></p>            <h3 id="s1.1">1.1 访问cookie</h3>            <p></p>            <p>通过document.cookie属性可以获取当前网站下的所有cookie,得到字符串形式的值,该返回值会将所有的cookie通过分号+空格的形式串联起来</p>            <p></p>            <div class="codeMirror">                <pre><code>console.log(document.cookie);</code></pre>            </div>            <p></p>            <h3 id="s1.2">1.2 存储cookie</h3>            <p></p>            <div class="codeMirror">                <pre><code>document.cookie = '数据名=值';</code></pre>            </div>            <p></p>            <p>注意:</p>            <ul>                <li>如果设置不同的cookie值,则用document.cookie再次赋值不会将原来设置的cookie覆盖掉,而是再加上一条cookie</li>                <li>如果设置相同的cookie值,则再次用document.coolkie设置cookie值时会将原来的cookie值覆盖掉</li>            </ul>            <p></p>            <h3 id="s1.3">1.3 设置cookie过期时间</h3>            <p></p>            <p>cookie默认是临时存储的,当浏览器关闭进程的时候自动销毁 ,如果想长时间存放一个cookie。需要在设置这个cookie的时候设置一个过期的时间</p>            <p></p>            <p>注意:过期时间必须是一个日期对象转换成的字符串</p>            <p></p>            <p>document.cookie = "数据名=值; expires=过期时间";</p>            <p></p>            <div class="codeMirror">                <pre><code>var oDate = new Date();    oDate.setDate(oDate.getDate()+5);    oDate.toUTCString();//转换为日期字符串                                document.cookie='age=20; expires='+oDate;        //转码    var content= encodeURI("20");    document.cookie="agex="+content+";expires="+oDate;</code></pre>            </div>            <p></p>            <h3 id="s1.4">1.4 cookie封装</h3>            <p></p>            <ul>                <li>设置cookie封装                    <div class="codeMirror">                        <pre><code>function setCookie(obj,time)&#123;        for(key in obj)&#123;            var d = new Date();            d.setDate(d.getDate()+time);            document.cookie = key+'='+obj[key]+'; expires='+d.toUTCString();        &#125;    &#125;            setCookie(&#123;        name:'zhangsan',        sex:'man',        age:18    &#125;,5);//5天后自动删除cookie</code></pre>                    </div>                </li>                <li>获取cookie封装                    <div class="codeMirror">                        <pre><code>function getCookie(name)&#123;//这里是用的arguments来设置的,所以可以获取多个cookie值        var cookie = document.cookie;        var result = &#123;&#125;;        for(key in arguments)&#123;            var value = '\\b'+arguments[key]+'=(\\w*)+';                var reg =new RegExp(value,'i');            value = reg.exec(cookie);                        result[arguments[key]] = value?decodeURI(value[1]):null;//解码        &#125;        return result;    &#125;        console.log( getCookie("name","sex","age"));//能够查找多个</code></pre>                    </div>                </li>                <li>移除cookie                    <div class="codeMirror">                        <pre><code>function removeCookie(name)&#123;//这里是用的arguments来获取的,所以可以删除多个cookie值        for(key in arguments)&#123;            var json =&#123;&#125;;            json[arguments[key]]=null;            setCookie(json,-1);        &#125;    &#125;    removeCookie('name');</code></pre>                    </div>                </li>            </ul>        </div>        <div class="list" id="s2">            <h2>2. 本地存储</h2>            <p></p>            <h3 id="s2.1">2.1 sessionStorage</h3>            <p></p>            <p>sessionStorage属性允许用户访问一个session Storage对象,存储在sessionStorage中的数据在页面会话结束时被清除</p>            <p></p>            <p>注意:</p>            <p></p>            <ul>                <li>页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。</li>                <li>在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话,这点和cookies的运行方式不同</li>            </ul>            <p></p>            <h3 id="s2.2">2.2 localStorage</h3>            <p></p>            <p>localStorage属性允许用户访问一个了local Storage对象,存储在localStorage中的数据能在跨浏览器会话保留,也就是说该属性中存入的值会在本地存储中永久保存</p>            <p></p>            <p>注意:localStorage中的键值对总是以字符串的形式存储,所有如果传入的是非字符串参数会自动转换为字符串,最好手动转化</p>            <p></p>            <p>方法</p>            <p></p>            <ul>                <li>setItem("对象名","对象值"),增加一个数据项目</li>                <li>getItem("对象名"),获取一个数据项目</li>                <li>removeItem("对象名"),移除一个数据项目</li>                <li>clear(),不传参数,移除所有的数据项目</li>            </ul>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/%E5%91%BD%E5%90%8D%E5%8F%82%E8%80%83main/"/>
    <url>/CodeNote/2020/10/23/zone/html/%E5%91%BD%E5%90%8D%E5%8F%82%E8%80%83main/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title">            <h1>命名参考</h1>        </div>        <p></p>        <div class="list" id="s1">            <h2>1.网页内容类</h2>            <p></p>            <p>标题: title</p>            <p>摘要: summary</p>            <p>箭头： arrow</p>            <p> 商标： label</p>            <p>网站标志：logo</p>            <p>转角/圆角： corner</p>            <p> 横幅广告： banner</p>            <p>子菜单： subMenu</p>            <p>搜索： search</p>            <p>搜索框： searchBox</p>            <p>登录： login</p>            <p>登录条：loginbar</p>            <p>工具条： toolbar</p>            <p>下拉： drop</p>            <p>标签页： tab</p>            <p>当前的： current</p>            <p> 列表： list</p>            <p>滚动： scroll</p>            <p>服务： service</p>            <p>提示信息： msg</p>            <p>热点：hot</p>            <p>新闻： news</p>            <p>小技巧： tips</p>            <p>下载： download</p>            <p>栏目标题： title</p>            <p>热点： hot</p>            <p> 加入： joinus</p>            <p>注册： regsiter</p>            <p>指南： guide</p>            <p>友情链接： friendlink</p>            <p>状态： status</p>            <p>版权： copyright</p>            <p>按钮： btn</p>            <p>合作伙伴： partner</p>            <p>投票： vote</p>            <p>左右中：left right center</p>        </div>        <p></p>        <div class="list" id="s2">            <h2>2.注释的写法：</h2>            <p></p>            <div class="codeMirror">                <pre><code>/* Footer */ 内容区 /* End Footer */</code></pre>            </div>        </div>        <p></p>        <div class="list" id="s3">            <h2>3.ID的命名</h2>            <p></p>            <h3 id="s3.1">3.1页面结构</h3>            <p></p>            <p>容器: container</p>            <p>页头：header</p>            <p>内容：content/container</p>            <p>页面主体：main</p>            <p> 页尾：footer</p>            <p> 导航：nav</p>            <p> 侧栏：sidebar</p>            <p> 栏目：column</p>            <p> 页面外围控制整体布局宽度：wrapper</p>            <p> 左右中：left right center</p>            <p></p>            <h3 id="s3.2">3.2导航</h3>            <p></p>            <p>导航：nav </p>            <p>主导航：mainbav</p>            <p>子导航：subnav</p>            <p>顶导航：topnav</p>            <p> 边导航：sidebar</p>            <p> 左导航：leftsidebar</p>            <p> 右导航：rightsidebar</p>            <p> 菜单：menu</p>            <p>子菜单：submenu</p>            <p> 标题: title</p>            <p>摘要: summary</p>            <p></p>            <h3 id="s3.3">3.3功能</h3>            <p></p>            <p>标志：logo</p>            <p>广告： banner</p>            <p>搜索： search</p>            <p>登录： login</p>            <p>登录条：loginbar</p>            <p>注册： regsiter</p>            <p>工具条： toolbar</p>            <p>下拉： drop</p>            <p>标签页： tab</p>            <p>当前的： current</p>            <p>列表： list</p>            <p>滚动： scroll</p>            <p>服务： service</p>            <p>提示信息： msg</p>            <p>热点：hot</p>            <p>新闻： news</p>            <p>图标: icon</p>            <p>注释：note</p>            <p>小技巧： tips</p>            <p>下载： download</p>            <p>栏目标题： title</p>            <p>热点： hot</p>            <p>加入： joinus</p>            <p>指南： guide</p>            <p>友情链接： friendlink</p>            <p>状态： status</p>            <p>版权： copyright</p>            <p>按钮： btn</p>            <p>合作伙伴： partner</p>            <p>投票： vote</p>        </div>        <p></p>        <div class="list" id="s4">            <h2>4.class的命名</h2>            <p></p>            <h3 id="s4.1">4.1 颜色</h3>            <p></p>            <p>使用颜色的名称或者16进制代码,如</p>            <div class="codeMirror">                <pre><code>1.red &#123; color: red; &#125;</code></pre>                <pre><code>2.f60 &#123; color: #f60; &#125;</code></pre>                <pre><code>3.ff8600 &#123; color: #ff8600; &#125;</code></pre>            </div>            <p></p>            <h3 id="s4.2">4.2字体大小</h3>            <p></p>            <p>直接使用"font+字体大小"作为名称,如</p>            <div class="codeMirror">                <pre><code>1.font12px &#123; font-size: 12px; &#125;</code></pre>                <pre><code>2.font9pt &#123;font-size: 9pt; &#125;</code></pre>            </div>            <p></p>            <h3 id="s4.3">4.3对齐样式</h3>            <p></p>            <p>使用对齐目标的英文名称,如</p>            <div class="codeMirror">                <pre><code>1.left &#123; float:left; &#125;</code></pre>                <pre><code>2.bottom &#123; float:bottom; &#125;</code></pre>            </div>            <p></p>            <h3 id="s4.4">4.4标题栏样式</h3>            <p></p>            <p>使用"类别+功能"的方式命名,如</p>            <div class="codeMirror">                <pre><code>1.barnews &#123; &#125;</code></pre>                <pre><code>2.barproduct &#123; &#125;</code></pre>            </div>            <p></p>            <p>注意事项:</p>            <ul>                <li>一律小写</li>                <li>尽量用英文</li>                <li>不加中杠和下划线</li>                <li>尽量不缩写，除非一看就明白的单词.</li>            </ul>        </div>        <p></p>        <div class="list" id="s5">            <h2>5.CSS书写顺序</h2>            <p></p>            <p>显示属性=>自身属性=>文本属性</p>            <p></p>            <ul>                <li><strong>显示属性</strong></li>                <li>display</li>                <li>list-style</li>                <li>position</li>                <li> float</li>                <li> clear</li>            </ul>            <ul>                <li><strong>自身属性</strong></li>                <li>width</li>                <li> height</li>                <li> margin</li>                <li> padding</li>                <li> border</li>                <li> background</li>            </ul>            <ul>                <li><strong>文本属性</strong></li>                <li>color</li>                <li>font</li>                <li>text-decoration</li>                <li>text-align</li>                <li>vertical-align</li>                <li>white-space</li>                <li>other text</li>                <li>content</li>            </ul>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/Vue%E9%A1%B9%E7%9B%AE/"/>
    <url>/CodeNote/2020/10/23/zone/html/Vue%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title">            <h1>Vue项目创建打包与UI资源</h1>        </div>        <p></p>        <div class="list" id="s1">            <h2>1. Vue项目创建</h2>            <p></p>            <h3 id="s1.1">1.1 vue-cli脚手架</h3>            <p></p>            <p>vue-cli是一个基于vue的构建工具,用于搭建vue项目的环境,有着兼容,方便,快速的优点,能够完全遵循前后端分离的原则,用vue开发单网页项目(SPA)的能力尤其的好</p>            <p></p>            <p>注:可以不用脚手架(vue-cli)就可以基于 webpack 打包工具 ,webpack最终会把整个项目打包成一个js文件但需要自己进行配置各个版本兼容问题,正因为这样,前端有一个专门的配置工程师</p>            <p></p>            <p></p>            <h3 id="s1.2">1.2 下载Node.js</h3>            <p></p>            <p>去Node.js的官网下载最新版的node,需要用到其包管理工具npm</p>            <p></p>            <h3 id="s1.3">1.3 配置淘宝镜像</h3>            <p></p>            <p>因为npm是国外的,在国内用会特别慢,所以需要先用淘宝的cnpm代替npm</p>            <p></p>            <p>在命令行窗口输入 npm install -g cnpm --registry=https://registry.npm.taobao.org配置淘宝镜像</p>            <p></p>            <p></p>            <h3 id="s1.4">1.4 安装vue-cli</h3>            <p></p>            <p>在命令行窗口输入 cnpm i -g vue-cli 全局安装vue-cli脚手架</p>            <p></p>            <p>注:安装完成后可以使用 vue -V 查看是否安装成功</p>            <p></p>            <h3 id="s1.5">1.5 安装项目文件</h3>            <p></p>            <p>先到项目文件夹,打开命令行窗口输入vue init webpack 项目文件夹名</p>            <p></p>            <h3 id="s1.6">1.6 运行项目文件</h3>            <p></p>            <p>在项目文件中使用npm run dev运行项目文件</p>            <p></p>            <p>出现http://localhost:8080字样后在 http://localhost:8080 查看生产的Vue项目,出现下面的页面证明Vue项目创建成功</p>            <p></p>            <h3 id="s1.7">1.7 打包项目</h3>            <p></p>            <p>在项目文件夹中运行 npm run build 将项目打包 ,打包后的文件将会保存在该文件的list文件夹中</p>            <p></p>        </div>        <div class="list" id="s2">            <h2>2.UI资源</h2>            <p></p>            <ul>                <li>ElementUI <br/>介绍：Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库 <br/>链接：https://element-cn.eleme.io/#/zh-CN                </li>                <li>Mint UI <br/>介绍：基于 Vue.js 的移动端组件库 <br/>链接：https://mint-ui.github.io/#!/zh-cn                </li>                <li>Mui <br/>介绍：最接近原生APP体验的高性能前端框架 <br/>链接：http://dev.dcloud.net.cn/mui/ui/                </li>                <li>Aui 框架 <br/>介绍：使用了大量弹性响应式布局，采用容器+布局结构+控件的嵌套形式,借鉴了市场上其他优秀UI框架<br/> 链接：http://www.auicss.com/                </li>                <li>we-vue<br/> 介绍：使用 Vue2.x + weui1.x 开发的组件<br/> 链接：https://github.com/tianyong90/we-vue                </li>                <li>Vue-Layout <br/>介绍：vue可视化布局 <br/>链接：https://jaweii.github.io/Vue-Layout/dist/#/                </li>                <li>muse-ui <br/>链接：https://muse-ui.org/#/zh-CN/tabs                </li>            </ul>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/Vue%E7%AE%80%E6%98%93%E6%A1%88%E4%BE%8B/"/>
    <url>/CodeNote/2020/10/23/zone/html/Vue%E7%AE%80%E6%98%93%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title">            <h1>Vue简易案例</h1>        </div>        <p></p>        <div class="list" id="s1">            <h2>1.Vue实现城市选择</h2>            <p></p>            <p>当选择不同省的时候,会在后一个城市的选择中出现对应省的城市</p>            <p></p>            <div class="codeMirror">                <pre><xmp><div id="app">    <select v-model="province"><!--通过v-modle双向绑定province-->        <option v-for="item in provinces" :value="item"></option>    </select>    <select v-model="city">        <option v-for="item in cities" :value="item"></option>    </select></div><script>    new Vue({        el:"#app",        data:{            provinces:[],            cities:[],            province:null,            city:null,        },        watch:{            province(value){//通过监听province的值来实现动态改变cities的值,一般都是通过接口赋值                if(value==="浙江省"){                    this.cities=["杭州市","嘉兴市"]                }else if(value==="四川省"){                    this.cities=["成都市","绵阳市","乐山市"]                }            }          },        created(){            //真实案例是通过接口实现            this.provinces=[                "省",                "浙江省",                "四川省"            ]        }    })</script></xmp></pre>            </div>        </div>        <div class="list" id="s2">            <h2>2. Vue-computed实现登录效果</h2>            <p></p>            <p></p>            <p>通过Vue的计算属性对登录按钮实现控制,只有当所有的内容都填写完毕后才能够使用登录按钮</p>            <p></p>            <div class="codeMirror">                <pre><xmp><div id="app">    <form @submit.prevent="login">        <input type="text" v-model="mobile">        <input type="password" v-model="password">        <button type="submit" :disabled="!isValid">            Login        </button>    </form> </div><script>    new Vue({        el:"#app",        data:{            mobile:"",            password:""        },        computed:{            isValid(){                return String(this.mobile).match(/^1\d{10}$/)&&String(this.password.length)>=6            }        },        methods:{            login(){                window.location.href="https://www.baidu.com/";            }        }    })</script></xmp></pre>            </div>        </div>        <div class="list" id="s3">            <h2>3.大数据加载特效</h2>            <p></p>            <p></p>            <p>通过Vue的计算属性对登录按钮实现控制,只有当所有的内容都填写完毕后才能够使用登录按钮</p>            <p></p>            <div class="codeMirror">                <pre><xmp><template><div class="dv-loading">    <svg width="50px" height="50px">        <circle          cx="25"          cy="25"          r="20"          fill="transparent"          stroke-width="3"          stroke-dasharray="31.415 31.415"          stroke="#02bcfe"          stroke-linecap="round"        >          <animateTransform            attributeName="transform"            type="rotate"            values="0, 25 25;360, 25 25"            dur="1.5s"            repeatCount="indefinite"          />          <animate            attributeName="stroke"            values="#02bcfe;#3be6cb;#02bcfe"            dur="3s"            repeatCount="indefinite"          />        </circle>          <circle          cx="25"          cy="25"          r="10"          fill="transparent"          stroke-width="3"          stroke-dasharray="15.7 15.7"          stroke="#3be6cb"          stroke-linecap="round"        >          <animateTransform            attributeName="transform"            type="rotate"            values="360, 25 25;0, 25 25"            dur="1.5s"            repeatCount="indefinite"          />          <animate            attributeName="stroke"            values="#3be6cb;#02bcfe;#3be6cb"            dur="3s"            repeatCount="indefinite"          />        </circle>      </svg>      <div class="loading-tip">        <slot />      </div>    </div>  </template>    <script>  export default {    name: 'DvLoading'  }  </script>    <style lang="less" scoped>  .dv-loading {    width: 100%;    height: 100%;    display: flex;    flex-direction: column;    justify-content: center;    align-items: center;  }  .dv-loading .loading-tip {    font-size: 15px;  }  </style></xmp></pre>            </div>        </div>        <div class="list" id="s4">            <h2>4.Vue指令实现拖拽功能</h2>            <p></p>            <p></p>            <p>通过Vue的计算属性对登录按钮实现控制,只有当所有的内容都填写完毕后才能够使用登录按钮</p>            <p></p>            <div class="codeMirror">                <pre><xmp>// 这个助手方法下面会用到，用来获取 css 相关属性值const getAttr = (obj, key) =>obj.currentStyle? obj.currentStyle[key]: window.getComputedStyle(obj, false)[key]const vDrag = {inserted(el) {/** * 这里是跟据 dialog 组件的 dom 结构来写的 * target: dialog 组件的容器元素 * header：dialog 组件的头部区域，也是就是拖拽的区域 */const target = el.children[0]const header = target.children[0]// 鼠标手型header.style.cursor = 'move'header.onmousedown = e => {  // 记录按下时鼠标的坐标和目标元素的 left、top 值  const currentX = e.clientX  const currentY = e.clientY  const left = parseInt(getAttr(target, 'left'))  const top = parseInt(getAttr(target, 'top'))  document.onmousemove = event => {    // 鼠标移动时计算每次移动的距离，并改变拖拽元素的定位    const disX = event.clientX - currentX    const disY = event.clientY - currentY    target.style.left = `${left + disX}px`    target.style.top = `${top + disY}px`    // 阻止事件的默认行为，可以解决选中文本的时候拖不动    return false  }  // 鼠标松开时，拖拽结束  document.onmouseup = () => {    document.onmousemove = null    document.onmouseup = null  }  // 分别计算四个方向的边界值  const minLeft =    target.offsetLeft + parseInt(getAttr(target, 'width')) - 50  const maxLeft =    parseInt(getAttr(document.body, 'width')) - target.offsetLeft - 50  const minTop = target.offsetTop  const maxTop =    parseInt(getAttr(document.body, 'height')) -    target.offsetTop -    parseInt(getAttr(header, 'height'))  document.onmousemove = event => {    // 鼠标移动时计算每次移动的距离，并改变拖拽元素的定位    const disX = event.clientX - currentX    const disY = event.clientY - currentY    // 判断左、右边界    if (disX < 0 && disX <= -minLeft) {      target.style.left = `${left - minLeft}px`    } else if (disX > 0 && disX >= maxLeft) {      target.style.left = `${left + maxLeft}px`    } else {      target.style.left = `${left + disX}px`    }    // 判断上、下边界    if (disY < 0 && disY <= -minTop) {      target.style.top = `${top - minTop}px`    } else if (disY > 0 && disY >= maxTop) {      target.style.top = `${top + maxTop}px`    } else {      target.style.top = `${top + disY}px`    }    return false  }}},// 每次重新打开 dialog 时，要将其还原update(el) {const target = el.children[0]target.style.left = ''target.style.top = ''},// 最后卸载时，清除事件绑定unbind(el) {const header = el.children[0].children[0]header.onmousedown = null}}export default vDrap</xmp></pre>            </div>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><!-- 使用 --><el-dialog v-drag title="对话框" :visible.sync="dialogVisible"></el-dialog></xmp></pre>            </div>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/CodeNote/2020/10/23/zone/html/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title">            <h1>Vue源码解析</h1>        </div>        <p></p>        <div class="list" id="s1">            <h2>1.数据驱动</h2>            <p></p>            <h3 id="s1.1">1.1 Vue与模板</h3>            <p></p>            <p>使用步骤:</p>            <p></p>            <ol>                <li>编写页面模板</li>                <ol>                    <li>直接在 HTML 标签中写 标签</li>                    <li>使用 template</li>                    <li>使用 单文件 ( &lt;template /> )</li>                </ol>                <li>创建 Vue 的实例</li>                <ol>                    <li>在 Vue 的构造函数中提供: data, methods, computed, watcher, props等</li>                </ol>                <li>将 Vue 挂载到 页面中 ( mount )</li>            </ol>            <p></p>            <h3 id="s1.2">1.2 数据驱动模型</h3>            <p></p>            <p>Vue 的执行流程：</p>            <p></p>            <ol>                <li>获得模板: 模板中有 "坑"</li>                <li>利用 Vue 构造函数中所提供的数据来 "填坑", 得到可以在页面中显示的 "标签了"                </li>                <li>将标签替换页面中原来有坑的标签</li>            </ol>            <p></p>            <p>所以，Vue 利用我们提供的数据和页面中模板生成了一个新的 HTML 标签 ( node 元素 )，替换到了页面中放置模板的位置。</p>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <script src="./node_modules/vue/dist/vue.min.js"></script>    </head>      <body>        <!-- 第一步、写模板 -->    <div id="root">        <p></p>        <p></p>    </div>    <script>        // 第一个打印的root鼠标放上去页面是不会有高亮的        console.log(root)            // 第二步，创建实例        const app = new Vue({                el: '#root',                data: {                    name: '张三',                    message: '是人'                }            })            // 第三步，挂载，Vue已经帮我们实现            // 第二个打印的root鼠标放上去页面才会有高亮的，因为Vue是替换模板，        而不是在模板基础上进行修改        console.log(root)    </script></body></html></xmp></pre>            </div>            <p></p>            <h3 id="s1.3">1.3 简单的模板渲染</h3>            <p></p>            <p>步骤分析:</p>            <p></p>            <ul>                <li>拿到模板</li>                <li>拿到数据（data）</li>                <li>将数据与模板结合，得到的是HTML元素（DOM元素）</li>                <li>放到页面中</li>            </ul>            <p></p>            <h4 id="s1.3.1">1.3.1 简单渲染</h4>            <p></p>            <div class="codeMirror">                <pre><code>&lt;!DOCTYPE html>&lt;html lang="en">&lt;head>&lt;meta charset="UTF-8" />&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" />&lt;meta http-equiv="X-UA-Compatible" content="ie=edge" />&lt;title>Document&lt;/title>&lt;/head>  &lt;body>     &lt;div id="root">      &lt;div>      &lt;p>&#123;&#123;name&#125;&#125;-&#123;&#123;message&#125;&#125;&lt;/p>      &lt;/div>        &lt;p>&#123;&#123;name&#125;&#125;&lt;/p>        &lt;p>&#123;&#123;message&#125;&#125;&lt;/p>      &lt;/div>      &lt;script>      /*            步骤分析：            1.拿到模板            2.拿到数据（data）            3.将数据与模板结合，得到的是HTML元素（DOM元素）            4.放到页面中        */      // 1.模版      const tmpNode = document.querySelector('#root')      // 2.数据      const data = &#123;        name: '一个名字',        message: '一个消息'      &#125;      // 3.将数据放到模板中（一般使用递归）      // &#123;&#123;&#125;&#125;语法正则      const Mustache = /\&#123;\&#123;(.+?)\&#125;\&#125;/g      /*        注意的是，在这个案例中我们的template是一个DOM元素，但是真正的Vue源码中是         DOM元素 -> 字符串模板 -> 抽象语法树（AST）-> VNode -> 真正的DOM      */      function compiler(template, data) &#123;        const childNodes = template.childNodes // 取出子元素        for (let i = 0; i < childNodes.length; i++) &#123;          const type = childNodes[i].nodeType //1.元素 3.文本节点          if (type === 3) &#123;            // 文本节点，判断里面是否有 &#123;&#123;&#125;&#125; 插值            let txt = childNodes[i].nodeValue // 该属性只有文本节点才有意义            // 有没有 &#123;&#123;&#125;&#125;            txt = txt.replace(Mustache, (_, g) => &#123;              // replace使用正则匹配一次，函数就会调用一次，函数第一个参数表示匹配到的内容              //第二个参数表示匹配到的正则中的第一组，以此类推              const key = g.trim() // 写在&#123;&#123;&#125;&#125;中的东西              // 将&#123;&#123;xxx&#125;&#125;用这个值替换              const value = data[key]              return value            &#125;)            // 注意：txt现在和DOM元素没有关系            childNodes[i].nodeValue = txt          &#125; else if (type === 1) &#123;            // 元素节点，考虑它有没有子元素，是否将其子元素进行判断是否要插值            compiler(childNodes[i], data)          &#125;        &#125;      &#125;      // 两次打印结果一致，因为我们没有生成新的template，是直接在页面更新数据，这样做模板就没有了      /*      console.log(tmpNode)      compiler(tmpNode, data)      console.log(tmpNode)      */      const generateNode = tmpNode.cloneNode(true) //不传true不克隆子节点      //同时因为是DOM元素才这样克隆，虚拟DOM不会这样克隆      console.log(tmpNode)      compiler(generateNode, data)      console.log(generateNode)      // 4.将渲染好的html放到页面中      tmpNode.parentNode.replaceChild(generateNode, tmpNode)      /*        注意：上面的代码只是个极其简陋的模板，还存在很大的问题        1.Vue使用的是虚拟DOM        2.只考虑了单属性 &#123;&#123;name&#125;&#125;，而Vue中大量的使用层级 &#123;&#123;child.name.firstName&#125;&#125;        3.代码没有整合      */    &lt;/script>  &lt;/body>&lt;/html></code></pre>            </div>            <p></p>            <p>注意：上面的代码只是个极其简陋的模板，还存在很大的问题：</p>            <p></p>            <ul>                <li>Vue使用的是虚拟DOM</li>                <li>只考虑了单属性 ，而Vue中大量的使用层级 </li>                <li>代码没有整合成面向对象形式，需要最后变成构造函数</li>            </ul>            <p></p>            <h4 id="s1.3.2">1.3.2 整合代码</h4>            <p></p>            <h5 id="s1.3.2.1">1.3.2.1 构造函数化</h5>            <p></p>            <p>我们将上面的简单模板进行一些整理，做成构造函数的形式，面向对象处理。</p>            <p></p>            <ul>                <li>ES5函数形式                    <div class="codeMirror">                        <pre><code>// &#123;&#123;&#125;&#125;语法正则const Mustache = /\&#123;\&#123;(.+?)\&#125;\&#125;/gfunction compiler(template, data) &#123;    const childNodes = template.childNodes // 取出子元素    for (let i = 0; i &lt;code childNodes.length; i++) &#123;        const type = childNodes[i].nodeType //1.元素 3.文本节点        if (type === 3) &#123;            // 文本节点，判断里面是否有 &#123;&#123;&#125;&#125; 插值            let txt = childNodes[i].nodeValue // 该属性只有文本节点才有意义            // 有没有 &#123;&#123;&#125;&#125;            txt = txt.replace(Mustache, (_, g) => &#123;                // replace使用正则匹配一次，函数就会调用一次，函数第一个参数表示匹配到的内容，                第二个参数表示匹配到的正则中的第一组，以此类推                const key = g.trim() // 写在&#123;&#123;&#125;&#125;中的东西                // 将&#123;&#123;xxx&#125;&#125;用这个值替换                const value = data[key]                return value            &#125;)            // 注意：txt现在和DOM元素没有关系            childNodes[i].nodeValue = txt        &#125; else if (type === 1) &#123;            // 元素节点，考虑它有没有子元素，是否将其子元素进行判断是否要插值            compiler(childNodes[i], data)        &#125;    &#125;&#125;// 将我们之前的简单模板进行构造函数化function myVue(options) &#123;    // 习惯：内部数据以下划线开头，只读数据以$开头    this._data = options.data    this._el = options.el    // 准备模板    this._templateDOM = document.querySelector(this._el)    this._parent = this._templateDOM.parentNode    // 渲染工作    this.render()&#125;// 将模板结合数据，得到HTML加入到页面中myVue.prototype.render = function() &#123;    this.compiler()&#125;// 编译，将模板与数据结合，得到真正的DOM元素myVue.prototype.compiler = function() &#123;    // 用模板得到一个准DOM    const realHTML = this._templateDOM.cloneNode(true)    compiler(realHTML, this._data)    this.update(realHTML)&#125;// 将DOM元素放到页面中，更新myVue.prototype.update = function(real) &#123;    // 注意：在真正的Vue中不是直接用的replaceChild进行更新，而是diff算法与虚拟DOM结合，这只是一个极简的版本    this._parent.replaceChild(real, document.querySelector(this._el))&#125;const app = new myVue(&#123;    el: '#root',    data: &#123;        name: '一个名字',        message: '一个消息'    &#125;&#125;)</code></pre>                    </div>                </li>                <p></p>                <li>ES6类的形式                    <div class="codeMirror">                        <pre><code>// &#123;&#123;&#125;&#125;语法正则const Mustache = /\&#123;\&#123;(.+?)\&#125;\&#125;/gfunction compiler(template, data) &#123;    const childNodes = template.childNodes // 取出子元素    for (let i = 0; i &lt; childNodes.length; i++) &#123;        const type = childNodes[i].nodeType //1.元素 3.文本节点        if (type === 3) &#123;            // 文本节点，判断里面是否有 &#123;&#123;&#125;&#125; 插值            let txt = childNodes[i].nodeValue // 该属性只有文本节点才有意义            // 有没有 &#123;&#123;&#125;&#125;            txt = txt.replace(Mustache, (_, g) => &#123;                // replace使用正则匹配一次，函数就会调用一次，函数第一个参数表示匹配到的内容，                第二个参数表示匹配到的正则中的第一组，以此类推                const key = g.trim() // 写在&#123;&#123;&#125;&#125;中的东西                // 将&#123;&#123;xxx&#125;&#125;用这个值替换                const value = data[key]                return value            &#125;)            // 注意：txt现在和DOM元素没有关系            childNodes[i].nodeValue = txt        &#125; else if (type === 1) &#123;            // 元素节点，考虑它有没有子元素，是否将其子元素进行判断是否要插值            compiler(childNodes[i], data)        &#125;    &#125;&#125;// 将我们之前的简单模板进行构造函数化class myVue &#123;    constructor(options) &#123;        // 习惯：内部数据以下划线开头，只读数据以$开头        this._data = options.data        this._el = options.el        // 准备模板        this._templateDOM = document.querySelector(this._el)        this._parent = this._templateDOM.parentNode        // 渲染工作        this.render()    &#125;    // 将模板结合数据，得到HTML加入到页面中    render() &#123;        this.compiler()    &#125;    // 编译，将模板与数据结合，得到真正的DOM元素    compiler() &#123;        // 用模板得到一个准DOM        const realHTML = this._templateDOM.cloneNode(true)        compiler(realHTML, this._data)        this.update(realHTML)    &#125;    // 将DOM元素放到页面中，更新    update(real) &#123;        // 注意：在真正的Vue中不是直接用的replaceChild进行更新，而是diff算法与虚拟DOM结合，        这只是一个极简的版本        this._parent.replaceChild(real, document.querySelector(this._el))    &#125;&#125;const app = new myVue(&#123;    el: '#root',    data: &#123;        name: '一个名字',        message: '一个消息'    &#125;&#125;)</code></pre>                    </div>                </li>            </ul>            <p></p>            <p></p>            <h5 id="s1.3.2.2">1.3.2.2 层级属性</h5>            <p></p>            <p>解决问题：使用a.b.c的方式访问对象时如何解决，其实就是使用字符串路径来访问对象的成员</p>            <p></p>            <div class="codeMirror">                <pre><xmp>// 通过分割字符串来实现function getValueByPath(obj, path) {    const paths = path.split('.') // a.b.c    // 先取到a.b，再取到a.b.c    let res = obj    let prop = ''    // 如果没有值最后为undefined    while ((prop = paths.shift())) {        res = res[prop]    }    return res}</xmp></pre>            </div>            <p></p>            <p></p>            <div class="codeMirror">                <pre><code>&lt;!DOCTYPE html>&lt;html lang="en">  &lt;head>  &lt;meta charset="UTF-8" />  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" />  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" />  &lt;title>Document</title>  &lt;/head>    &lt;body>      &lt;div id="root">          &lt;p>&#123;&#123;name.firstName&#125;&#125;</p>      &lt;/div>      &lt;script>          // 将我们之前的简单模板进行构造函数化          class myVue &#123;            constructor(options) &#123;              // 习惯：内部数据以下划线开头，只读数据以$开头              this._data = options.data              this._el = options.el              // 准备模板              this._templateDOM = document.querySelector(this._el)              this._parent = this._templateDOM.parentNode              // 渲染工作              this.render()            &#125;            // 将模板结合数据，得到HTML加入到页面中            render() &#123;              this.compiler()            &#125;            // 编译，将模板与数据结合，得到真正的DOM元素            compiler() &#123;              // 用模板得到一个准DOM              const realHTML = this._templateDOM.cloneNode(true)              compiler(realHTML, this._data)              this.update(realHTML)            &#125;            // 将DOM元素放到页面中，更新            update(real) &#123;              // 注意：在真正的Vue中不是直接用的replaceChild进行更新，而是diff算法与虚拟DOM结合，              这只是一个极简的版本              this._parent.replaceChild(real, document.querySelector(this._el))            &#125;          &#125;              // &#123;&#123;&#125;&#125;语法正则          const Mustache = /\&#123;\&#123;(.+?)\&#125;\&#125;/g          function compiler(template, data) &#123;            const childNodes = template.childNodes // 取出子元素            for (let i = 0; i < childNodes.length; i++) &#123;              const type = childNodes[i].nodeType //1.元素 3.文本节点              if (type === 3) &#123;                // 文本节点，判断里面是否有 &#123;&#123;&#125;&#125; 插值                let txt = childNodes[i].nodeValue // 该属性只有文本节点才有意义                // 有没有 &#123;&#123;&#125;&#125;                txt = txt.replace(Mustache, (_, g) => &#123;                  // replace使用正则匹配一次，函数就会调用一次，函数第一个参数表示匹配到的内容                  //第二个参数表示匹配到的正则中的第一组，以此类推                  const path = g.trim() // 写在&#123;&#123;&#125;&#125;中的东西                  // 将&#123;&#123;xxx&#125;&#125;用这个值替换                  const value = getValueByPath(data, path)                  return value                &#125;)                // 注意：txt现在和DOM元素没有关系                childNodes[i].nodeValue = txt              &#125; else if (type === 1) &#123;                // 元素节点，考虑它有没有子元素，是否将其子元素进行判断是否要插值                compiler(childNodes[i], data)              &#125;            &#125;          &#125;              /*           解决问题：          使用a.b.c的方式访问对象时如何解决，其实就是使用字符串路径来访问对象的成员          */          function getValueByPath(obj, path) &#123;            const paths = path.split('.') // a.b.c            // 先取到a.b，再取到a.b.c            let res = obj            let prop = ''            // 如果没有值最后为undefined            while ((prop = paths.shift())) &#123;              res = res[prop]            &#125;            return res          &#125;          const app = new myVue(&#123;            el: '#root',            data: &#123;              name: &#123;                firstName: '张',                lastName: '三'              &#125;            &#125;          &#125;)    &lt;/script>  &lt;/body>&lt;/html></code></pre>            </div>            <p></p>            <p></p>            <h3 id="s1.4">1.4 虚拟DOM</h3>            <p></p>            <p>虚拟DOM能够极大的提高页面渲染的性能，减少页面的缓存等因素的影响</p>            <p></p>            <div class="codeMirror">                <pre><xmp>// 虚拟DOM类似下面这样class VNode {    constructor(tag, data, value, type) {        this.tag = tag && tag.toLowerCase()        this.data = data        this.value = value        this.type = type        this.children = []    }    appendChild(vnode) {        this.children.push(vnode)    }}</xmp></pre>            </div>            <p></p>            <p>在Vue中，要将模板和数据相结合其实需要经历两个过程，这其中也涉及到了两种算法（思路与深拷贝类似</p>            <p></p>            <ul>                <li>怎么将真正的 DOM 转换为 虚拟 DOM                    <div class="codeMirror">                        <pre><xmp>// 将真正的DOM转换为VNodefunction getVNode(node) {    const nodeType = node.nodeType    let _vnode = null    if (nodeType === 1) {        const nodeName = node.nodeName        const attrs = node.attributes        let _attrObj = {}        for (let i = 0; i < attrs.length; i++) {            _attrObj[attrs[i].nodeName] = attrs[i].nodeValue        }        _vnode = new VNode(nodeName, _attrObj, undefined, nodeType)        // 考虑node的子元素        const childNodes = node.childNodes        for (let i = 0; i < childNodes.length; i++) {            _vnode.appendChild(getVNode(childNodes[i]))        }    } else if (nodeType === 3) {        _vnode = new VNode(undefined, undefined, node.nodeValue, nodeType)    }    return _vnode}</xmp></pre>                    </div>                </li>                <li>怎么将虚拟 DOM 转换为 真正的 DOM                    <div class="codeMirror">                        <pre><xmp>// 将VNode转换为真正的DOMfunction parseVNode(vnode) {    // 创建真实的DOM节点    const type = vnode.type    let _node = null    if (type === 3) {        // 创建文本节点        return document.createTextNode(vnode.value)    } else if (type === 1) {        _node = document.createElement(vnode.tag)        // 属性        const data = vnode.data // 现在这个data是键值对        Object.keys(data).forEach(key => {            const attrName = key            const attrValue = data[key]            _node.setAttribute(attrName, attrValue)        })        // 创建子元素        const children = vnode.children        children.forEach(subvnode => {            _node.appendChild(parseVNode(subvnode))        })        return _node    }}</xmp></pre>                    </div>                </li>            </ul>            <p></p>            <div class="codeMirror">                <pre><code>&lt;!DOCTYPE html>&lt;html lang="en">&lt;head>&lt;meta charset="UTF-8" />&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" />&lt;meta http-equiv="X-UA-Compatible" content="ie=edge" />&lt;title>Document</title>  &lt;/head>    &lt;body>        &lt;div id="root">           &lt;p>11</p>        &lt;/div>        &lt;script>          // 将真正的DOM转换为VNode          function getVNode(node) &#123;            const nodeType = node.nodeType            let _vnode = null            if (nodeType === 1) &#123;              const nodeName = node.nodeName              const attrs = node.attributes              let _attrObj = &#123;&#125;              for (let i = 0; i < attrs.length; i++) &#123;                _attrObj[attrs[i].nodeName] = attrs[i].nodeValue              &#125;              _vnode = new VNode(nodeName, _attrObj, undefined, nodeType)                  // 考虑node的子元素              const childNodes = node.childNodes              for (let i = 0; i < childNodes.length; i++) &#123;                _vnode.appendChild(getVNode(childNodes[i]))              &#125;            &#125; else if (nodeType === 3) &#123;              _vnode = new VNode(undefined, undefined, node.nodeValue, nodeType)            &#125;            return _vnode          &#125;          // 将VNode转换为真正的DOM          function parseVNode(vnode) &#123;            // 创建真实的DOM节点            const type = vnode.type            let _node = null            if (type === 3) &#123;              // 创建文本节点              return document.createTextNode(vnode.value)            &#125; else if (type === 1) &#123;              _node = document.createElement(vnode.tag)              // 属性              const data = vnode.data // 现在这个data是键值对              Object.keys(data).forEach(key => &#123;                const attrName = key                const attrValue = data[key]                _node.setAttribute(attrName, attrValue)              &#125;)                  // 创建子元素              const children = vnode.children              children.forEach(subvnode => &#123;                _node.appendChild(parseVNode(subvnode))              &#125;)              return _node            &#125;          &#125;          class VNode &#123;            constructor(tag, data, value, type) &#123;              this.tag = tag && tag.toLowerCase()              this.data = data              this.value = value              this.type = type              this.children = []            &#125;            appendChild(vnode) &#123;              this.children.push(vnode)            &#125;          &#125;          const root = document.querySelector('#root')          const vRoot = getVNode(root)          console.log(vRoot)          const realRoot = parseVNode(vRoot)          // 要验证是否转换，只需要将DOM打印出来是否和原来的DOM一致          console.log(realRoot)        &lt;/script>      &lt;/body>&lt;/html></code></pre>            </div>        </div>        <p></p>        <div class="list" id="s2">            <h2>2.函数科里化和渲染模型</h2>            <p></p>            <h3 id="s2.1">2.1 函数科里化</h3>            <p></p>            <h4 id="2.1.1">2.1.1 什么是函数科里化？</h4>            <p></p>            <h4 id="s2.1.2">2.1.2 基本概念</h4>            <p></p>            <ul>                <li>科里化： 一个函数原本有多个参数, 只传入一个参数, 生成一个新函数, 由新函数接收剩下的参数来运行得到结构。</li>                <li>偏函数： 一个函数原本有多个参数, 只传入一部分参数, 生成一个新函数, 由新函数接收剩下的参数来运行得到结构。</li>                <li>高阶函数：一个函数参数是一个函数, 该函数对参数这个函数进行加工, 得到一个函数, 这个加工用的函数就是高阶函数</li>            </ul>            <p></p>            <h4 id="s2.1.3">2.1.3 Vue中的函数科里化</h4>            <p></p>            <p>Vue 中使用函数科里化的直接受益就是能够提升性能，使用科里化能够缓存函数的一部分能力。</p>            <p></p>            <p>Vue 本质上是使用 HTML 的字符串作为模板的, 将字符串的 模板 转换为 AST, 再转换为 VNode。</p>            <p></p>            <ul>                <li>模板 -> AST</li>                <li>AST -> VNode</li>                <li>VNode -> DOM</li>            </ul>            <p></p>            <p>在这三个阶段中，第一个阶段 模板 -> AST 是最消耗性能的，因为在这里面进行了字符串的解析。在前面我们进行简单的模板渲染时并没有说明这个问题，其实 Vue 在真正的转换的时候不是那样直接转换的。</p>            <p></p>            <p>以Vue的例子来说，在 Vue 中每一个标签可以是真正的 HTML 标签, 也可以是自定义组件, 那么怎么区分？</p>            <p></p>            <p>其实，观察Vue的源码我们可以知道，Vue已经内部事先将可以用的 HTML 标签都保存起来了</p>            <p></p>            <div class="codeMirror">                <pre><xmp>const tags = 'html,body,base,head,link,meta,style,title,' +    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +    'embed,object,param,source,canvas,script,noscript,del,ins,' +    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +    'output,progress,select,textarea,' +    'details,dialog,menu,menuitem,summary,' +    'content,element,shadow,template,blockquote,iframe,tfoot'</xmp></pre>            </div>            <p></p>            <p>但是，如果我们每次在进行判断的时候都要循环一次判断，这样做是非常消耗性能的。而使用科里化能够将指数次的时间复杂度降为O(1)。</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp>const tags =    'html,body,base,head,link,meta,style,title,' +    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +    'embed,object,param,source,canvas,script,noscript,del,ins,' +    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +    'output,progress,select,textarea,' +    'details,dialog,menu,menuitem,summary,' +    'content,element,shadow,template,blockquote,iframe,tfoot'function makeMap(tags) {  const keys = tags.split(',')  const set = {}  keys.forEach(key => (set[key] = true))  // 我们只需要通过函数是否有该属性来判断  return function(tagName) {      return !!set[tagName.toLowerCase()]  }}// 得到这个函数来进行HTML标签和组件的判断const isHTMLTag = makeMap(tags)</xmp></pre>            </div>            <p></p>            <p>那么，为什么不将set定义为全局对象，这样一样能够实现效果？</p>            <p></p>            <p>因为使用makeMap获取各种判断的函数并不止会用一次，在Vue中不止是处理了HTML的标签，还有很多其他的标签，类似svg这样。所以，为了区分开以及代码的复用性，我们更倾向将其进行科里化处理。</p>            <p></p>            <p></p>            <h3 id="2.2">2.2 Vue的渲染模型（极简）</h3>            <p></p>            <p>Vue在获取到渲染函数的时候也是通过函数科里化实现的，目的在于将抽象语法树保存在内存中，增加性能。</p>            <p></p>            <p>我们在这里不直接将抽象语法树转换为VNode，写一个极简的渲染模型，使用空的VNode模板进行渲染。</p>            <p></p>            <div class="codeMirror">                <pre><code>&lt;!DOCTYPE html>&lt;html lang="en">&lt;head>&lt;meta charset="UTF-8" />&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" />&lt;meta http-equiv="X-UA-Compatible" content="ie=edge" />&lt;title>Document</title>&lt;/head>  &lt;body>    &lt;div id="root">          &lt;p>&#123;&#123;name&#125;&#125;</p>          &lt;p>&#123;&#123;age&#125;&#125;</p>          &lt;p>&#123;&#123;gender&#125;&#125;</p>            &lt;div class="box">             &lt;p>box</p>            &lt;/div>    &lt;/div>    &lt;script>          // 将真正的DOM转换为VNode          function getVNode(node) &#123;            const nodeType = node.nodeType            let _vnode = null            if (nodeType === 1) &#123;              const nodeName = node.nodeName              const attrs = node.attributes              let _attrObj = &#123;&#125;              for (let i = 0; i < attrs.length; i++) &#123;                _attrObj[attrs[i].nodeName] = attrs[i].nodeValue              &#125;              _vnode = new VNode(nodeName, _attrObj, undefined, nodeType)                  // 考虑node的子元素              const childNodes = node.childNodes              for (let i = 0; i < childNodes.length; i++) &#123;                _vnode.appendChild(getVNode(childNodes[i]))              &#125;            &#125; else if (nodeType === 3) &#123;              _vnode = new VNode(undefined, undefined, node.nodeValue, nodeType)            &#125;            return _vnode          &#125;          // 将VNode转换为真正的DOM          function parseVNode(vnode) &#123;            // 创建真实的DOM节点            const type = vnode.type            let _node = null            if (type === 3) &#123;              // 创建文本节点              return document.createTextNode(vnode.value)            &#125; else if (type === 1) &#123;              _node = document.createElement(vnode.tag)              // 属性              const data = vnode.data // 现在这个data是键值对              Object.keys(data).forEach(key => &#123;                const attrName = key                const attrValue = data[key]                _node.setAttribute(attrName, attrValue)              &#125;)                  // 创建子元素              const children = vnode.children              children.forEach(subvnode => &#123;                _node.appendChild(parseVNode(subvnode))              &#125;)              return _node            &#125;          &#125;          const Mustache = /\&#123;\&#123;(.+?)\&#125;\&#125;/g          // 根据路径访问对象成员          function getValueByPath(obj, path) &#123;            const paths = path.split('.') // a.b.c            // 先取到a.b，再取到a.b.c            let res = obj            let prop = ''            // 如果没有值最后为undefined            while ((prop = paths.shift())) &#123;              res = res[prop]            &#125;            return res          &#125;          // 让模板与数据结合          function combine(vnode, data) &#123;            const _type = vnode.type            const _data = vnode.data            const _value = vnode.value            const _tag = vnode.tag            const _children = vnode.children                let _vnode = null            // 对文本节点的处理            if (_type === 3) &#123;              _parsedValue = _value.replace(Mustache, (_, g) =>                getValueByPath(data, g.trim())              )              _vnode = new VNode(_tag, _data, _parsedValue, _type)            &#125; else if (_type === 1) &#123;              // 元素节点              _vnode = new VNode(_tag, _data, _value, _type)              _children.forEach(_subvnode =>                _vnode.appendChild(combine(_subvnode, data))              )            &#125;            return _vnode          &#125;                      class VNode &#123;            constructor(tag, data, value, type) &#123;              this.tag = tag && tag.toLowerCase()              this.data = data              this.value = value              this.type = type              this.children = []            &#125;            appendChild(vnode) &#123;              this.children.push(vnode)            &#125;          &#125;              class MyVue &#123;            constructor(options) &#123;              this._options = options              this._data = options.data              this._el = options.el              const elm = document.querySelector(options.el) // 在Vue中这里是字符串，我们这里简化为DOM              this._template = elm              this._parent = elm.parentNode              this.mount() // 挂载            &#125;            mount() &#123;              // 需要提供一个render方法来生成虚拟DOM,引入Vue是可以传入自定义render方法的              //该方法让用户提供自定义的VNode              if (typeof this._options.render !== 'function') &#123;                this.render = this.createRenderFn() // 带有缓存              &#125;              this.mountComponent()            &#125;            mountComponent() &#123;              // 执行 mountComponent函数              const mount = function() &#123;                this.update(this.render())              &#125;              // 在Vue中其实是交给 watcher 来调用，现在就这样写              mount.call(this)            &#125;            /*              在真正的 Vue中使用了二次提交的设计结构              1.在页面中的DOM和虚拟DOM是一一对应的关系              2.先由 AST 和数据生成VNode（这个是新产生的VNode）              3.将原来的旧的VNode与新的VNode进行比较（使用diff算法），再更新（update）            */            // 这里是生成render函数，目的是缓存抽象语法树（现在这里我们先使用虚拟DOM来进行模拟）            createRenderFn() &#123;              const ast = getVNode(this._template)              // 在Vue中是直接：AST + DATA -> VNode                  // 我们这里做简化，将模板转换的直接的空的VNode转换为由数据的VNode              return function() &#123; // 带有缓存                const _tmp = combine(ast, this._data)                return _tmp              &#125;            &#125;                // 将虚拟DOM渲染到页面中，diff算法就在这个地方            update(vnode) &#123;              const realDOM = parseVNode(vnode)              // 对这个过程简化，直接生成 DOM 通过替换的方式到页面中去，真实情况不是这样全部替换              //而是通过diff算法一级一级比较然后改变原来的对象              this._parent.replaceChild(realDOM, document.querySelector(this._el))            &#125;          &#125;              const app = new MyVue(&#123;            el: '#root',            data: &#123;              name: '张三',              age: 18,              gender: '男'            &#125;          &#125;)        &lt;/script>  &lt;/body>&lt;/html></code></pre>            </div>        </div>        <p></p>        <div class="list" id="s3">            <h2>3.响应式原理</h2>            <p></p>            <p>Vue的响应式基本有着下面几点：</p>            <p></p>            <ul>                <li>在使用 Vue 时候, 赋值属性获得属性都是直接使用的 Vue 实例（通过this.xxx获取，而不是this._data.xxx）。</li>                <li>在涉及属性值的时候, 页面的数据更新。</li>            </ul>            <p></p>            <h3 id="s3.1">3.1 属性描述符</h3>            <p></p>            <p>在ES5之前，JavaScript 没有内置的机制来指定或者检查对象某个属性(property)的特性(characteristics)，比如某个属性是只读(readonly)的或者不能被枚举(enumerable)的。但是在 ES5之后，JavaScript 被赋予了这个能力，所有的对象属性都可以通过属性描述符(Property Descriptor)来指定。</p>            <p></p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp>let myObject = {}Object.defineProperty(myObject, 'a', {    value: 2,    writable: true, // 可写    configurable: true, // 可配置    enumerable: true // 可遍历  })// 上面的定义等同于 myObject.a = 2;// 所以如果不需要修改这三个特性，我们一般不会用 `Object.defineProperty`  console.log(myObject.a) // 2</xmp></pre>            </div>            <p></p>            <p>属性描述符的六个属性</p>            <p></p>            <ul>                <li>value：属性值</li>                <li>writable：是否允许赋值，true 表示允许，否则该属性不允许赋值</li>                <li>get：返回属性值的函数。如果为 undefined 则直接返回描述符中定义的 value 值</li>                <li>set：属性的赋值函数。如果为 undefined 则直接将赋值运算符右侧的值保存为属性值<br>注：</li>                <ul>                    <li>一旦同时使用了get和set，需要一个中间变量存储真正的值</li>                    <li>set和writable:false是不能共存的</li>                </ul>                <li>configurable：如果为 true，则表示该属性可以重新使用（Object.defineProperty(...) ）定义描述符，或者从属性的宿主删除。缺省为 true                    <div class="codeMirror">                        <pre><xmp>let myObject = {     a: 2}                              Object.defineProperty(myObject, 'a', {    value: 4,    writable: true,    configurable: false, // 不可配置!    enumerable: true  })    console.log(myObject.a) // 4  myObject.a = 5  // 因为最开始writable时true，所以不会影响到赋值  console.log(myObject.a) // 5    Object.defineProperty(myObject, 'a', {    value: 6,    writable: true,    configurable: true,    enumerable: true}) // TypeError</xmp></pre>                    </div>                </li>                <p></p>                <p>注：一旦某个属性被指定为 configurable: false，那么就不能从新指定为configurable: true 了，这个操作是单向，不可逆的</p>                <p>这个特性还会影响delete 操作的行为</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>let myObject = {    a: 2}                          Object.defineProperty(myObject, 'a', {    value: 4,    writable: true,    configurable: false, // 不可配置!    enumerable: true})delete myObject.aconsole.log(myObject.a) // 4</xmp></pre>                </div>                <p></p>                <li>enumerable：如果为 true，则表示遍历宿主对象时，该属性可以被遍历到（比如 for..in 循环中）。缺省为 true                    <div class="codeMirror">                        <pre><xmp>let myObject = {}Object.defineProperty(    myObject,    'a',    // make `a` enumerable, as normal    { enumerable: true, value: 2 }  )    Object.defineProperty(    myObject,    'b',    // make `b` NON-enumerable    { enumerable: false, value: 3 }  )  console.log(myObject.b) // 3  console.log('b' in myObject) // true  myObject.hasOwnProperty('b') // true    // .......  // 无法被遍历到  for (let k in myObject) {    console.log(k, myObject[k])  }  // "a" 2    myObject.propertyIsEnumerable('a') // true  myObject.propertyIsEnumerable('b') // false    Object.keys(myObject) // ["a"]  Object.getOwnPropertyNames(myObject) // ["a", "b"]</xmp></pre>                    </div>                </li>                <p></p>                <p></p>                <p>可以看出，enumerable: false 使得该属性从对象属性枚举操作中被隐藏，但Object.hasOwnProperty(...) 仍然可以检测到属性的存在。另外，Object.propertyIsEnumerable(..) 可以用来检测某个属性是否可枚举,Object.keys(...) 仅仅返回可枚举的属性，而Object.getOwnPropertyNames(...) 则返回该对象上的所有属性，包括不可枚举的</p>                <p></p>                <p></p>                <p></p>                <p>注：Object有专门操作属性的方法，在这里就不再多讲了</p>            </ul>            <p></p>            <h3 id="s3.2">3.2 Vue中使用属性描述符</h3>            <p></p>            <p>在Vue中因为全部依赖的是响应式，所以直接使用会有命名冲突的问题，我们使用闭包来解决这个问题</p>            <p></p>            <div class="codeMirror">                <pre><xmp>const o = {    name: '张三',    age: '18',    gender: '男'}// 简化后的版本function defineRective(target, key, value, enumerable) {    // 函数内部形成一个局部作用域，value只在内部使用（闭包，避免污染全局）    Object.defineProperty(target, key, {        configurable: true,        enumerable: !!enumerable,        get() {            console.log(`读取 o 的 ${key} 属性`) // 额外            return value        },        set(newValue) {            console.log(`设置 o 的 ${key} 属性为: ${newValue}`) // 额外            value = newValue        }    })}console.log(o) // {name: "张三", age: "18", gender: "男"}// 将对象转换为响应式的，会将原来的键值覆盖掉Object.keys(o).forEach(key => {    defineRective(o, key, o[key], true)})console.log(o) // {}</xmp></pre>            </div>            <p></p>            <p>但是，上面的只能对基本类型的数据进行响应式化，所以我们需要进行递归修改</p>            <p></p>            <div class="codeMirror">                <pre><xmp>const o = {    name: '张三',    age: '18',    gender: '男',    courses: [        {            name: '语文'        },        {            name: '数学'        }    ]}// 简化后的版本function defineRective(target, key, value, enumerable) {    // 函数内部形成一个局部作用域，value只在内部使用（闭包，避免污染全局）    if (        typeof value === 'object' &&        value !== null &&        !Array.isArray(value)    ) {        // 非数组引用类型        reactify(value)    }    Object.defineProperty(target, key, {        configurable: true,        enumerable: !!enumerable,        get() {            console.log(`获取${key}属性`)            return value        },        set(newValue) {            console.log(`设置${key}属性`)            value = newValue        }    })}function reactify(o) {    Object.keys(o).forEach(key => {        // 将对象转换为响应式的，会将原来的键值覆盖掉        /*          1.判断这个属性是否为引用类型，是否是数组          2.          （1）如果是引用类型就递归，如果不是就不需要          （2）如果是数组，需要循环数组，然后将数组里面的元素进行响应式话        */        // 数组        if (Array.isArray(o[key])) {            o[key].forEach(value => reactify(value))        } else {            // 对象或值类型            defineRective(o, key, o[key], true)        }    })}reactify(o)console.log(o) </xmp></pre>            </div>            <p></p>            <h3 id="s3.3">3.3 Vue中对数组方法的扩展</h3>            <p></p>            <p>对于对象和数组添加新的属性时也需要做到响应式，在Vue官方文档中可以通过$set方法进行设置，都是使用递归来进行响应式化，但是数组的的一些改变原数组的方法在调用时也需要有响应式化，如：</p>            <p></p>            <ul>                <li>push</li>                <li>pop</li>                <li>shift</li>                <li>unshift</li>                <li>reverse</li>                <li>sort</li>                <li>splice</li>            </ul>            <p></p>            <p>我们需要在改变数组的数据的时候, 发出通知，将新加入的元素变成响应式的</p>            <p></p>            <p>注意：在 Vue 2.x 中，因为使用的是 Object 的defineProperty方法, 数组发生变化, 设置 length 没法通知 ( Vue 3 中使用 Proxy 语法 ES6 的语法解决了这个问题 )</p>            <p></p>            <h4 id="s3.3.1">3.3.1 扩展函数功能</h4>            <p></p>            <p>如果一个函数已经定义了, 但是我们需要扩展其功能, 我们一般的处理办法:</p>            <p></p>            <ol>                <li>使用一个临时的函数名存储函数</li>                <li>重新定义原来的函数</li>                <li>定义扩展的功能</li>                <li>调用临时的那个函数</li>            </ol>            <p></p>            <h4 id="s3.3.2">3.3.2 Vue中的拦截数组</h4>            <p></p>            <p>如果要修改数组的方法，我们不能通过直接修改数组的prototype，因为这样会将所有的数组方法都改了，而是修改要进行响应式化的数组的原型 ( __proto__ )。</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp>const ARRAY_METHOD = [    'push',    'pop',    'shift',    'unshift',    'reverse',    'sort',    'splice']// 原型式继承：修改原型链的结构let arr = []let array_method = Object.create(Array.prototype)ARRAY_METHOD.forEach(method => {    array_method[method] = function() {            //调用原来的方法            console.log(`调用拦截的${method}方法`)            // 将数据进行响应式化            const res = Array.prototype[method].apply(this, arguments)            return res    }})arr.__proto__ = array_method/*    Vue的源码中也做了这样的办法：    1.如果浏览器支持__proto__就放原型上    2.如果不支持Vue使用的混入的方法，Vue会挂载到当前对象上*/</xmp></pre>            </div>            <p></p>            <p>这样，在使用数组方法的时候就能够触发console.log了。</p>            <p></p>            <h4 id="s3.3.3">3.3.3 Vue中的拦截数组</h4>            <p></p>            <p>所以，在数组中要响应式需要再修改一下上面的reactify函数。同时，如果是直接用对象或者数组进行赋值，也需要响应式化，需要修改一下defineRective函数定义属性时候的set方法</p>            <p></p>            <p>注意：下面的代码在，直接赋值的响应式化只能够原来的值不是数组或者对象才行，数组和对象在一开始赋值的时候本身就不是一个响应式数据，而是它的成员或属性才是，所以直接赋值的时候并不会触发set方法，在之后会单独再进行修改。</p>            <p></p>            <div class="codeMirror">                <pre><xmp>function defineRective(target, key, value, enumerable) {    // 函数内部形成一个局部作用域，value只在内部使用（闭包，避免污染全局）    if (        typeof value === 'object' &&        value !== null &&        !Array.isArray(value)    ) {        // 非数组引用类型        reactify(value)    }    Object.defineProperty(target, key, {        configurable: true,        enumerable: !!enumerable,        get() {            console.log(`获取${key}属性`)            return value        },        set(newValue) {            console.log(`设置${key}属性`)            // 如果是数组等直接赋值，也需要响应式化            value = newValue            reactify(value)        }    })}function reactify(o) {    Object.keys(o).forEach(key => {        // 将对象转换为响应式的，会将原来的键值覆盖掉        /*          1.判断这个属性是否为引用类型，是否是数组          2.          （1）如果是引用类型就递归，如果不是就不需要          （2）如果是数组，需要循环数组，然后将数组里面的元素进行响应式话        */        // 数组        if (Array.isArray(o[key])) {            // 现在的数组就是响应式            o[key].__proto__ = array_method            o[key].forEach(value => reactify(value))        } else {            // 对象或值类型            defineRective(o, key, o[key], true)        }    })}</xmp></pre>            </div>            <p></p>            <h4 id="s3.3.4">3.3.4 响应式刷新页面</h4>            <p></p>            <p>将响应式读取数据与前面的模板页面相结合，就能够做到响应式刷新页面了</p>            <p></p>            <p>下面是集成上面代码的一个简易框架：</p>            <p></p>            <div class="codeMirror">                <pre><code>&lt;!DOCTYPE html>&lt;html lang="en">&lt;head>&lt;meta charset="UTF-8" />&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" />&lt;meta http-equiv="X-UA-Compatible" content="ie=edge" />&lt;title>Document&lt;/title>&lt;/head>&lt;body>  &lt;div id="root">     &lt;p>&#123;&#123;name&#125;&#125;</p>     &lt;p>&#123;&#123;age&#125;&#125;</p>     &lt;p>&#123;&#123;gender&#125;&#125;</p>    &lt;div class="box">    &lt;p>box</p>    &lt;/div>  &lt;/div>&lt;script>          const ARRAY_METHOD = [            'push',            'pop',            'shift',            'unshift',            'reverse',            'sort',            'splice'          ]              // 原型式继承：修改原型链的结构          const array_method = Object.create(Array.prototype)              ARRAY_METHOD.forEach(method => &#123;            array_method[method] = function() &#123;              // 将数据进行响应式化              for (let i = 0; i < arguments.length; i++) &#123;                // 因为缺陷，这里无法传入vm                reactify(arguments[i])              &#125;                  //调用原来的方法              const res = Array.prototype[method].apply(this, arguments)              return res            &#125;          &#125;)              // 简化后的版本          function defineRective(target, key, value, enumerable) &#123;            // 函数内部形成一个局部作用域，value只在内部使用（闭包，避免污染全局）            // 折中处理后的Vue实例            const _this = this                if (              typeof value === 'object' &&              value !== null &&              !Array.isArray(value)            ) &#123;              // 非数组引用类型              reactify(value)            &#125;                Object.defineProperty(target, key, &#123;              configurable: true,              enumerable: !!enumerable,              get() &#123;                console.log(`获取$&#123;key&#125;属性`)                return value              &#125;,              set(newValue) &#123;                console.log(`设置$&#123;key&#125;属性`)                value = newValue                if (typeof value === 'object' && value !== null) &#123;                  reactify(value)                &#125;                // 进行模板刷新，因为要获取Vue实例，这里就通过传入参数的形式获取，真实的Vue是通过watcher来获取的，以后会有修改                _this.mountComponent()              &#125;            &#125;)          &#125;          function reactify(o, vm) &#123;            Object.keys(o).forEach(key => &#123;              // 将对象转换为响应式的，会将原来的键值覆盖掉              /*              1.判断这个属性是否为引用类型，是否是数组              2.              （1）如果是引用类型就递归，如果不是就不需要              （2）如果是数组，需要循环数组，然后将数组里面的元素进行响应式话            */              // 数组              if (Array.isArray(o[key])) &#123;                // 现在的数组就是响应式                o[key].__proto__ = array_method                o[key].forEach(value => reactify(value, vm))              &#125; else &#123;                // 对象或值类型                defineRective.call(vm, o, key, o[key], true)              &#125;            &#125;)          &#125;          // 将真正的DOM转换为VNode          function getVNode(node) &#123;            const nodeType = node.nodeType            let _vnode = null            if (nodeType === 1) &#123;              const nodeName = node.nodeName              const attrs = node.attributes              let _attrObj = &#123;&#125;              for (let i = 0; i < attrs.length; i++) &#123;                _attrObj[attrs[i].nodeName] = attrs[i].nodeValue              &#125;              _vnode = new VNode(nodeName, _attrObj, undefined, nodeType)                  // 考虑node的子元素              const childNodes = node.childNodes              for (let i = 0; i < childNodes.length; i++) &#123;                _vnode.appendChild(getVNode(childNodes[i]))              &#125;            &#125; else if (nodeType === 3) &#123;              _vnode = new VNode(undefined, undefined, node.nodeValue, nodeType)            &#125;            return _vnode          &#125;          // 将VNode转换为真正的DOM          function parseVNode(vnode) &#123;            // 创建真实的DOM节点            const type = vnode.type            let _node = null            if (type === 3) &#123;              // 创建文本节点              return document.createTextNode(vnode.value)            &#125; else if (type === 1) &#123;              _node = document.createElement(vnode.tag)              // 属性              const data = vnode.data // 现在这个data是键值对              Object.keys(data).forEach(key => &#123;                const attrName = key                const attrValue = data[key]                _node.setAttribute(attrName, attrValue)              &#125;)                  // 创建子元素              const children = vnode.children              children.forEach(subvnode => &#123;                _node.appendChild(parseVNode(subvnode))              &#125;)              return _node            &#125;          &#125;          const Mustache = /\&#123;\&#123;(.+?)\&#125;\&#125;/g          // 根据路径访问对象成员          function getValueByPath(obj, path) &#123;            const paths = path.split('.') // a.b.c            // 先取到a.b，再取到a.b.c            let res = obj            let prop = ''            // 如果没有值最后为undefined            while ((prop = paths.shift())) &#123;              res = res[prop]            &#125;            return res          &#125;          // 让模板与数据结合          function combine(vnode, data) &#123;            const _type = vnode.type            const _data = vnode.data            const _value = vnode.value            const _tag = vnode.tag            const _children = vnode.children                let _vnode = null            // 对文本节点的处理            if (_type === 3) &#123;              _parsedValue = _value.replace(Mustache, (_, g) =>                getValueByPath(data, g.trim())              )              _vnode = new VNode(_tag, _data, _parsedValue, _type)            &#125; else if (_type === 1) &#123;              // 元素节点              _vnode = new VNode(_tag, _data, _value, _type)              _children.forEach(_subvnode =>                _vnode.appendChild(combine(_subvnode, data))              )            &#125;            return _vnode          &#125;          class VNode &#123;            constructor(tag, data, value, type) &#123;              this.tag = tag && tag.toLowerCase()              this.data = data              this.value = value              this.type = type              this.children = []            &#125;            appendChild(vnode) &#123;              this.children.push(vnode)            &#125;          &#125;              class MyVue &#123;            constructor(options) &#123;              this._options = options              this._data = options.data              reactify(this._data, this) // 先传入实例              this._el = options.el              const elm = document.querySelector(options.el) // 在Vue中这里是字符串，我们这里简化为DOM              this._template = elm              this._parent = elm.parentNode              this.mount() // 挂载            &#125;            mount() &#123;              // 需要提供一个render方法来生成虚拟DOM,引入Vue是可以传入自定义render方法的，该方法让用户提供自定义的VNode              if (typeof this._options.render !== 'function') &#123;                this.render = this.createRenderFn() // 带有缓存              &#125;              this.mountComponent()            &#125;            mountComponent() &#123;              // 执行 mountComponent函数              const mount = function() &#123;                this.update(this.render())              &#125;              // 在Vue中其实是交给 watcher 来调用，现在就这样写              mount.call(this)            &#125;            /*              在真正的 Vue中使用了二次提交的设计结构              1.在页面中的DOM和虚拟DOM是一一对应的关系              2.先由 AST 和数据生成VNode（这个是新产生的VNode）              3.将原来的旧的VNode与新的VNode进行比较（使用diff算法），再更新（update）            */            // 这里是生成render函数，目的是缓存抽象语法树（现在这里我们先使用虚拟DOM来进行模拟）            createRenderFn() &#123;              const ast = getVNode(this._template)              // 在Vue中是直接：AST + DATA -> VNode                  // 我们这里做简化，将模板转换的直接的空的VNode转换为由数据的VNode              return function() &#123;                const _tmp = combine(ast, this._data)                return _tmp              &#125;            &#125;                // 将虚拟DOM渲染到页面中，diff算法就在这个地方            update(vnode) &#123;              const realDOM = parseVNode(vnode)              // 对这个过程简化，直接生成 DOM 通过替换的方式到页面中去，真实情况不是这样全部替换，而是通过diff算法一级一级比较然后改变原来的对象              this._parent.replaceChild(realDOM, document.querySelector(this._el))            &#125;          &#125;              const app = new MyVue(&#123;            el: '#root',            data: &#123;              name: '张三',              age: 18,              gender: '男',              datas: &#123;                info: '11'              &#125;            &#125;          &#125;)    &lt;/script>  &lt;/body>&lt;/html></code></pre>            </div>            <p></p>            <h4 id="s3.3.5">3.3.5 代理方法</h4>            <p></p>            <p>代理方法的实现就是将Vue上的this._data上的成员映射到this上。由于需要在更新数据的时候，更新页面的内容，所有this._data访问的成员与this访问的成员应该是同一个成员</p>            <p></p>            <p>我们现在对我们自己的简易框架做一点修改：</p>            <p></p>            <div class="codeMirror">                <pre><xmp>class MyVue {    constructor(options) {        this._options = options        this._data = options.data        this._el = options.el        const elm = document.querySelector(options.el) // 在Vue中这里是字符串，我们这里简化为DOM        this._template = elm        this._parent = elm.parentNode        // <------------------------------>        this.initData() // 将data进行响应式转换，代理        // <------------------------------>        this.mount() // 挂载    }    mount() {        // 需要提供一个render方法来生成虚拟DOM,引入Vue是可以传入自定义render方法的，该方法让用户提供自定义的VNode        if (typeof this._options.render !== 'function') {            this.render = this.createRenderFn() // 带有缓存        }        this.mountComponent()    }    mountComponent() {        // 执行 mountComponent函数        const mount = function() {            this.update(this.render())        }        // 在Vue中其实是交给 watcher 来调用，现在就这样写        mount.call(this)    }    /*          在真正的 Vue中使用了二次提交的设计结构          1.在页面中的DOM和虚拟DOM是一一对应的关系          2.先由 AST 和数据生成VNode（这个是新产生的VNode）          3.将原来的旧的VNode与新的VNode进行比较（使用diff算法），再更新（update）        */    // 这里是生成render函数，目的是缓存抽象语法树（现在这里我们先使用虚拟DOM来进行模拟）    createRenderFn() {        const ast = getVNode(this._template)        // 在Vue中是直接：AST + DATA -> VNode        // 我们这里做简化，将模板转换的直接的空的VNode转换为由数据的VNode        return function() {            const _tmp = combine(ast, this._data)            return _tmp        }    }    // 将虚拟DOM渲染到页面中，diff算法就在这个地方    update(vnode) {        const realDOM = parseVNode(vnode)        // 对这个过程简化，直接生成 DOM 通过替换的方式到页面中去，真实情况不是这样全部替换，而是通过diff算法一级一级比较然后改变原来的对象        this._parent.replaceChild(realDOM, document.querySelector(this._el))    }    // <------------------------------------------->    initData() {        // 遍历this._data的成员，将属性转换为响应式，同时代理到实例上        Object.keys(this._data).forEach(key => {            // 响应式化            reactify(this._data, this)            // 代理            /*              将this._data[key]映射到this[key]上，就是提供代理，在访问this[key]的时候相当于是在访问this._data[key]            */            proxy(this, '_data', key)        })    }    // <------------------------------------------->}// <------------------------------------------->function proxy(target, prop, key) {    Object.defineProperty(target, key, {        enumerable: true,        configurable: true,        get() {            return target[prop][key]        },        set(newValue) {            target[prop][key] = newValue        }    })}// <-------------------------------------------></xmp></pre>            </div>        </div>        <div class="list" id="s4">            <h2>4.发布订阅模式</h2>            <p></p>            <p>发布订阅模式的目标是通过解耦, 让各个模块之间没有紧密的联系</p>            <p></p>            <p>在之前我们的简单模板中的处理办法是属性在更新的 时候调用mountComponent方法。但是这种方法目前还存在着问题</p>            <p></p>            <p>现在调用该方法更新的是全部的页面，也就是当前虚拟 DOM 对应的页面 DOM。</p>            <p></p>            <p>但是，在 Vue 中, 整个的更新是按照组件为单位进行断, 已节点为单位进行更新：</p>            <p></p>            <ul>                <li>如果代码中没有自定义组件，那么在比较算法的时候，会将全部的模板对应的虚拟 DOM 进行比较。</li>                <li>如果代码中含有自定义组件，那么在比较算法的时候，就会判断更新的是哪一些组件中的属性，只会判断更新数据的组件，其他组件不会更新。</li>            </ul>            <p></p>            <p>所以，我们的目标是如果修改了什么属性，就尽可能只更新这些属性对应的页面 DOM。</p>            <p></p>            <p>发布订阅模式 ( 形式不局限于函数, 形式可以是对象等 ) ：</p>            <p></p>            <ol>                <li>中间的全局的容器，用来存储可以被触发的东西（函数, 对象）。</li>                <li>需要一个方法，可以往容器中传入东西（函数, 对象）。</li>                <li>需要一个方法，可以将容器中的东西取出来使用（函数调用, 对象的方法调用）。</li>            </ol>            <p></p>            <h3 id="s4.1">4.1 事件模型</h3>            <p></p>            <p>总的来说发布订阅模式的一种事件就是创立一个事件模型，当需要更新的时候触发对应的事件实现更新。</p>            <p></p>            <p>该事件模型需要做到以下几点：</p>            <p></p>            <ul>                <li>有一个event对象。</li>                <li>有on，off，emit等绑定、取消、触发事件的方法。</li>                <li>通过event.on('事件名', 处理函数)订阅事件，可以同时对同一个事件订阅多个处理函数。</li>                <li>通过event.off()方法传入0、1、2个参数可以分别移除所有处理函数、对应事件名的所有处理函数和对应事件名的对应处理函数。</li>                <li>通过event.emit('事件名', 参数), 先前注册的事件处理函数就会依次调用。</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp>const event = (function() {    const eventObjs = {}    return {        /*            注册事件：可以连续注册，可以注册多个事件          */        on(type, handler) {            ;(eventObjs[type] || (eventObjs[type] = [])).push(handler)        },        /*            移除事件：            1.如果没有参数，移除所有事件            2.如果只带有事件名参数，就移除这个事件名下的所有事件            3.如果带有两个参数，那么就移除某一个事件的具体函数          */        off(type, handler) {            if (arguments.length === 0) {                // 没有参数，移除所有事件                eventObjs = {}            } else if (arguments.length === 1) {                eventObjs[type] = []                //只有事件类型，移除该事件的所有处理函数            } else if (arguments.length === 2) {                // 移除type事件的handler处理函数                // 使用循环移除所有的改函数对应的type事件                const _events = eventObjs[type]                if (!events) {                    return                }                // 循环数组，倒着防止序号影响                for (let i = _events.length - 1; i >= 0; i--) {                    if (_events[i] === handler) {                        _events.splice(i, 1)                    }                }            }        },        /*            发射事件：触发事件，包装事件，传递给事件处理函数          */        emit(type) {            const _events = eventObjs[type]            const args = Array.prototype.slice.call(arguments, 1) // 获得arguments从1开始后的所有参数，返回数组            if (!_events) {                return            }            for (let i = 0; i < _events.length; i++) {                _events[i].apply(null, args)            }        }    }})()/*    测试*///注册事件event.on('click', () => {    console.log('click event')})setTimeout(() => {    event.emit('click')}, 2000)</xmp></pre>            </div>            <p></p>            <h3 id="s4.2">4.2 Vue中的模型</h3>            <p></p>            <p>页面中的变更（diff）是以组件为单位的：</p>            <p></p>            <ul>                <li>如果页面中只有一个组件 ( Vue 实例 ), 不会有性能损失</li>                <li>但是如果页面中有多个组件（多 watcher 的一种情况），第一次会有多个组件的 watcher 存入到全局watcher容器中。如果修改了局部的数据（例如其中一个组件的数据），表示只会对该组件进行 diff 算法, 也就是说只会重新生成该组件的抽象语法树，只会访问该组件的 watcher，然后调用完改 watcher 后，再次往全局存储的该组件的新的 watcher ，页面更新的时候也就只需要更新一部分。</li>            </ul>        </div>        <p></p>        <div class="list" id="s5">            <h2>5.Flow</h2>            <p></p>            <p>Flow是一个静态的检测工具，语法与TypeScript类似，在 Vue 2.x 中是使用它来进行编码的，具体的用法可查看官方文档</p>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/Vue%E6%8F%92%E4%BB%B6/"/>
    <url>/CodeNote/2020/10/23/zone/html/Vue%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title">            <h1>Vue插件</h1>        </div>        <p></p>        <div class="list" id="s1">            <h2>1.vue-codemirror</h2>            <p></p>            <div class="codeMirror">                <pre><xmp>npm i codemirror --save</xmp></pre>            </div>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><template>    <div class="in-coder-panel">        <textarea ref="textarea"></textarea>        <el-select class="code-mode-select" v-model="mode" @change="changeMode">          <el-option v-for="mode in modes" :key="mode.value" :label="mode.label" :value="mode.value"></el-option>        </el-select>      </div></template>    <script>    // 引入全局实例    import _CodeMirror from 'codemirror'        // 核心样式    import 'codemirror/lib/codemirror.css'    // 引入主题后还需要在 options 中指定主题才会生效    import 'codemirror/theme/cobalt.css'        // 需要引入具体的语法高亮库才会有对应的语法高亮效果    // codemirror 官方其实支持通过 /addon/mode/loadmode.js 和 /mode/meta.js 来实现动态加载对应语法高亮库    // 但 vue 貌似没有无法在实例初始化后再动态加载对应 JS ，所以此处才把对应的 JS 提前引入    import 'codemirror/mode/javascript/javascript.js'    import 'codemirror/mode/css/css.js'    import 'codemirror/mode/xml/xml.js'    import 'codemirror/mode/clike/clike.js'    import 'codemirror/mode/markdown/markdown.js'    import 'codemirror/mode/python/python.js'    import 'codemirror/mode/r/r.js'    import 'codemirror/mode/shell/shell.js'    import 'codemirror/mode/sql/sql.js'    import 'codemirror/mode/swift/swift.js'    import 'codemirror/mode/vue/vue.js'        // 尝试获取全局实例    const CodeMirror = window.CodeMirror || _CodeMirror        export default {      name: 'in-coder',      props: {        // 外部传入的内容，用于实现双向绑定        value: String,        // 外部传入的语法类型        language: {          type: String,          default: null        }      },      data() {        return {          // 内部真实的内容          code: '',          // 默认的语法类型          mode: 'javascript',          // 编辑器实例          coder: null,          // 默认配置          options: {            // 缩进格式            tabSize: 2,            // 主题，对应主题库 JS 需要提前引入            theme: 'cobalt',            // 显示行号            lineNumbers: true,            line: true          },          // 支持切换的语法高亮类型，对应 JS 已经提前引入          // 使用的是 MIME-TYPE ，不过作为前缀的 text/ 在后面指定时写死了          modes: [            {              value: 'css',              label: 'CSS'            },            {              value: 'javascript',              label: 'Javascript'            },            {              value: 'html',              label: 'XML/HTML'            },            {              value: 'x-java',              label: 'Java'            },            {              value: 'x-objectivec',              label: 'Objective-C'            },            {              value: 'x-python',              label: 'Python'            },            {              value: 'x-rsrc',              label: 'R'            },            {              value: 'x-sh',              label: 'Shell'            },            {              value: 'x-sql',              label: 'SQL'            },            {              value: 'x-swift',              label: 'Swift'            },            {              value: 'x-vue',              label: 'Vue'            },            {              value: 'markdown',              label: 'Markdown'            }          ]        }      },      mounted() {        // 初始化        this._initialize()      },      methods: {        // 初始化        _initialize() {          // 初始化编辑器实例，传入需要被实例化的文本域对象和默认配置          this.coder = CodeMirror.fromTextArea(this.$refs.textarea, this.options)          // 编辑器赋值          this.coder.setValue(this.value || this.code)              // 支持双向绑定          this.coder.on('change', coder => {            this.code = coder.getValue()                if (this.$emit) {              this.$emit('input', this.code)            }          })              // 尝试从父容器获取语法类型          if (this.language) {            // 获取具体的语法类型对象            let modeObj = this._getLanguage(this.language)                // 判断父容器传入的语法是否被支持            if (modeObj) {              this.mode = modeObj.label            }          }        },        // 获取当前语法类型        _getLanguage(language) {          // 在支持的语法类型列表中寻找传入的语法类型          return this.modes.find(mode => {            // 所有的值都忽略大小写，方便比较            let currentLanguage = language.toLowerCase()            let currentLabel = mode.label.toLowerCase()            let currentValue = mode.value.toLowerCase()                // 由于真实值可能不规范，例如 java 的真实值是 x-java ，所以讲 value 和 label 同时和传入语法进行比较            return (              currentLabel === currentLanguage || currentValue === currentLanguage            )          })        },        // 更改模式        changeMode(val) {          // 修改编辑器的语法配置          this.coder.setOption('mode', `text/${val}`)              // 获取修改后的语法          let label = this._getLanguage(val).label.toLowerCase()              // 允许父容器通过以下函数监听当前的语法值          this.$emit('language-change', label)        }      }    }    </script>    <style lang="less" scoped>    .in-coder-panel {      flex-grow: 1;      display: flex;      position: relative;      .CodeMirror {        flex-grow: 1;        z-index: 1;        .CodeMirror-code {          line-height: 19px;        }      }      .code-mode-select {        position: absolute;        z-index: 2;        right: 10px;        top: 10px;        max-width: 130px;      }    }</style></xmp></pre>            </div>        </div>        <div class="list" id="s2">            <h2>2.vue-json-viewer</h2>            <p></p>            <p></p>            <p>将json字符串在网页显示出来，可伸缩</p>            <p></p>            <div class="codeMirror">                <pre><xmp>npm install vue-json-viewer --save</xmp></pre>            </div>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><template> <div class="app-container">    <div>        <el-collapse v-model="activeNames">          <el-collapse-item            v-for="(item,index) in dataList"            :name="index+1"            :key="index"            :title="item.name"          >            <el-row :gutter="100">              <el-col :span="11">                <div>                  <json-viewer :value="item.value"></json-viewer>                </div>              </el-col>              <el-col :span="11">                <div>                  <json-viewer :value="item.value"></json-viewer>                </div>              </el-col>            </el-row>          </el-collapse-item>        </el-collapse>      </div>    </div>  </template>    <script>  import JsonViewer from 'vue-json-viewer'  export default {    components: {      'json-viewer': JsonViewer    },    data() {      return {        activeNames: [],        dataList: [          {            name: '1',            value: {              total: 25,              limit: 10,              skip: 0,              links: {                previous: undefined,                next: function() {}              }            }          },          {            name: '2',            value: {              total: 25,              limit: 10,              skip: 0,              links: {                previous: undefined,                next: function() {}              }            }          }        ]      }    }  }  </script>  <style lang='scss' scoped>  </style></xmp></pre>            </div>            <p></p>            <p>具体属性</p>            <p></p>            <img src="../image/1584558445041-ec9a3307-7895-410e-8849-762e65c4c769.png" alt="" srcset="" width="750px">        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/Vue.js/"/>
    <url>/CodeNote/2020/10/23/zone/html/Vue.js/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title">            <h1>Vue.js</h1>        </div>        <p></p>        <div class="list" id="s1">            <h2>1.Vue的特性</h2>            <p></p>            <p>Vue是一套用于构建用户界面的渐进式框架,与其它大型框架不同的是,Vue 被设计为可以自底向上逐层应用,Vue拥有以下特性:</p>            <p></p>            <ul>                <li>组件化思想</li>                <li>模板的使用和数据渲染非常灵活，层次结构鲜明</li>                <li>简单的语法并能够简单快速构建一个项目</li>                <li>轻量级，体积小渲染速度更快</li>                <li>Vue采用的脚手架工具为vue-cli</li>                <li>初期是尤雨溪维护，现在有加入的团队组织个人提供技术一同维护迭代更新</li>                <li>Vue中指令和组件分得更清晰。指令只封装 DOM 操作,而组件代表一个自给自足的独立单元,都拥有有自己的视图样式和数据逻辑</li>            </ul>        </div>        <p></p>        <div class="list" id="s2">            <h2>2.绑定Vue对象</h2>            <p></p>            <p>Vue也是一个构造函数,通过new Vue()可以创建一个Vue对象,通过Vue对象进行对DOM元素以及内部的子孙元素的操作</p>            <p></p>            <div class="codeMirror">                <pre><xmp><div id="div">        &#123;&#123;msg&#125;&#125;<!--显示123-->    </div>    <script>        new Vue({            el:"#div",            /*            在Vue中通过el属性来绑定一个DOM元素,从而让该DOM元素以及内部都绑定Vue的相关操作,            一般是通过ID进行查找,因为这样才能够精确绑定            */            data:{//data属性中包含着在el中使用的使用的变量或属性                msg:123            }            //也可以使用函数形式的            data(){            return{                msg:123            };            //methods属性包含着需要使用的方法            methods:{                show(){                    console.log(this.msg);                }            }        }        })        </script></xmp></pre>            </div>            <p></p>            <p></p>            <p>注:在实例内部使用定义的属性或方法时不能直接使用,必须通过this来指定需要用的属性</p>            <p></p>            <h3 id="s2.1">2.1 vm.$mount</h3>            <p></p>            <p>如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 vm.$mount() 手动地挂载一个未挂载的实例</p>            <p></p>            <p></p>            <p>注意:这个方法返回实例自身,因而可以链式调用其它实例方法</p>            <p></p>            <div class="codeMirror">                <pre><xmp>var MyComponent = Vue.extend({        template: '<div>Hello!</div>'    })                          // 创建并挂载到 #app (会替换 #app)    new MyComponent().$mount('#app')        // 同上    new MyComponent({ el: '#app' })        // 或者，在文档之外渲染并且随后挂载    var component = new MyComponent().$mount()    document.getElementById('app').appendChild(component.$el)</xmp></pre>            </div>        </div>        <p></p>        <div class="list" id="s3">            <h2>3.基本指令</h2>            <p></p>            <h3 id="s3.1">3.1 v-text</h3>            <p></p>            <p>v-text,该指令的用法同原生JS中的innerText,更新绑定元素内部的文本内容</p>            <p></p>            <div class="codeMirror">                <pre><code>&lt;div id="div">&lt;span v-text="msg"></span><!--不会有闪烁问题-->    <!-- 和下面的一样 -->    &lt;span>&#123;&#123;msg&#125;&#125;</span>&lt;/div></code></pre>            </div>            <p></p>            <p></p>            <h3 id="s3.2">3.2 v-html</h3>            <p></p>            <p>v-html,该指令用法同原生JS的innerHTML,可以解析内部的HTML标签</p>            <p></p>            <h3 id="s3.3">3.3 v-cloak</h3>            <p></p>            <p>v-cloak,该指令CSS一起使用,用于隐藏还没有开始编译的&#123;&#123;&#125;&#125;(插值表达式)直到编译完成,解决其闪烁问题</p>            <p></p>            <div class="codeMirror">                <pre><xmp>[v-cloak] {        display: none;/*如果没有起作用可能是由于优先级不够导致的,可以加上!important提高优先级*/    }</xmp></pre>            </div>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><div v-cloak>    &#123;&#123; message &#125;&#125;    </div></xmp></pre>            </div>            <p></p>            <h3 id="s3.4">3.4 v-show</h3>            <p></p>            <p>v-show,该指令用于显示和隐藏DOM元素,根据表达式之真假值,切换元素的display属性值</p>            <p></p>            <p>注意:</p>            <p></p>            <ul>                <li>当条件变化时该指令触发过渡效果</li>                <li>v-show指令不支持在&lt; template>&lt; /template>标签上写,也不支持v-else,一般来说,v-if 有更高的切换开销,而 v-show 有更高的初始渲染开销。因此,如果需要非常频繁地切换,则使用 v-show 较好,如果在运行时条件很少改变,则使用 v-if 较好</li>            </ul>            <p></p>            <h3 id="s3.5">3.5 v-if,v-else与v-else-if</h3>            <p></p>            <ul>                <li>v-if,该指令用于是否渲染DOM元素,传入一个布尔值,通过该布尔值的条件改变实现对于DOM元素的删除和重建,该指令不同于v-show,而是会完全销毁这个DOM元素<br/>>:当条件变化时该指令触发过渡效果</li>                <li>v-else,该指令用于不需要任何表达式,但是在该指令的前一个兄弟元素必须有v-if或者v-else-if指令,该指令的用处是为v-if 或者 v-else-if添加else的选项                    <div class="codeMirror">                        <pre><xmp><div v-if="Math.random() > 0.5">        Now you see me    </div>    <div v-else>        Now you don't    </div></xmp></pre>                    </div>                </li>                <li>v-else-if,该指令用于用于v-if的else if选项,前一个兄弟元素必须要v-if指令,并且该指令可以链式调用,也就是说可以调用多次v-else-if指令                    <div class="codeMirror">                        <pre><xmp><div v-if="type === 'A'">         A    </div>        <div v-else-if="type === 'B'">        B    </div>    <div v-else-if="type === 'C'">        C    </div>    <div v-else>        Not A/B/C    </div></xmp></pre>                    </div>                </li>            </ul>            <p></p>            <h3 id="s3.6">3.6 v-for</h3>            <p></p>            <p>v-for,该指令可以基于源数据多次渲染元素或模板块,用于循环遍历某个数组或对象,如果只用一个变量代表得到是数组或对象的value值</p>            <p></p>            <p>注意:在内部必须使用固定的item in/of items形式的特殊语法(下面的in都可以用of代替,并且更符合实际)</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><ul id="example-1">        <li v-for="item in items">            &#123;&#123; item.message &#125;&#125; <!--Foo Bar-->        </li>      </ul>      <script>      var example1 = new Vue({        el: '#example-1',        data: {          items: [            { message: 'Foo' },            { message: 'Bar' }          ]        }      })      </script></xmp></pre>            </div>            <p></p>            <p></p>            <ul>                <li>遍历数组时其实还支持第二个变量,代表的是遍历数组的索引值                    <div class="codeMirror">                        <pre><xmp><ul id="example-2">        <li v-for="(item, index) in items">            &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;            <!--                Parent-0-Foo                Parent-1-Bar            -->          </li>    </ul>    <script>        var example2 = new Vue({          el: '#example-2',          data: {            parentMessage: 'Parent',            items: [              { message: 'Foo' },              { message: 'Bar' }            ]          }        })    </script></xmp></pre>                    </div>                </li>                <li>遍历对象时还可以接受第二三两个变量,分别代表了键名和索引值                    <div class="codeMirror">                        <pre><xmp><ul id="v-for-object" class="demo">    <div v-for="(value, key, index) in object">        &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;        <!--          0. firstName: John          1. lastName: Doe          2. age: 30         -->    </div>    </ul>    <script>          new Vue({              el: '#v-for-object',              data: {                  object: {                      firstName: 'John',                      lastName: 'Doe',                      age: 30                  }              }    })    </script></xmp></pre>                    </div>                </li>                <li>该指令还可以遍历一个整数,遍历的量会分别从1开始得到赋值直到到这个整数的值                    <div class="codeMirror">                        <pre><xmp><p v-for="count in 10">&#123;&#123;count&#125;&#125;</p>    //1 2 3 4 5 6 7 8 9 10</xmp></pre>                    </div>                </li>            </ul>            <p></p>            <p>注意:当v-for和v-if处于同一节点时,v-for 的优先级比 v-if更高，这意味着 v-if将分别重复运行于每个 v-for循环中,当想为仅有的一些项渲染节点时,这种优先级的机制会十分有用</p>            <p></p>            <div class="codeMirror">                <pre><xmp><li v-for="todo in todos" v-if="!todo.isComplete">        &#123;&#123; todo &#125;&#125;    </li>    <!--    官方并不建议v-for和v-if指令一起使用,如果要使用这种方式,就进行条件渲染    -->                          <!--    如果想有条件才继续v-for指令,则可以将v-if置于外层元素(或<template>)上    -->    <ul v-if="todos.length">        <li v-for="todo in todos">            &#123;&#123; todo &#125;&#125;        </li>    </ul>    <p v-else>No todos left!</p>    <!--        条件渲染        v-if如果想只写一个而同时切换多个元素,可以在最外成包裹一层<template></template>标签,在这个标签上面        使用v-if,在渲染的时候并不会将<template>标签渲染出来    --></xmp></pre>            </div>            <p></p>            <h3 id="s3.7">3.7 v-bind</h3>            <p></p>            <p>v-bind,该指令用于动态绑定一个或多个特性,该方法绑定的特性与普通的属性效果一致,只是其内部会被解析为JS表达式,而不是普通特性一样会是一个字符串</p>            <p></p>            <p>修辞符:</p>            <p></p>            <ul>                <li>.prop - 被用于绑定 DOM 属性(property)</li>                <li>.camel - 将短横线命名法特性名转换为驼峰命名法</li>                <li>.sync - 会扩展成一个更新父组件绑定值的 v-on 侦听器</li>            </ul>            <p></p>            <p>注意:</p>            <p></p>            <ul>                <li>该指令有其简写写法,通过:来代替v-bind:</li>                <li>该指令可以动态对绑定的参数进行改变,参数用[]括起来</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><!-- 绑定一个属性 -->    <img v-bind:src="imageSrc">                 <!-- 动态特性名 (2.6.0+) -->    <button v-bind:[key]="value"></button>                            <!-- 缩写 -->    <img :src="imageSrc">        <!-- 动态特性名缩写 (2.6.0+) -->    <button :[key]="value"></button>        <!-- 内联字符串拼接 -->    <img :src="'/path/to/images/' + fileName">                                      <!-- class 绑定 -->     <div :class="{ red: isRed }"></div><!--对象通过布尔值确定是否传入class中-->     <div :class="[classA, classB]"></div><!--数组会直接将类名传入到class中-->     <div :class="[classA, { classB: isB, classC: isC }]"><!--对象和数组可以混用-->                          <!-- style 绑定 -->    <div :style="{ fontSize: size + 'px' }"></div><!--通过对象写入每个属性-->    <div :style="[styleObjectA, styleObjectB]"></div><!--数组的成员中实际是一个个对象-->          <!-- 绑定一个有属性的对象 -->    <div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>                              <!-- 通过 prop 修饰符绑定 DOM 属性 -->    <div v-bind:text-content.prop="text"></div>                                     <!-- prop 绑定。“prop”必须在 my-component 中声明。-->      <my-component :prop="someThing"></my-component>                                  <!-- 通过 $props 将父组件的 props 一起传给子组件 -->      <child-component v-bind="$props"></child-component>                           <!-- XLink -->      <svg><a :xlink:special="foo"></a></svg></xmp></pre>            </div>            <p></p>            <p></p>            <h3 id="s3.8">3.8 v-on</h3>            <p></p>            <p>v-on,该指令用于绑定监听事件,表达式可以是一个方法的名字或一个内联语句(也就是说在传入事件的时候可以选择加()可以选择不加(),推荐在传入参数的时候添加,在不传参的时候写事件名)</p>            <p></p>            <p>参数:该指令的参数为原生JS中的事件名,只不过没有on</p>            <p></p>            <p>修饰符</p>            <p></p>            <ul>                <li>.stop - 调用 event.stopPropagation(),会阻止本元素上的事件进行冒泡传播</li>                <li>.prevent - 调用 event.preventDefault(),不能和.passive一起使用</li>                <li>.capture - 添加事件侦听器时使用 capture 模式,父元素会执行在子元素上进行的同名事件</li>                <li>.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调,只会真正自己触发的事件才会进行,和.stop是有区别的,这个只会阻止自己的冒泡,但不会阻止该元素的父元素事件的冒泡进行</li>                <li>.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调,可以是表示键盘字符的数字或者表示特效事件的按键修饰符</li>                <li>.native - 监听组件根元素的原生事件,一个Vue实例内部通过只能v-on只能绑定自己内部的方法,不能绑定原生DOM事件的方法,通过该修饰符就可以使用原生JS的事件方法了</li>                <li>.once - 只触发一次回调</li>                <li>.left - 只当点击鼠标左键时触发</li>                <li>.right - 只当点击鼠标右键时触发</li>                <li>.middle - 只当点击鼠标中键时触发</li>                <li>.passive - 不用查找是否阻止默认事件的请求直接进行操作。如在滚动页面时的onscroll事件,每次触发事件时浏览器都会查看是否有阻止默认滚动事件的操作,但是如果本来就没有进行这个操作,在滚动的时候就会出现卡的的情况,因为在触发滚动条滚动时总会先查找请求,这个修饰符就是告诉浏览器不用进行查找直接进行滚动操作。因为作用的冲突,所以不能和.prevent一起使用</li>            </ul>            <p></p>            <p>注意:</p>            <p></p>            <ul>                <li>该指令有简写形式,通过@来代替v-on:</li>                <li>该指令可以动态对绑定的参数进行改变,参数用[]括起来</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><!-- 方法处理器 -->    <button v-on:click="doThis"></button>                            <!-- 动态事件 (2.6.0+) -->    <button v-on:[event]="doThis"></button>                            <!-- 内联语句 -->    <button v-on:click="doThat('hello', $event)"></button>          <!-- 缩写 -->    <button @click="doThis"></button>          <!-- 动态事件缩写 (2.6.0+) -->    <button @[event]="doThis"></button>        <!-- 停止冒泡 -->    <button @click.stop="doThis"></button>                 <!-- 阻止默认行为 -->    <button @click.prevent="doThis"></button>             <!-- 阻止默认行为，没有表达式 -->    <form @submit.prevent></form>             <!--  串联修饰符 -->    <button @click.stop.prevent="doThis"></button>             <!-- 键修饰符，键别名 -->    <input @keyup.enter="onEnter">                    <!-- 键修饰符，键代码 -->    <input @keyup.13="onEnter">                 <!-- 点击回调只会触发一次 -->    <button v-on:click.once="doThis"></button>          <!-- 对象语法 (2.4.0+) -->    <button v-on="{ mousedown: doThis, mouseup: doThat }"></button>          <!-- 组件中的自定义事件 -->    <my-component @my-event="handleThis"></my-component>          <!-- 内联语句 -->    <my-component @my-event="handleThis(123, $event)"></my-component>                              <!-- 组件中的原生事件 -->    <my-component @click.native="onClick"></my-component></xmp></pre>            </div>            <p></p>            <h3 id="s3.9">3.9 v-model</h3>            <p></p>            <p>v-model,该指令用于表单内的标签进行双向的数据绑定</p>            <p></p>            <p>注意:v-model只能绑定给input,textarea,select等表单元素和自定义的组件中,除此之外不能在其他标签上绑定</p>            <p></p>            <p></p>            <p>修辞符:</p>            <p></p>            <ul>                <li>.lazy - 取代 input监听 change 事件,默认在用户写入值时是使用的input事件,也就是当值输入完成后才会触发事件,而change是一些有输入法的语言在值还没有输入时就时刻监听改变</li>                <li>.number- 输入字符串转为有效的数字</li>                <li>.trim - 输入首尾空格过滤</li>            </ul>            <p></p>            <p>用法:</p>            <p></p>            <ul>                <li>如果是对input文本框和textarea绑定的,绑定的值会根据输入的内容,就是将内部的变量的值改为value中的值</li>                <li>如果是对复选框绑定的</li>                <ul>                    <li>如果绑定的变量不是数组,会根据复选框是否被选中而改变为false或true,即使原来不是布尔值也会被强制转换为布尔值,这是因为双向的数据绑定,如果是有多个复选框,那么则会一起被选中或不选中</li>                    <li>如果变量是数组则会将value属性中的值(没有写value属性会传入null)传入该数组作为其中的一个成员,Vue会根据数组内部的值来判断是否选中该复选框(内部其实就是这样运作的),如果value值一样会有多个复选框被选中,再次点击就会将该值删去然后取消复选框的选中</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp><div id='example'>    <input type="checkbox" id="jack" value="Jack" v-model="checkedNames">    <label for="jack">Jack</label>    <input type="checkbox" id="john" value="John" v-model="checkedNames">    <label for="john">John</label>    <input type="checkbox" id="mike" value="Mike" v-model="checkedNames">    <label for="mike">Mike</label>    <br>    <span>Checked names: &#123;&#123; checkedNames &#125;&#125;</span>    </div>                                                 <!--也可以在被选中和没被选择直接设置不同的值-->    <input    type="checkbox"    v-model="toggle"    true-value="yes"    false-value="no"    >    <!--    当选中时    vm.toggle === 'yes'    当没有选中时    vm.toggle === 'no'    注意:点击了才会改变值,如果没有点击过而变量本身有值的话就不会是fasle-value的值    --></xmp></pre>                </div>                <li>如果是对单选按钮进行绑定的,变量值会随着选中单选框的value值而变化,如果变量的值刚开始就是一个单选框的value值,那么就会自动选中这个单选框<br/>注意:</li>                <ul>                    <li>单选框和复选框即使不写相同的name而只绑定了相同的modle也会认做是一类单选框的,但是最好还是将name写上</li>                    <li>单选框和复选框都可以通过v-bind:value绑定的value值来设置值自身的value值</li>                </ul>                <li>如果是对选择框select进行绑定的,绑定的变量的值会随着选中的option选项内部的内容而发生变化,如果option没有写value属性,该变量会变成&lt; option> &lt;/option>内部的值,如果有value属性,变量会变成value值而不是option的内容</li>                <p></p>                <div class="codeMirror">                    <pre><xmp><div id="example">        <select v-model="selected">            <option disabled value="">请选择</option>            <option>A</option>            <option>B</option>            <option>C</option>        </select>          <span>Selected: &#123;&#123; selected &#125;&#125;</span>        </div>    <script>        new Vue({          el: '#example',          data: {            selected: ''          }        })    </script></xmp></pre>                </div>                <p></p>                <p>注意:在s多选时要绑定一个数组,将上方的selected:[]，这样在选入的时候就能将每个选择的选项的值加到变量中去,还可以是一个对象,但是要通过v-bind:value绑定</p>                <p></p>                <div class="codeMirror">                    <pre><xmp><select v-model="selected">        <!-- 内联对象字面量 -->        <option v-bind:value="{ number: 123 }">123</option>    </select></xmp></pre>                </div>            </ul>            <p></p>            <h3 id="s3.10">3.10 v-pre</h3>            <p></p>            <p>该指令不接受任何表达式,使用了该指令的元素Vue在编译时跳过这个元素和它的子元素的编译过程,可以用来显示原始的模板&#123;&#123;&#125;&#125;标签,跳过大量没有指令的节点会加快编译</p>            <p></p>            <h3 id="s3.11">3.11 v-once</h3>            <p></p>            <p>该指令不需要表达式,只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能</p>        </div>        <p></p>        <div class="list" id="s4">            <h2>4.绑定class和style</h2>            <p></p>            <h3 id="s4.1">4.1 绑定class</h3>            <p></p>            <ul>                <li>通过数组的书写传入:class形式绑定的类名                    <div class="codeMirror">                        <pre><xmp><h1 :class="['red','big']">Vue</h1></xmp></pre>                    </div>                </li>                <li>通过对象书写的形式绑定类名,对象中的属性名就是要传入的class名,而属性名对应的属性值为一个布尔值,可以是变量,如果是真就作为一个类名传入class中,如果是假的就不计入class中                    <div class="codeMirror">                        <pre><xmp><h1 :class="{red:true,big:true}">Vue</h1></xmp></pre>                    </div>                    <p></p>                    <p>注意:传入一个对象的时候完全可以在Vue的实例创建的时候传入变量,直接在class中写入变量名</p>                </li>                <li>传入三元表达式进行切换是否用该类名的判断                    <div class="codeMirror">                        <pre><xmp><h1 :class="['red',isActive?'big':'small']">Vue</h1></xmp></pre>                    </div>                </li>                <li>在数组中使用对象,可以使用该方法代替繁琐的三元表达式                    <div class="codeMirror">                        <pre><xmp><h1 :class="['red',{big:isActive}]">Vue</h1></xmp></pre>                    </div>                </li>            </ul>            <h3 id="s4.2">4.2 绑定style</h3>            <p></p>            <p>绑定的style样式可以通过驼峰命名法会短横线分割法进行命名(短横线命名需要在外层用单引号包住)</p>            <p></p>            <ul>                <li>直接在元素上同过:style的形式,通过对象的形式书写                    <div class="codeMirror">                        <pre><xmp><h1 :style="{color:'red','font-size':'40px'}">Vue</h1></xmp></pre>                    </div>                </li>                <li>将样式定义在data中,再引用到:style中                    <div class="codeMirror">                        <pre><xmp><h1 :style="foo">Vue</h1></xmp></pre>                    </div>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>data:{        foo:{color:'red','font-size':'40px'}    }</xmp></pre>                    </div>                </li>                <li>在:style中通过数组引用多个data中的样式对象,其实每个对象就相当于一个class,只是需要在data中设置                    <div class="codeMirror">                        <pre><xmp><h1 :style="[foo,foo2]">Vue</h1></xmp></pre>                    </div>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>data:{        foo:{color:'red','font-size':'40px'},        foo2:{fontWight:200}//驼峰命名法也可以    }</xmp></pre>                    </div>                </li>            </ul>        </div>        <p></p>        <div class="list" id="s5">            <h2>5.过滤器</h2>            <p></p>            <p>Vue可以通过自定义过滤器,将需要的文本格式化输出</p>            <p></p>            <p>注意:</p>            <p></p>            <ul>                <li>过滤器只能写在插值表达式或者v-bind表达式中,并且过滤器需要添加到要添加的JS表达式的后方并用管道符|分割                    <div class="codeMirror">                        <pre><xmp><!-- 在双花括号中 -->    &#123;&#123; message | capitalize &#125;&#125;                                    <!-- 在 `v-bind` 中 -->    <div v-bind:id="rawId | formatId"></div>                                    <!-- 管道符后方的都是声明的过滤器函数 --></xmp></pre>                    </div>                </li>                <li>每个过滤器函数会将接收到的表达式作为函数内部的第一个参数,如果在使用时传入参数,那么传入的参数会依次成为第二个第三个等参数                    <div class="codeMirror">                        <pre><xmp>&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;</xmp></pre>                    </div>                </li>                <li>多个过滤器可以进行串联操作,将传入的表达式依次进行过滤                    <div class="codeMirror">                        <pre><xmp>&#123;&#123; message | filterA | filterB &#125;&#125;</xmp></pre>                    </div>                </li>            </ul>            <p></p>            <h3 id="s5.1">5.1 全局过滤器</h3>            <p></p>            <p>全局的过滤器可以在任意的Vue实例中使用</p>            <p></p>            <div class="codeMirror">                <pre><xmp>Vue.filter('capitalize', function (value) {        if (!value) return ''        value = value.toString()        return value.charAt(0).toUpperCase() + value.slice(1)    })            new Vue({        // ...    })</xmp></pre>            </div>            <p></p>            <h3 id="s5.2">5.2 私有过滤器</h3>            <p></p>            <p>私有的过滤器只能在自身的本地实例中使用</p>            <p></p>            <div class="codeMirror">                <pre><xmp>new Vue({         data:{},         methods{},         filters: {             capitalize: function (value) {                 if (!value) return ''                 value = value.toString()                 return value.charAt(0).toUpperCase() + value.slice(1)             }         }      })</xmp></pre>            </div>        </div>        <p></p>        <div class="list" id="s6">            <h2>6.按键修饰符</h2>            <p></p>            <p>在绑定了键盘或鼠标的点击事件后,可以通过按下的按键触发要进行的事件,这时需要在后方添加表示按键的修辞符</p>            <p></p>            <h3 id="s6.1">6.1按键码</h3>            <p></p>            <p></p>            <ul>                <li>可以通过keyCode的值来绑定需要触发的按键                    <div class="codeMirror">                        <pre><xmp><input v-on:keyup.13="submit"></xmp></pre>                    </div>                </li>                <p></p>                <li>部分特殊的按键码可以使用别名</li>                <ul>                    <li>.enter</li>                    <li>.tab</li>                    <li>.delete(捕获“删除”和“退格”键)</li>                    <li>.esc</li>                    <li>.space</li>                    <li>.up</li>                    <li>.down</li>                    <li>.left</li>                    <li>.right</li>                </ul>                <p></p>                <li>也可以自定义按键修饰符的别名                    <div class="codeMirror">                        <pre><xmp>Vue.config.keyCodes.f1 = 112;//使用Vue对象上的全局属性config.keyCodes来定义别名    // 在绑定时就可以使用v-on:keyup.f1直接对f1按键进行操作了</xmp></pre>                    </div>                </li>            </ul>            <p></p>            <h3 id="s6.2">6.2 系统修饰符</h3>            <p></p>            <p>系统修辞符监听仅在同时按下了绑定键盘或鼠标按钮时才会触发事件</p>            <ul>                <li>键盘</li>                <ul>                    <li>.ctrl</li>                    <li>.alt</li>                    <li>.shift</li>                    <li>.meta</li>                </ul>            </ul>            <p></p>            <p>注意:在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。</p>            <p></p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><!-- Alt + C -->    <input @keyup.alt.67="clear">                            <!-- Ctrl + Click -->    <div @click.ctrl="doSomething">Do something</div></xmp></pre>            </div>            <p></p>            <ul>                <li>鼠标</li>                <ul>                    <li>.left</li>                    <li>.right</li>                    <li>.middle</li>                </ul>                <p></p>                <p>注:修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。而单单释放 ctrl 也不会触发事件。如果只想要单独触发,则需要使用keycode编码或.exact修饰符</p>                <p></p>                <p></p>                <li>.exact<br/>.exact 修饰符允许用户控制由精确的系统修饰符组合触发的事件                    <div class="codeMirror">                        <pre><xmp><!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->    <button @click.ctrl="onClick">A</button>                                    <!-- 有且只有 Ctrl 被按下的时候才触发 -->    <button @click.ctrl.exact="onCtrlClick">A</button>                                    <!-- 没有任何系统修饰符被按下的时候才触发 -->    <button @click.exact="onClick">A</button></xmp></pre>                    </div>                </li>            </ul>        </div>        <p></p>        <div class="list" id="s7">            <h2>7.自定义指令</h2>            <p></p>            <h3 id="s7.1">7.1 全局指令</h3>            <p></p>            <p>通过全局的Vue的Vue.directive()可以创建一个能用在整个Vue实例内的指令</p>            <p></p>            <div class="codeMirror">                <pre><xmp>// 注册一个全局自定义指令 v-focus        Vue.directive('focus', {        // 当被绑定的元素插入到 DOM 中时聚焦        inserted: function (el) {        // 聚焦元素        el.focus()        }    })</xmp></pre>            </div>            <p></p>            <h3 id="s7.2">7.2 局部指令</h3>            <p></p>            <p>通过局部创建的directives属性可以创建多个内部的指令,该指令只能用在自身的Vue实例中</p>            <p></p>            <div class="codeMirror">                <pre><xmp>new Vue({        data:{},        methods{},        directives: {        focus: {            // 指令的定义            inserted: function (el) {                el.focus()            }        }    }    }</xmp></pre>            </div>            <p></p>            <h3 id="s7.3">7.3 钩子函数</h3>            <p></p>            <p>在定义的一个指令对象中可以绑定多个可选的钩子函数,这些钩子函数会在特定的时刻自动调用</p>            <p></p>            <h4 id="s7.3.1">7.3.1 函数</h4>            <p></p>            <ul>                <li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置</li>                <li>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)</li>                <li>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新</li>                <li>componentUpdated：指令所在组件的 VNode 及其子 VNode全部更新后调用</li>                <li>unbind：只调用一次，指令与元素解绑时调用</li>            </ul>            <p></p>            <p>函数简写</p>            <p></p>            <p>当只想要对bind与update设置相同行为而不设置其他的钩子函数时,可以直接写成一个函数,不用写一个包含了钩子函数的对象</p>            <p></p>            <div class="codeMirror">                <pre><xmp>//全局    Vue.directive('focus', function(el){        el.focus();    })    //局部    new Vue({        data:{},        methods{},            directives: {            function (el) {                    el.focus()            }        }    }</xmp></pre>            </div>            <p></p>            <h4 id="s7.3.2">7.3.2 钩子函数的参数</h4>            <p></p>            <ul>                <li>el：指令所绑定的元素,可以用来直接操作DOM</li>                <li>binding：一个对象，还包含以下属性</li>                <ul>                    <li>name：指令名，不包括 v- 前缀</li>                    <li>value：指令的绑定值，会将参数的表达式进行解析,如果内部绑定的参数为1+1,那么绑定后的值就为2<br/>注意:如果想要传递多个值,可以传入一个对象,通过对象进行获取多个值                        <div class="codeMirror">                            <pre><xmp><div v-demo="{ color: 'white', text: 'hello!' }"></div>    <script>         Vue.directive('demo', function (el, binding) {            console.log(binding.value.color) // => "white"            console.log(binding.value.text)  // => "hello!"        })    </script></xmp></pre>                        </div>                    </li>                    <li>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子函数中中可以使用,无论值是否改变都可用</li>                    <li>expression：字符串形式的指令表达式,不会对表达式进行解析,如果参数为1+1那么值还为 "1 + 1"</li>                    <li>arg：传给指令的参数,可选。例如 v-my-directive:foo 中，参数为 "foo"。</li>                    <li>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }</li>                </ul>                <li>vnode：Vue 编译生成的虚拟节点</li>                <li>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子函数中可以使用</li>                <p></p>                <div class="codeMirror">                    <pre><xmp><div id="hook-arguments-example" v-demo:foo.a.b="message"></div></xmp></pre>                </div>                <p></p>                <div class="codeMirror">                    <pre><xmp>Vue.directive('demo', {        bind: function (el, binding, vnode) {            var s = JSON.stringify            el.innerHTML =              'name: '       + s(binding.name) + '<br>' +              'value: '      + s(binding.value) + '<br>' +              'expression: ' + s(binding.expression) + '<br>' +              'argument: '   + s(binding.arg) + '<br>' +              'modifiers: '  + s(binding.modifiers) + '<br>' +              'vnode keys: ' + Object.keys(vnode).join(', ')          }    })                                             new Vue({        el: '#hook-arguments-example',        data: {          message: 'hello!'        }    })      /*      name: "demo"      value: "hello!"      expression: "message"      argument: "foo"      modifiers: {"a":true,"b":true}      vnode keys: tag, data, children, text, elm, ns, context, fnContext,       fnOptions, fnScopeId, key, componentOptions, componentInstance, parent,        raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory,        asyncMeta, isAsyncPlaceholder    */</xmp></pre>                </div>            </ul>            <p></p>        </div>        <p></p>        <div class="list" id="s8">            <h2>8.生命周期函数</h2>            <p></p>            <p></p>            <img src="../image/1569655790584-a5e09649-ecbe-40eb-864c-fe110dd31efc.png" alt="" width="800px">            <p>生命周期函数写在一个Vue实例内部,这些函数直接作为一个内部的方法创建,根据不同的状况会自动的调用</p>            <p></p>            <h3 id="s8.1">8.1 Vue实例创建阶段</h3>            <p></p>            <p></p>            <ul>                <li>var vm=new Vue(),创建出一个Vue实例对象</li>                <li>beforeCreat，当Vue实例被完全创建出来之前,就会执行该函数，这是表示刚初始化了一个空的Vue对象,这时候这个对象身上只有一些<br/>注意:在beforeCreat生命周期函数执行的时候,data和methods等中的数据还没有初始化,所以在这里面调用这些data或methods等中的属性和方法会报错</li>                <li>created,在该函数中,data和methods等数据已经被初始化好了,如果要调用methods中的方法或者data中的数据,最早只能在created中进行操作<br/>注:如果要发Ajax请求尽量在这个阶段发送</li>                <li>轻量级，体积小渲染速度更快</li>                <li>在这两个生命周期函数之间进行Vue的编译模板,把Vue代码中的那些指令进行执行,最终在内存中生成一个编译好的最终模板字符串,然后把这个字符串渲染为内存中的DOM,但是此时只是在内存中渲染DOM,还没有将其挂载到页面中去</li>                <li>beforeMount,在该函数中模板已经在内存中了,但是还没有把模板渲染到页面中,也就是说&#123;&#123;&#125;&#125;中的内容还没有被解析,页面中的元素还没有真正被替换,只是写了一些模板字符串</li>                <li>将内存中的DOM挂载到页面中去</li>                <li>mounted,表示内存中的DOM已经挂载到页面中了,用户已经可以看到渲染好的页面了<br/>注意:</li>                <ul>                    <li>mounted是实例创建期间执行的最后一个生命周期函数,当执行完mounted就表示实例已经完全被创建好了</li>                    <li>如果要通过某些插件操作页面上的DOM节点,最早要在mounted中进行</li>                </ul>            </ul>            <p></p>            <h3 id="s8.2">8.2 Vue实例运行阶段</h3>            <p></p>            <p>下面两个生命周期必须要数据发生改变时才会进行,会根据data数据的改变触发0次或多次</p>            <p></p>            <ul>                <li>beforeUpdate,这个函数表明Vue实例在运行时数据已经被更新,而页面还没有被更新的时间节点,当执行该函数时,页面中显示的数据还是没有更新前的数据,而data中的数据是最新的,页面还没有和数据实现同步</li>                <li>在这两个函数之间,会根据data中的最新数据,重新渲染出一份最新的内存DOM树,当最新的内存DOM树被更新之后,会把最新的内存DOM树重新渲染到真实的页面中去,完成数据从data到页面视图的更新</li>                <li>updated,当这个函数执行时证明data中的数据已经和页面中的数据保存同步更新了</li>            </ul>            <p></p>            <h3 id="s8.3">8.3 Vue实例销毁阶段</h3>            <p></p>            <ul>                <li>beforeDestroy, 当执行该函数时,Vue实例就已经从运行阶段进入到了销毁阶段,实例上的所以属性如data,methods等都还是处于可用状态,还没有真正的执行销毁</li>                <li>destroyed,当执行到该函数时,Vue实例已经被完全销毁,此时所有实例中的属性都不可用了</li>            </ul>        </div>        <p></p>        <div class="list" id="s9">            <h3>9.过渡与动画</h3>            <p></p>            <p>Vue中可以通过transition组件来实现过渡效果Vue 在插入,更新或者移除 DOM 时,提供多种不同方式的应用过渡效果</p>            <p></p>            <ul>                <li>在 CSS 过渡和动画中自动应用 class</li>                <li>可以配合使用第三方 CSS 动画库，如 Animate.css</li>                <li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li>                <li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li>            </ul>            <p></p>            <h3 id="s9.1">9.1 过渡的类名</h3>            <p></p>            <h4 id="s9.1.1">9.1.1 自身实现的类名</h4>            <p></p>            <p>这些类名是transition组件中自定好的,在使用的时候只需要在CSS中写入特定的类名和样式就可以了</p>            <p></p>            <ul>                <li>v-enter：定义进入过渡的开始状态。在元素被插入之前生效，此时元素还没有进入过渡，在元素被插入之后的下一帧移除</li>                <li>v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数</li>                <li>v-enter-to: 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除</li>                <li>v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除</li>                <li>v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数</li>                <li>v-leave-to:定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除</li>            </ul>            <p></p>            <p>注:</p>            <p></p>            <ul>                <li>一般都是使用v-enter,v-leave-to与v-enter-active和v-leave-active的组合</li>                <li>对于这些在过渡中切换的类名来说,如果使用一个没有名字的 &lt;transition>,则 v- 是这些类名的默认前缀,如果使用了 &lt;transition name="my-transition">,那么 v-enter 会替换为 my-transition-enter**,通过这个可以绑定:name实现动态过渡的效果</li>            </ul>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><style>    .fade-enter-active, .fade-leave-active {    transition: opacity .5s;    }    .fade-enter, .fade-leave-to {        opacity: 0;    }    </style>                            <div id="demo">        <button v-on:click="show = !show">          Toggle        </button>        <transition name="fade">          <p v-if="show">hello</p>        </transition>      </div>                                                                  <script>        new Vue({          el: '#demo',          data: {            show: true          }        })    </script></xmp></pre>            </div>            <p></p>            <p></p>            <ul>                <li>动画效果同过渡效果,只是在动画中v-enter这个类名在插入DOM中后不会立刻被删除,而是在animationend事件触发时才会被删除<br/>注:动画可以实现多个阶段的样式</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><style>    .bounce-enter-active {        animation: bounce-in .5s;    }    .bounce-leave-active {        animation: bounce-in .5s reverse;    }    @keyframes bounce-in {        0% {            transform: scale(0);        }        50% {            transform: scale(1.5);        }        100% {            transform: scale(1);        }            }                                    </style>                                                              <div id="example">        <button @click="show = !show">Toggle show</button>        <transition name="bounce">          <p v-if="show">Lorem ipsum dolor sit amet, consectetur adipiscing elit.               Mauris facilisis enim libero, at lacinia diam fermentum id.               Pellentesque habitant morbi tristique senectus et netus.</p>        </transition>    </div>                                      <script>        new Vue({          el: '#example-2',          data: {            show: true          }        })    </script></xmp></pre>            </div>            <p></p>            <p></p>            <h4 id="s9.1.2">9.1.2 自定义过渡的类名</h4>            <p></p>            <p>可以通过引入第三方库实现过渡效果,这时需要使用自定义过渡的类名来加第三方库的过渡效果使用</p>            <p></p>            <p>可以通过以下特性来自定义过渡类名,这些类名分别也对应着上方的执行时期,它们的优先级高于普通的类名</p>            <p></p>            <ul>                <li>enter-class</li>                <li>enter-active-class</li>                <li>enter-to-class</li>                <li>leave-class</li>                <li>leave-active-class</li>                <li>leave-to-class</li>            </ul>            <p></p>            <p>在这些自定义的属性中可以写入要引入的第三方库的CSS样式就能实现效果</p>            <p></p>            <div class="codeMirror">                <pre><xmp><link href="https://cdn.jsdelivr.net/npm/animate.css@3.5.1" rel="stylesheet" type="text/css">        <div id="example">        <button @click="show = !show">            Toggle render          </button>          <transition            name="custom-classes-transition"            enter-active-class="animated tada"            leave-active-class="animated bounceOutRight"          >            <p v-if="show">hello</p>          </transition>    </div>                          <script>        new Vue({          el: '#example',          data: {            show: true          }        })    </script></xmp></pre>            </div>            <p></p>            <p></p>            <h3 id="s9.2">9.2 初始渲染过渡</h3>            <p></p>            <p>为transition组件添加一个简单的属性appear就能够实现在刚开始渲染的时候就使用一次enter-active-class来实现开始渲染列表的过渡效果</p>            <p></p>            <p></p>            <p>初始渲染时也可以使用自定义的CSS类名进行初始渲染</p>            <p></p>            <ul>                <li>appear-class</li>                <li>appear-active-class</li>                <li>appear-to-class</li>            </ul>            <p></p>            <p>注意:使用自定义类名进行渲染时也需要添加appear属性</p>            <p></p>            <div class="codeMirror">                <pre><xmp><transition        appear        appear-class="custom-appear-class"        appear-to-class="custom-appear-to-class"        appear-active-class="custom-appear-active-class"      >        <!-- ... -->    </transition>                        <!--当然也可以使用JS的钩子函数-->      <transition      appear      v-on:before-appear="customBeforeAppearHook"      v-on:appear="customAppearHook"      v-on:after-appear="customAfterAppearHook"      v-on:appear-cancelled="customAppearCancelledHook"    >      <!-- ... -->    </transition></xmp></pre>            </div>            <p></p>            <h3 id="s9.3">9.3 显性定义过渡时间</h3>            <p></p>            <p>默认情况下，Vue 会等待其在过渡效果的根元素的第一个 transitionend 或 animationend 事件。然而也可以不这样设定——比如，我们可以拥有一个精心编排的一系列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果。在这种情况下,可以用&lt;transition> 组件上的绑定的 duration 属性定制一个显性的过渡持续时间 (以毫秒为单位)</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><transition :duration="1000">...</transition></xmp></pre>            </div>            <p></p>            <p>可以传入一个对象分别对移入和移除的时间进行设置</p>            <p></p>            <div class="codeMirror">                <pre><xmp><transition :duration="{ enter: 500, leave: 800 }">...</transition></xmp></pre>            </div>            <p></p>            <h3 id="s9.4">9.4 JS钩子</h3>            <p></p>            <p></p>            <p>除了通过CSS实现过渡效果,还可以用JS中的钩子函数实现过渡效果,这些钩子可以结合CSS使用,也可以全部单独使用</p>            <p></p>            <div class="codeMirror">                <pre><xmp><transition        v-on:before-enter="beforeEnter"        v-on:enter="enter"        v-on:after-enter="afterEnter"        v-on:enter-cancelled="enterCancelled"                  v-on:before-leave="beforeLeave"        v-on:leave="leave"        v-on:after-leave="afterLeave"        v-on:leave-cancelled="leaveCancelled"    >    <!-- ... -->    </transition></xmp></pre>            </div>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp>// ...    methods: {        // --------        // 进入中        // --------              beforeEnter: function (el) {          // ...        },        // 当与 CSS 结合使用时        // 回调函数 done 是可选的        enter: function (el, done) {          // ...          el.offsetWidth;           //玄学操作,不加这个设置全JS样式时,动画不会有过渡效果出现,可以认为是这个操作会强制动画刷新          done()           //done()所代表的函数就是下一个结束afterEnter的函数,只有调用了这个回调函数才会执行下面的方法        },        afterEnter: function (el) {          // ...        },        enterCancelled: function (el) {          // ...        },              // --------        // 离开时        // --------              beforeLeave: function (el) {          // ...        },        // 当与 CSS 结合使用时        // 回调函数 done 是可选的        leave: function (el, done) {          // ...          done()        },        afterLeave: function (el) {          // ...        },        // leaveCancelled 只用于 v-show 中        leaveCancelled: function (el) {          // ...        }    }</xmp></pre>            </div>            <p></p>            <p>注意:</p>            <p></p>            <ul>                <li>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css="false"，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响</li>                <li>当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。</li>            </ul>            <p></p>            <h3 id="s9.5">9.5 多个元素过渡</h3>            <p></p>            <p>对于原生标签可以使用 v-if和v-else 来实现多标签过渡效果</p>            <p></p>            <p>注意:当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容</p>            <p></p>            <div class="codeMirror">                <pre><xmp><transition>        <button v-if="isEditing" key="save">            Save        </button>        <button v-else key="edit">          Edit        </button>      </transition>      <!--也可以也可以通过给同一个元素的 key 特性设置不同的状态来代替 v-if 和 v-else-->      <transition>        <button v-bind:key="isEditing">          &#123;&#123; isEditing ? 'Save' : 'Edit' &#125;&#125;        </button>    </transition></xmp></pre>            </div>            <p></p>            <p>过渡模式</p>            <p></p>            <p>通过mode属性来定义多个元素过渡时的过渡模式</p>            <p></p>            <ul>                <li>in-out：新元素先进行过渡，完成之后当前元素过渡离开</li>                <li>out-in：当前元素先进行过渡，完成之后新元素过渡进入</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><transition  mode="out-in"></transition></xmp></pre>            </div>            <p></p>            <h3 id="s9.6">9.6 列表过渡</h3>            <p></p>            <p>渲染一整个列表时,如用v-for来渲染,就需要使用&lt; transition-group> 组件</p>            <p></p>            <p>注意:</p>            <p></p>            <ul>                <li>不同于&lt; transition>组件，&lt;transition-group>组件会以一个真实元素呈现,默认为一个 &lt;span>标签,可以通过 tag 特性更换为其他元素<br/>如:内部是li列表,那么可以用&lt;transition-grounp tag="ul">来让该组件被渲染时表现为ul</li>                <li>过渡模式不可用，因为不再相互切换特有的元素</li>                <li>内部元素必须要有提供唯一的 key 属性值</li>            </ul>            <p></p>            <h4 id="s9.6.1">9.6.1 添加与删除列表</h4>            <p></p>            <p>通过对一个transiton-grounp用过渡的类名和实现当个成员在过渡时的效果</p>            <p></p>            <div class="codeMirror">                <pre><xmp><style>    .list-item {        display: inline-block;        margin-right: 10px;    }    .list-enter-active, .list-leave-active {        transition: all 1s;    }    .list-enter, .list-leave-to                   /* .list-leave-active for below version 2.1.8 */ {        opacity: 0;        transform: translateY(30px);    }    </style>                                                                                    <div id="list-demo" class="demo">        <button v-on:click="add">Add</button>        <button v-on:click="remove">Remove</button>        <transition-group name="list" tag="p">          <span v-for="item in items" v-bind:key="item" class="list-item">            &#123;&#123; item &#125;&#125;          </span>        </transition-group>    </div>                                              <script>        new Vue({          el: '#list-demo',          data: {            items: [1,2,3,4,5,6,7,8,9],            nextNum: 10          },          methods: {            randomIndex: function () {              return Math.floor(Math.random() * this.items.length)            },            add: function () {              this.items.splice(this.randomIndex(), 0, this.nextNum++)            },            remove: function () {              this.items.splice(this.randomIndex(), 1)            },          }        })    </script></xmp></pre>            </div>            <p></p>            <p></p>            <h4 id="s9.6.2">9.6.2 排序过渡列表</h4>            <p></p>            <p>上方的添加与删除列表只会对进行操作的成员自身产生过渡效果,对组件中的其他成员没有过渡效果,如果要想通过过渡效果进行添加,需要使用v-move的类名写入CSS样式,该效果会在组件的成员改变其定位的时候起作用,所以要想起过渡效果还需要在过渡时将元素的定位改变为绝对定位.也可以通过 name 属性来自定义前缀,也能通过 move-class 属性CSS效果</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><style>    .flip-list-move {        transition: transform 1s;    }    </style>                            <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>                            <div id="flip-list-demo" class="demo">        <button v-on:click="shuffle">Shuffle</button>        <transition-group name="flip-list" tag="ul">          <li v-for="item in items" v-bind:key="item">            &#123;&#123; item &#125;&#125;          </li>        </transition-group>      </div>            <script>      new Vue({        el: '#flip-list-demo',        data: {          items: [1,2,3,4,5,6,7,8,9]        },        methods: {          shuffle: function () {            this.items = _.shuffle(this.items)          }        }                                       })    </script></xmp></pre>            </div>            <p></p>            <h4 id="s9.6.3">9.6.3 交错过渡列表</h4>            <p></p>            <p>通过JS钩子来实现列表的过渡效果,使data属性与JS进行数据通信,就可以实现列表的交错过渡效果</p>            <p></p>            <div class="codeMirror">                <pre><xmp><script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>        <div id="staggered-list-demo">        <input v-model="query">        <transition-group          name="staggered-fade"          tag="ul"          v-bind:css="false"          v-on:before-enter="beforeEnter"          v-on:enter="enter"          v-on:leave="leave"        >          <li            v-for="(item, index) in computedList"            v-bind:key="item.msg"            v-bind:data-index="index"          >&#123;&#123; item.msg &#125;&#125;</li>        </transition-group>    </div>          <script>      new Vue({        el: '#staggered-list-demo',        data: {          query: '',          list: [            { msg: 'Bruce Lee' },            { msg: 'Jackie Chan' },            { msg: 'Chuck Norris' },            { msg: 'Jet Li' },            { msg: 'Kung Fury' }          ]        },        computed: {          computedList: function () {            var vm = this            return this.list.filter(function (item) {              return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1            })          }        },        methods: {          beforeEnter: function (el) {            el.style.opacity = 0            el.style.height = 0          },          enter: function (el, done) {            var delay = el.dataset.index * 150            setTimeout(function () {              Velocity(                el,                { opacity: 1, height: '1.6em' },                { complete: done }              )            }, delay)          },          leave: function (el, done) {            var delay = el.dataset.index * 150            setTimeout(function () {              Velocity(                el,                { opacity: 0, height: 0 },                { complete: done }              )            }, delay)          }        }      })    </script></xmp></pre>            </div>        </div>        <p></p>        <div class="list" id="s10">            <h3>10.组件</h3>            <p></p>            <p></p>            <h3 id="s10.1">10.1 什么是组件</h3>            <p></p>            <p>组件的出现是为了拆分Vue实例的代码量,能够让我们以不同的组件来划分不同的功能模板,将来需要什么样的功能,只需要调用对应的组件就可以了</p>            <p></p>            <p>组件化与模块化的区别</p>            <p></p>            <ul>                <li>模块化是从代码逻辑的角度进行划分的;方便代码分层开发,保证每个功能模块的职能单一</li>                <li>组件化是从UI界面的角度进行划分的,前端的组件化是为了方便UI组件的重用</li>            </ul>            <p></p>            <h3 id="s10.2">10.2 创建组件</h3>            <p></p>            <p>组件的注意事项:</p>            <p></p>            <ul>                <li>每个组件必须只有一个根元素,可以将模板的内容包裹在一个父元素内来解决这个问题</li>                <li>组件中可以有自己的data数据,使用方式同Vue实例中一样,但是组件的data只能是一个方法,而且必须要返回一个包含了数据的对象,因为需要每个组件之间相互独立,如果不是一个函数,那么每个组件就会影响其他的组件<br/>如果要想同时影响其他数据,可以创建一个外部的镀锡,每次data返回这个对象</li>            </ul>            <p></p>            <h4 id="s10.2.1">10.2.1 组件名</h4>            <p></p>            <p>在创建一个组件时,我们始终需要给该组件一个名字用作标识,组件名的有多种写法</p>            <p></p>            <ul>                <li>短横线命名法,使用短横线命名法来命名组件在使用的时候也是直接将引用的组件名作为标签名来使用</li>                <li>驼峰命名法,使用驼峰命名法命名的组件在引用这个组件时可以通过两种命名的方式来引用<br/>注意:当用作标签时只能使用短横线命名法,所以最好都使用短横线命名法来命名</li>            </ul>            <p></p>            <h4 id="s10.2.2">10.2.2 全局组件</h4>            <p></p>            <p>创建全局组件有三种方式,都是基于Vue.component()方法来创建的</p>            <p></p>            <ul>                <li>通过Vue.extend()的方式,创建一个含有template属性的子类,引用子类到Vue.component()创建的组件中去                    <div class="codeMirror">                        <pre><xmp>var tem1 = Vue.extend({        template:'<h3>这是使用 Vue.extend 创建的组件</h3>'    });    Vue.component('myTem1',tem1);                                <!--可以通过组合的形式引用-->    Vue.component('myTem1',Vue.extend({        template :'<h3>这是使用 Vue.extend 创建的组件</h3>'    }));</xmp></pre>                    </div>                </li>                <li>直接使用Vue.component()方法传入一个对象                    <div class="codeMirror">                        <pre><xmp>Vue.component('my-component-name', {        template:'<h3>这是直接使用Vue.component创建的组件</h3>'    });</xmp></pre>                    </div>                </li>                <li>在一个 &lt;script> 标签中，并为其带上 text/x-template的类型，然后通过ID引用模板(这种方式有代码提示)                    <div class="codeMirror">                        <pre><xmp><script type="text/x-template" id="hello-world-template">        <p>Hello hello hello</p>    </script>                                  <script>        Vue.component('hello-world', {          template: '#hello-world-template'        })    </script></xmp></pre>                    </div>                </li>            </ul>            <p></p>            <h4 id="s10.2.3">10.2.3 私有组件</h4>            <p></p>            <p>通过在一个Vue实例中向components对象中添加属性可以在局部注册只能在该Vue实例内部使用的私有组件</p>            <p></p>            <p>对于 components`对象中的每个属性来说，其属性名就是自定义元素的名字，其属性值就是这个组件的选项对象</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp>new Vue({        el: '#app',        components: {            'component-a': {                template:""            },            'component-b': {                template:""            },        }    })      /*          也可以通过一个普通的变量来定义组件      */      var ComponentA = { /* ... */ }      var ComponentB = { /* ... */ }      var ComponentC = { /* ... */ }          new Vue({        el: '#app',        components: {          'component-a': ComponentA,          'component-b': ComponentB        }    })</xmp></pre>            </div>            <p></p>            <p></p>            <p>注意:局部注册的组件在其子组件中不可以使用,如果要使用需要嵌套创建组件或通过webpack等导出</p>            <p></p>            <div class="codeMirror">                <pre><xmp>//嵌套组件    var ComponentA = { /* ... */ }                            var ComponentB = {        components: {          'component-a': ComponentA        },        // ...    }</xmp></pre>            </div>            <p></p>            <h3 id="s10.3">10.3 组件切换</h3>            <p></p>            <h4 id="s10.3.1">10.3.1 通过v-if切换组件</h4>            <p></p>            <p>通过一个标识可以进行两个组件之间的切换</p>            <p></p>            <div class="codeMirror">                <pre><xmp><div id="app">        <a href="#" @click.prevent="flag=true">登录</a>        <a href="#" @click.prevent="flag=false">注册</a>        <login v-if="flag"></login>        <register v-else></register>    </div>        <script>        Vue.component("login",{            template:"<h2>登录<h2>"        })         Vue.component("register",{            template:"<h2>注册<h2>"        })        new Vue({            el:"#app",            data:{                flag:true            }        })    </script></xmp></pre>            </div>            <p></p>            <h4 id="s10.3.2">10.3.2 通过component切换组件</h4>            <p></p>            <p>通过Vue中自带的component标签的:is特性来实现多个组件之间的切换</p>            <p></p>            <div class="codeMirror">                <pre><xmp><div id="app">        <a href="#" @click.prevent="clickName='login'">登录</a>        <a href="#" @click.prevent="clickName='register'">注册</a>        <component :is="clickName"></component>    </div>        <script>        Vue.component("login",{            template:"<h2>登录<h2>"        })         Vue.component("register",{            template:"<h2>注册<h2>"        })        new Vue({            el:"#app",            data:{                clickName:"login"            }        })    </script></xmp></pre>            </div>            <p></p>            <h4 id="s10.3.3">10.3.3 过渡切换</h4>            <p></p>            <p>组件的切换比其他的东西容易很多,只需要使用过渡模式就能完成切换</p>            <p></p>            <div class="codeMirror">                <pre><xmp><style>        .component-fade-enter-active, .component-fade-leave-active {            transition: opacity .3s ease;        }        .component-fade-enter, .component-fade-leave-to{            opacity: 0;        }    </style>                        <div id="app">        <a href="#" @click.prevent="clickName='login'">登录</a>        <a href="#" @click.prevent="clickName='register'">注册</a>        <transition mode="out-in">        <component :is="clickName" name="component-fade"></component>        </transition>    </div>        <script>        Vue.component("login",{            template:"<h2>登录<h2>"        })         Vue.component("register",{            template:"<h2>注册<h2>"        })        new Vue({            el:"#app",            data:{                clickName:"login"            }        })                </script></xmp></pre>            </div>            <p></p>            <p></p>            <h3 id="s10.4">10.4 Prop</h3>            <p></p>            <p>子组件是无法直接使用父组件的data中的数据的,需要通过props属性才能够使用父组件传入过来的值</p>            <p></p>            <h4 id="s10.4.1">10.4.1 向子组件传入数据</h4>            <p></p>            <p>在父组件的引用中填入属性名与对应的属性值,然后在子组件的props值填入与引用子组件的属性名一致的属性名,就可以在子组件中引用父组件的数据了，就如访问data中的值一样</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><blog-post title="My journey with Vue"></blog-post>    <blog-post title="Blogging with Vue"></blog-post>    <blog-post title="Why Vue is so fun"></blog-post>    <script>    Vue.component('blog-post', {      props: ['title'],      template: '<h3>&#123;&#123; title &#125;&#125;</h3>'    })    </script></xmp></pre>            </div>            <p></p>            <p>注意:</p>            <p></p>            <ul>                <li>-一个组件默认可以拥有任意数量的 prop,任何值都可以传递给任何 prop,但是为了方便可以传入一个对象,调用对象的属性来使用传入的数据</li>                <li>组件中的所有props中的数据都是通过父组件传递给子组件的,不要试图去修改props中传入的数据,一般都是只读的,如果修改Vue会抛出报错信息</li>                <li>可以通过v-bind动态传递给prop一个值</li>                <li>子组件的data数据并不是通过父组件传递过来的,而是子组件自身私有的,比如子组件通过Ajax请求回来的数据都可以放在data身上,子组件的data上的数据都是可读可写的</li>            </ul>            <p></p>            <h4 id="s10.4.2">10.4.2 Prop的大小写</h4>            <p></p>            <p>HTML中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当使用 DOM 中的模板时，驼峰命名法的prop名需要使用其等价的短横线分隔命名</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><blog-post post-title="hello!"></blog-post>        <script>    Vue.component('blog-post', {        props: ['postTitle'],        template: '<h3>&#123;&#123; postTitle &#125;&#125;</h3>'                        })    </script></xmp></pre>            </div>            <p></p>            <h4 id="s10.4.3">10.4.3 Prop类型</h4>            <p></p>            <p>如果希望传入的prop都有指令的值类型,可以用对象的方式来,可以以对象形式列出 prop，这些属性的名称和值分别是 prop 各自的名称和类型。除此之外,还可以用于配置其他高级选项</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp>//数组形式    props: ['title', 'likes', 'isPublished', 'commentIds', 'author']    //对象形式    props: {      title: String,      likes: Number,      isPublished: Boolean,      commentIds: Array,      author: Object    }</xmp></pre>            </div>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp>// 简单语法    Vue.component('props-demo-simple', {        props: ['size', 'myMessage']    })        // 对象语法，提供校验    Vue.component('props-demo-advanced', {      props: {        // 检测类型        height: Number,        // 检测类型 + 其他验证        age: {          type: Number,          default: 0,//设置默认值          required: true,//是否必须          validator: function (value) {//对值进行验证            return value >= 0          }        }      }    })</xmp></pre>            </div>            <p></p>            <h4 id="s10.4.4">10.4.4 动态传递Prop</h4>            <p></p>            <p>可以通过v-bind的方式动态传递一个变量值给一个prop</p>            <p></p>            <ul>                <li>传入一个数字                    <div class="codeMirror">                        <pre><xmp><!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->    <!-- 这是一个 JavaScript 表达式而不是一个字符串。-->    <blog-post v-bind:likes="42"></blog-post>                                    <!-- 用一个变量进行动态赋值。-->    <blog-post v-bind:likes="post.likes"></blog-post></xmp></pre>                    </div>                </li>                <li>传入一个布尔值                    <div class="codeMirror">                        <pre><xmp><!-- 包含该 prop 没有值的情况在内，都意味着 `true`。-->    <blog-post is-published></blog-post>                                    <!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->     <!-- 这是一个 JavaScript 表达式而不是一个字符串。-->     <blog-post v-bind:is-published="false"></blog-post>                                     <!-- 用一个变量进行动态赋值。-->     <blog-post v-bind:is-published="post.isPublished"></blog-post></xmp></pre>                    </div>                </li>                <li>传入一个数组                    <div class="codeMirror">                        <pre><xmp><!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->    <!-- 这是一个 JavaScript 表达式而不是一个字符串。-->    <blog-post v-bind:comment-ids="[234, 266, 273]"></blog-post>                                    <!-- 用一个变量进行动态赋值。-->    <blog-post v-bind:comment-ids="post.commentIds"></blog-post></xmp></pre>                    </div>                </li>                <li>传入一个对象                    <div class="codeMirror">                        <pre><xmp><!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->    <!-- 这是一个 JavaScript 表达式而不是一个字符串。-->    <blog-post    v-bind:author="{      name: 'Veronica',      company: 'Veridian Dynamics'    }"    ></blog-post>        <!-- 用一个变量进行动态赋值。-->    <blog-post v-bind:author="post.author"></blog-post></xmp></pre>                    </div>                </li>                <li>传入一个对象的所有属性<br/>如果想要将一个对象的所有属性都作为 prop 传入，你可以使用不带参数的 v-bind(取代 v-bind:prop-name)                    <div class="codeMirror">                        <pre><xmp>post: {        id: 1,        title: 'My Journey with Vue'    }</xmp></pre>                    </div>                    <p></p>                    <div class="codeMirror">                        <pre><xmp<blog-post v-bind="post"></blog-post>    <!--与下面的方法等价-->    <blog-post v-bind:id="post.id"  v-bind:title="post.title"></blog-post></xmp></pre>                    </div>                </li>            </ul>            <p></p>            <p></p>            <h3 id="s10.5">10.5 $emit</h3>            <p></p>            <p>子组件也无法使用组件的事件,要想传递给父组件事件,需要通过内置的$emit方法并传入事件的名字,来向父级组件触发一个事件</p>            <p></p>            <h4 id="s10.5.1">10.5.1 向子组件传递事件</h4>            <p></p>            <p>在子组件的引用中绑定事件的自定义名字,然后绑定父组件的事件,在子组件中通过抛出事件$emit来使用父组件的事件</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><!--引用子组件-->    <blog-post v-on:enlarge-text="doSomething"></blog-post>                            <!--子组件-->    <script>    Vue.component("enlarge-text",{        template:"<button v-on:click="$emit('enlarge-text')">Enlarge text</button>"    })    </script></xmp></pre>            </div>            <h4 id="s10.5.2">10.5.2 向父组件抛出值</h4>            <p></p>            <p>子父组件的函数中写入参数,那么当子组件使用$emit的时候可以传入后面多个参数来将值传递给父组件的参数,从而实现子组件向父组件传值</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><div id="app">    <blog-post    v-on:enlarge-text="onEnlargeText"    ></blog-post>    </div>        <script>    Vue.component("blog-post",{    template:"<button v-on:click="$emit('enlarge-text',0.1)">Enlarge text</button>"    })    new Vue({    el="#app",    data:{        postFontSize:1    }    methods: {        onEnlargeText: function (enlargeAmount) {            this.postFontSize += enlargeAmount    }    }      })    </script></xmp></pre>            </div>            <p></p>            <p>注意:虽然子组件能触发父组件的方法或值,但是这些方法中的this指向依然是父组件,子组件只是使用的这些方法,同时传递了一些参数</p>            <p></p>            <h4 id="s10.6">10.6 $on与$once</h4>            <p></p>            <ul>                <li>$on属性用于监听在当前实例上的自定义事件,事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数</li>                <li>$once属性与$on一致,只不过只会触发一次,触发一次后移除该事件</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp>vm.$on('test', function (msg) {        console.log(msg)    })    vm.$once('test', function (msg) {      console.log(msg)    })        vm.$emit('test', 'hi')    // => "hi"</xmp></pre>            </div>            <p></p>            <p>注意:在组件化中通过创建一个中间的Vue实例可以进行中转完成父子组件的事件传值</p>            <p></p>            <h4 id="s10.7">10.7 $ref</h4>            <p></p>            <p>可以使用ref属性为一个组件或是子元素赋予一个引用的ID,通过这个引用的ID,父组件可以直接通过this.$refs访问这个组件或子元素</p>            <p></p>            <div class="codeMirror">                <pre><xmp><div id="app">    <div>        <input type="button" value="获取元素内容" @click="getElement" />        <!-- 使用 ref 获取元素 -->        <h1 ref="myh1">这是一个大大的H1</h1>            <hr>        <!-- 使用 ref 获取子组件 -->        <my-com ref="mycom"></my-com>      </div>    </div>        <script>      Vue.component('my-com', {        template: '<h5>这是一个子组件</h5>',        data() {          return {            name: '子组件'          }        }      });          // 创建 Vue 实例，得到 ViewModel      var vm = new Vue({        el: '#app',        data: {},        methods: {          getElement() {            // 通过 this.$refs 来获取元素            console.log(this.$refs.myh1.innerText);            // 通过 this.$refs 来获取组件            console.log(this.$refs.mycom.name);          }        }      });    </script></xmp></pre>            </div>        </div>        <p></p>        <div class="list" id="s11">            <h2>11.Vue-router</h2>            <p></p>            <h3 id="s11.1">11.1 什么是路由</h3>            <p></p>            <p></p>            <ul>                <li>后端路由：对于普通的网站，所有的超链接都是URL地址，所有的url地址都对应服务器上对应的资源</li>                <li>前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现,在单页面应用中这就叫做前端路由</li>            </ul>            <h3 id="s11.2">11.2 使用Vue-router</h3>            <p></p>            <p>1.导入 vue-router 组件类库</p>            <p></p>            <div class="codeMirror">                <pre><xmp><!-- 1. 导入 vue-router 组件类库 -->    <script src="./lib/vue-router-2.7.0.js"></script></xmp></pre>            </div>            <p></p>            <p>2.使用 router-link 组件来导航</p>            <p></p>            <div class="codeMirror">                <pre><xmp><!--     2. 使用 router-link 组件来导航    router-link组件默认渲染为一个a标签,可以使用tag属性来转换标签,但是无论转换为什么标签都可以进行跳转     -->    <router-link to="/login">登录</router-link>    <router-link to="/register">注册</router-link>    <!--链接的跳转可以使用a标签,但是官方不推荐使用,因为a链接使用的时候需要在前面加上#,会很麻烦--></xmp></pre>            </div>            <p></p>            <p>3.使用 router-view 组件来显示匹配到的组件</p>            <p></p>            <div class="codeMirror">                <pre><xmp><!--     3. 使用 router-view 组件来显示匹配到的组件     这是Vue-router提供的组件元素,专门用来当做占位符,当路由规则到了路径,    就会把对应的组件展示到其中可以使用多个router-view,这是会根据path属性的目录渲染多个组件    -->    <!--        最外层也可以使用transition组件将 router-view 组件包裹实行过渡效果    -->    <router-view></router-view></xmp></pre>            </div>            <p></p>            <p>4.创建使用Vue.extend创建组件</p>            <p></p>            <div class="codeMirror">                <pre><xmp>// 4.1 使用 Vue.extend 来创建登录组件    var login = Vue.extend({        template: '<h1>登录组件</h1>'    });        // 4.2 使用 Vue.extend 来创建注册组件    var register = Vue.extend({        template: '<h1>注册组件</h1>'    });</xmp></pre>            </div>            <p></p>            <p>5.创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</p>            <p></p>            <div class="codeMirror">                <pre><xmp>// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则    var router = new VueRouter({        /*        route这个配置对象中的route表示路由器匹配规则的意思        每个路由规则都是一个规则对象,身上有两个必须的属性:        第一个属性为path,表示监听哪个路由链接地址        第二个属性为component,表示如果路由前面匹配到了path路径,则展示component属性对于的组件        */          routes: [//路由器匹配规则                    {path:'/',redirect:'/login'},          //通过redirect属性设置路由重定向,当访问根目录的时候自动跳转到/login目录          { path: '/login', component: login },          { path: '/register', component: register }        ]    });</xmp></pre>            </div>            <p></p>            <p>6.使用 router 属性来使用路由规则</p>            <p></p>            <div class="codeMirror">                <pre><xmp>// 6. 创建 Vue 实例，得到 ViewMode    var vm = new Vue({        el: '#app',        router: router // 使用 router 属性来使用路由规则    });</xmp></pre>            </div>            <p></p>            <h3 id="s11.3">11.3 修改路由样式</h3>            <p></p>            <p>当点击了router-link组件时,会默认为该路由设置一router-link-active的CSS类名,在通过给该类名设置样式可以达到修改路由样式的能力,如果要修改这个默认的类名选用自己需要的类名,可以通过在VueRouter的构造函数中添加linkActiveClass来改变一个新值</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp>var router = new VueRouter({        routes: [//路由器匹配规则                {path:'/',redirect:'/login'},            //通过redirect属性设置路由重定向,当访问根目录的时候自动跳转到/login目录            { path: '/login', component: login },            { path: '/register', component: register }        ],        linkActiveClass:"myClass"    });</xmp></pre>            </div>            <p></p>            <h3 id="s11.4">11.4 传入参数</h3>            <p></p>            <h4 id="s11.4.1">11.4.1 query</h4>            <p></p>            <p>当在路由器中链接中使用查询字符串(url后面的?后的一系列值),不用修改路由规则中的path属性的路径,在路由视图的组件中可用通过this.$route获取该路由实例,通过该实例的query属性获取传入的参数的属性和值</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><router-link to="/login?id=123">登录</router-link>    <router-link to="/register?id=456">注册</router-link></xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>var login = Vue.extend({        template: '<h1>登录组件</h1>',        created(){            console.log(this.$route.query.id);        }    });            var register = Vue.extend({        template: '<h1>注册组件</h1>'        created(){        console.log(this.$route.query.id);        }    });</xmp></pre>            </div>            <p></p>            <h4 id="s11.4.2">11.4.2 params</h4>            <p></p>            <p>使用params来获取参数需要在路由规则中定义参数,然后在路由器链接中需要在后面跟上对应数量的/+值传给参数实现传参,通过该实例的params属性获取传入的参数的属性和值</p>            <p></p>            <div class="codeMirror">                <pre><xmp><router-link to="/login/123/zhangsan">登录</router-link>    <router-link to="/register/456/lisi">注册</router-link></xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>var login = Vue.extend({        template: '<h1>登录组件</h1>',        created(){        console.log(this.$route.params.id);        }    });                        var register = Vue.extend({        template: '<h1>注册组件</h1>'        created(){        console.log(this.$route.params.id);        }    });</xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则        var router = new VueRouter({            /*            route这个配置对象中的route表示路由器匹配规则的意思            每个路由规则都是一个规则对象,身上有两个必须的属性:            第一个属性为path,表示监听哪个路由链接地址            第二个属性为component,表示如果路由前面匹配到了path路径,则展示component属性对于的组件            */              routes: [//路由器匹配规则                            {path:'/',redirect:'/login'},              //通过redirect属性设置路由重定向,当访问根目录的时候自动跳转到/login目录              { path: '/login/:id/:name', component: login },              { path: '/register/:id/:name', component: register }            ]        });</xmp></pre>            </div>            <p></p>            <h3 id="s11.5">11.5 路由嵌套</h3>            <p></p>            <p>如果想要在一层路由组件下面开启第二层组件,不能够直接通过二级的路由链接得到二级的路由组件,因为这样一级的链接组件就会消失,需要通过routes路由器匹配规则中相应规则的children属性,在该属性构成的数组中写入子路由来实现路由嵌套的功能</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><div id="app">        <router-link to="/account">Account</router-link>                            <router-view></router-view>    </div>                        <script>        // 父路由中的组件        const account = Vue.extend({          template: `<div>            这是account组件            <router-link to="/account/login">login</router-link> |             <router-link to="/account/register">register</router-link>            <router-view></router-view>          </div>`        });            // 子路由中的 login 组件        const login = Vue.extend({          template: '<div>登录组件</div>'        });            // 子路由中的 register 组件        const register = Vue.extend({          template: '<div>注册组件</div>'        });            // 路由实例        var router = new VueRouter({          routes: [            { path: '/', redirect: '/account/login' }, // 使用 redirect 实现路由重定向            {              path: '/account',              component: account,              children: [ // 通过 children 数组属性，来实现路由的嵌套                { path: 'login', component: login }, // 注意，子路由的开头位置，不要加 / 路径符                { path: 'register', component: register }              ]            }          ]        });            // 创建 Vue 实例，得到 ViewModel        var vm = new Vue({          el: '#app',          data: {},          methods: {},          components: {            account          },          router: router        });    </script></xmp></pre>            </div>            <p></p>            <p></p>            <h3 id="s11.6">11.6 命名路由</h3>            <p></p>            <p>通过在&lt;router-link>&lt;/router-link>的组件中to指向一个带有name属性的对象,而在路由规则中也添加一个对应的name属性实现路由跳转,该方法能让我们更加轻松的进行路由规则的匹配</p>            <p></p>            <div class="codeMirror">                <pre><xmp><router-link :to="{ name: 'user', params: { userId: 123 &#125;&#125;">User</router-link>    <script>    const router = new VueRouter({        routes: [            {            path: '/user/:userId',            name: 'user',            component: User            }        ]    })           </script></xmp></pre>            </div>            <p></p>            <h3 id="s11.7">11.7 命名视图</h3>            <p></p>            <p>在Vue的路由实例中,一个路由路径可以对应多个路由组件,所以可以设置多个路由的视图,在一个路径中就可以,通过命名的视图在一个路径中使用多个路由组件,从而实现经典的布局效果</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><!--CSS-->      <style>        .header {            border: 1px solid red;        }                                .content{            display: flex;        }        .sidebar {            flex: 2;            border: 1px solid green;            height: 500px;        }                   .mainbox{            flex: 8;            border: 1px solid blue;            height: 500px;        }                                                         </style>                  <!--HTML-->      <div id="app">        <router-view></router-view>        <div class="content">          <router-view name="a"></router-view>    <!--通过name属性可以只参与对应组件的渲染,没有name属性代表是default,会渲染属性名为defalut的组件-->          <router-view name="b"></router-view>        </div>      </div>    <!--JS-->      <script>        var header = Vue.component('header', {          template: '<div class="header">header</div>'        });            var sidebar = Vue.component('sidebar', {          template: '<div class="sidebar">sidebar</div>'        });            var mainbox = Vue.component('mainbox', {          template: '<div class="mainbox">mainbox</div>'        });            // 创建路由对象        var router = new VueRouter({          routes: [            {              path: '/', components: {                default: header,//定义一个name为efalut的组件,即使视图不写name属性也能渲染该组件                a: sidebar,                b: mainbox              }            }          ]        });            // 创建 Vue 实例，得到 ViewModel        var vm = new Vue({          el: '#app',          data: {},          methods: {},          router        });    </script></xmp></pre>            </div>            <p></p>            <p></p>            <h3 id="s11.8">11.8 route与router</h3>            <p></p>            <ul>                <li>this.$route是路由的参数对象,所有的路由参数如pararms和query都属于该属性的参数</li>                <li>this.$router是一个路由导航对象,用它可以方便的使用JS代码,实现路由器的前进,后退,跳转到新的url地址                    <div class="codeMirror">                        <pre><xmp>// 字符串    this.$router.push('home')                                    // 对象    this.$router.push({ path: 'home' })        // 命名的路由    this.$router.push({ name: 'user', params: { userId: '123' &#125;&#125;)        // 带查询参数，变成 /register?plan=private    this.$router.push({ path: 'register', query: { plan: 'private' &#125;&#125;)</xmp></pre>                    </div>                </li>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况</li>                    <li>该属性的APIthis.$router.push、 this.$router.replace 和 this.$router.go 跟 window.history.pushState、 window.history.replaceState 和 window.history.go类似</li>                </ul>            </ul>        </div>        <p></p>        <div class="list" id="s12">            <h2>12.watch与computed</h2>            <p></p>            <h3 id="s12.1">12.1 watch</h3>            <p></p>            <p>watch属性为Vue实例或组件中的一个自定义的侦听器,通过该属性可以在实例或组件的数据发生变化时进行相应的操作,对于路由这些虚拟DOM的监听是非常好用的</p>            <p></p>            <ul>                <li>监听data数据变化                    <div class="codeMirror">                        <pre><xmp><div id="app">        <input type="text" v-model="firstName"> +        <input type="text" v-model="lastName"> =        <span>&#123;&#123;fullName&#125;&#125;</span>    </div>        <script>        // 创建 Vue 实例，得到 ViewModel        var vm = new Vue({          el: '#app',          data: {            firstName: 'jack',            lastName: 'chen',            fullName: 'jack - chen'          },          methods: {},          watch: {            'firstName': function (newVal, oldVal) { // 第一个参数是新数据，第二个参数是旧数据              this.fullName = newVal + ' - ' + this.lastName;            },            'lastName': function (newVal, oldVal) {              this.fullName = this.firstName + ' - ' + newVal;            }          }        });    </script></xmp></pre>                    </div>                </li>                <p></p>                <li>监听路由的变化                    <div class="codeMirror">                        <pre><xmp><div id="app">        <router-link to="/login">登录</router-link>        <router-link to="/register">注册</router-link>                                    <router-view></router-view>    </div>        <script>        var login = Vue.extend({          template: '<h1>登录组件</h1>'        });            var register = Vue.extend({          template: '<h1>注册组件</h1>'        });            var router = new VueRouter({          routes: [            { path: "/login", component: login },            { path: "/register", component: register }          ]        });            // 创建 Vue 实例，得到 ViewModel        var vm = new Vue({          el: '#app',          data: {},          methods: {},          router: router,          watch: {            '$route': function (newVal, oldVal) {              if (newVal.path === '/login') {                console.log('这是登录组件');              }            }          }        });    </script></xmp></pre>                    </div>                </li>            </ul>            <p></p>            <h3 id="s12.2">12.2 computed</h3>            <p></p>            <p>计算属性computed是用于定义一些可以动态改变的属性的,模板内的表达式非常便利,但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护,所以尽量不要在模板&#123;&#123;&#125;&#125;中使用计算表达式,这时就可以用Vue实例中的computed属性,computed里面的属性的值为一个函数,可以在该函数中间一系列的计算,然后将需要的结果返回</p>            <p></p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><code>&lt;div id="app">  &lt;input type="text" v-model="firstName"> +  &lt;input type="text" v-model="lastName"> =  &lt;span>&#123;&#123;fullName&#125;&#125;&lt;/span>&lt;/div>       &lt;script>        // 创建 Vue 实例，得到 ViewModel        var vm = new Vue(&#123;          el: '#app',          data: &#123;            firstName: 'jack',            lastName: 'chen'          &#125;,          methods: &#123;&#125;,          computed: &#123;         /*        计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，        都会重新触发本计算属性的重算，从而更新 fullName 的值        */            fullName() &#123;              return this.firstName + ' - ' + this.lastName;            &#125;          &#125;        &#125;);  &lt;/script></code></pre>            </div>            <p></p>            <p>计算属性默认只有getter,不过在需要时也可以提供一个setter,这时最外层的属性会是一个对象,内部分别有get()方法和set()方法</p>            <p></p>            <div class="codeMirror">                <pre><code>&lt;div id="app">&lt;input type="text" v-model="firstName">&lt;input type="text" v-model="lastName"><!-- 点击按钮重新为 计算属性 fullName 赋值 -->&lt;input type="button" value="修改fullName" @click="changeName">            &lt;span>&#123;&#123;fullName&#125;&#125;&lt;/span>&lt;/div>        &lt;script>        // 创建 Vue 实例，得到 ViewModel        var vm = new Vue(&#123;            el: '#app',            data: &#123;                firstName: 'jack',                lastName: 'chen'            &#125;,            methods: &#123;                changeName() &#123;                    this.fullName = 'TOM - chen2';                &#125;            &#125;,            computed: &#123;                fullName: &#123;                    get: function () &#123;                        return this.firstName + ' - ' + this.lastName;                    &#125;,                    set: function (newVal) &#123;                        var parts = newVal.split(' - ');                        this.firstName = parts[0];                        this.lastName = parts[1];                    &#125;                &#125;            &#125;        &#125;);    &lt;/script></code></pre>            </div>            <p></p>            <p>注意:</p>            <p></p>            <ul>                <li>计算属性本质上就是一个方法,不过只需要将其当做一个属性来用,在使用这些属性的时候是直接使用它们的名称,而不是将其当做方法来用,所以在引用的时候不要在后面加上()</li>                <li>只要计算属性的函数内部所用到的data中的数据发生了变化就会立刻调用该函数,计算属性的值会重新被计算</li>                <li>与方法不同的是computed是有缓存的,意味着只要内部的响应式依赖变量没有发生改变访问的该函数的结果依然不会发生改变,而如果是方法,每当再次访问方法时都会重新执行一次函数,所以不会有缓存,如果不相同要有缓存,computed就用方法methods来代替</li>            </ul>            <p></p>            <h3 id="s12.3">12.3 wath,computed与methods的区别</h3>            <p></p>            <ul>                <li>computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用</li>                <li>methods方法表示一个具体的操作，主要书写业务逻辑</li>                <li>watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作,可以看作是computed和methods的结合体</li>            </ul>        </div>        <p></p>        <div class="list" id="s13">            <h2>13.对象数组更新</h2>            <p></p>            <h3 id="s13.1">13.1 Vue.set与vm.$set</h3>            <p></p>            <p>向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性</p>            <p></p>            <ul>                <li>数组添加                    <br> Vue中的data中的数组可以通过Vue返回后的实例进行改变,所拥有的方法同原生JS,变异方法会直接改变数组,重新渲染页面,但如果不是变异方法也可以通过重新赋值来使用,Vue不会直接重新渲染,而是由其内部高效的机制                    <br> 注意:如果直接通过赋值改变数组中成员的值或者length的长度,并不能够渲染页面,这是由JS内部的机制决定的                    <br> 解决方案:                </li>                <ul>                    <li>Vue.set(vm.items, indexOfItem, newValue)(第一个参数为素组名,第二个为数组索引,第三个为成员值)</li>                    <li>vm.items.splice(indexOfItem, 1, newValue)</li>                    <li>vm.$set(vm.items, indexOfItem, newValue)(其实vm.$set()就是Vue.set()方法的别名)</li>                    <li>如果要解决改变length属性的问题,使用vm.items.splice(newLength)</li>                </ul>                <li>对象添加                    <br>如果要更新对象的属性,在已有属性的情况下改变原来的值是可以进行动态更新的,但是如果是添加一个新的属性或为一个对象添加新的属性不能做到响应式的更新,这也是由于JS的内部机制决定的                    <br>解决方案:                </li>                <ul>                    <li>Vue.set(vm.userProfile, 'age', 27)(第一个参数为对象名,第二个为键名,第三个为键值)</li>                    <li>vm.$set(vm.userProfile, 'age', 27)</li>                    <li>如果要同时给多个属性使用下面这种方式                        <div class="codeMirror">                            <pre><xmp>vm.userProfile = Object.assign({}, vm.userProfile, {        age: 27,        favoriteColor: 'Vue Green'    })    //不好的方式:    Object.assign(vm.userProfile, {        age: 27,        favoriteColor: 'Vue Green'    })</xmp></pre>                        </div>                    </li>                </ul>            </ul>        </div>        <p></p>        <div class="list" id="s14">            <h2>14.混入</h2>            <p></p>            <p>混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项</p>            <p></p>            <h3 id="s14.1">14.1 全局混入</h3>            <p></p>            <p>注意: 一旦使用全局混入对象，将会影响到所有之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑</p>            <p></p>            <div class="codeMirror">                <pre><xmp>// 为自定义的选项 'myOption' 注入一个处理器。    Vue.mixin({        created: function () {            var myOption = this.$options.myOption            if (myOption) {              console.log(myOption)            }          }    })            new Vue({         myOption: 'hello!'    })</xmp></pre>            </div>            <p></p>            <p></p>            <h3 id="s14.2">14.2 局部混入</h3>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp>// 定义一个混入对象    var myMixin = {        created: function () {           this.hello()        },        methods: {        hello: function () {            console.log('hello from mixin!')            }        }    }            // 定义一个使用混入对象的组件    var Component = Vue.extend({        mixins: [myMixin]    })            var component = new Component() // => "hello from mixin!"</xmp></pre>            </div>            <p></p>            <p>当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合,比如数据对象在内部会进行浅合并 (一层属性深度)，在和组件的数据发生冲突时以组件数据优先</p>            <p></p>            <div class="codeMirror">                <pre><xmp>var mixin = {        data: function () {            return {                message: 'hello',                foo: 'abc'              }            }          }              new Vue({        mixins: [mixin],        data: function () {            return {            message: 'goodbye',            bar: 'def'            }        },        created: function () {            console.log(this.$data)            // => { message: "goodbye", foo: "abc", bar: "def" }        }    })</xmp></pre>            </div>            <p></p>            <p>值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对</p>            <p></p>            <div class="codeMirror">                <pre><xmp>var mixin = {        methods: {            foo: function () {                console.log('foo')            },            conflicting: function () {                console.log('from mixin')            }        }    }              var vm = new Vue({        mixins: [mixin],        methods: {            bar: function () {            console.log('bar')            },            conflicting: function () {            console.log('from self')            }        }    })              vm.foo() // => "foo"    vm.bar() // => "bar"    vm.conflicting() // => "from self"</xmp></pre>            </div>            <p></p>            <p>注意:混入对象的钩子将在组件自身钩子之前调用</p>        </div>        <p></p>        <div class="list" id="s15">            <h2>15.Vuex</h2>            <p></p>            <p>Vuex是一个全局的共享存储区域,相当于是一个数据仓库</p>            <p></p>            <p>Vuex是为了保存组件之间的共享数据而诞生的,如果组件之间要有共享数据,可以直接挂载到Vuex中,而不必通过父子组件直接的传值了,而私有的数据则不需要挂载到Vuex中,只有需要共享的数据才放在Vuex中,私有的数据只需要放在组件的data中即可</p>            <p></p>            <p></p>            <h3 id="s15.1">15.1 基本用法</h3>            <p></p>            <div class="codeMirror">                <pre><xmp>//现下载Vuex    //main.js    import Vue from 'vue';    import Vuex from 'vuex';    Vue.use(Vuex);    //使用new Vuex.store()实例得到一个数据存储对象    var store=new Vuex.Store({        state:{    /*    可以把state想像成组件中的data,专门用来访问数据,如果想在组件中访问store中的数据,    只能通过(this.)$store.state.属性名来获取    */        count:0        },        mutations:{            /*            如果要操作state中的数据,只能通过mutations中的方法,不推荐直接操作state中的数据,            因为每个组件都有能够操作数据的方法,如果导致了数据的紊乱就不能够快速进行定位            */           increment (state) {                  state.count++            }              /*                如果组件想调用mutations中的方法,只能使用(this.)$store.commit("方法名")的方式,类似于                this.$emit("方法名")            */        },        getters:{            //该属性中的方法用于对外修改包装提供的数据和计算出新的数据            optCount:function(state){                return "当前的值为"+state.count;            }            /*            getters的调用类似过滤器和计算属性,能够修改导出的数据(不修改元数据),            同时只要元数据发生改变就会立刻重新计算新的值,所以如果想要对数据进行一层包装推荐用它            */            /*            在组件中引用getters中的方法使用this.$store.getters.方法名来使用            */        }    });    import App from './App.vue';        const vm=new Vue({        el:"#app",        component:APP,        template:"<App/>",        store:store;//将store挂载到vm实例上,只要挂载了就能全局使用store中的数据了    })</xmp></pre>            </div>            <p></p>            <h3 id="s15.2">15.2 mutations中的参数</h3>            <p></p>            <p>mutations函数中的函数参数列表最多只支持两个参数,也就是state与要传入的一个参数</p>            <p></p>            <div class="codeMirror">                <pre><xmp>mutations: {        increment (state, n) {            state.count += n        }      }</xmp></pre>            </div>            <p></p>            <p>因为只能传入一个参数,所以通常情况下都是传入一个对象</p>            <p></p>            <div class="codeMirror">                <pre><xmp>mutations: {        increment (state, payload) {            state.count += payload.amount        }      }            //在某个组件的方法中      this.$store.commit('increment', {        amount: 10      })</xmp></pre>            </div>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/node/"/>
    <url>/CodeNote/2020/10/23/zone/html/node/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title">            <h1>Node.js</h1>        </div>    </div>    <p></p>    <div class="list" id="s1">        <h2>1. 认识Node.js</h2>        <p></p>        <ul>            <li>Node.js既不是一门语言,也不是一个库或框架,而只是一个构建在Chrome的V8引擎上的一个JS的运行环境,可以解析和执行JS代码,在以前只能在浏览器中解析执行JS代码,而现在可以完全脱离浏览器来运行</li>            <li>在Node.js的中的JS没用DOM和BOM,只有ECMAScript和额外为JS提供的一些服务器级别的API</li>            <li>Node.js使用事件驱动,异步模型,具有轻量高效的特点</li>            <li>Node.js使用npm进行包管理,绝大多数JS相关的包都存放在npm上,这样做的目的是为了让开发人员更方便去下载使用</li>        </ul>        <p></p>        <p>node与浏览器的异同</p>        <p></p>        <ul>            <li>架构一样,都是基于事件驱动的异步架构</li>            <li>浏览器主要是通过事件驱动来进行服务器交互</li>            <li>node主要是通过事件驱动来服务(I/O),进行用户间的数据交互</li>        </ul>    </div>    <p></p>    <div class="list" id="s2">        <h2>2.node的作用</h2>        <p></p>        <h3 id="s2.1">2.1 执行JS脚本文件</h3>        <p></p>        <p>在命令行的父目录中使用node 文件名的方法解析和运行JS脚本文件</p>        <p></p>        <p>注意:JS的文件名不能node.js,不然不会执行该脚本,而是会直接打开该文件</p>        <p></p>        <h3 id="s2.2">2.2 Buffer</h3>        <p></p>        <p>Buffer是一种数据结构,里面专门存放二进制数据,而为了方便将里面的数据显示,所以用了十六进制来进行显示</p>        <p></p>        <div class="codeMirror">            <pre><xmp>let str="123";let buf=Buffer.from(str);//字符串转Buffer数据console.log(buf);console.log(buf.length);//表示字节长度,一个英文字节为1,中文字节为3let str2=Buffer.toString(buf);//Buffer数据转字符串console.log(str2);//123</xmp></pre>        </div>    </div>    <p></p>    <div class="list" id="s3">        <h2>3.模块系统</h2>        <p></p>        <p>在node中有三种模块:</p>        <p></p>        <ul>            <li>具体的核心模块</li>            <li>用户自己编写的文件模块</li>            <li>第三方模块</li>        </ul>        <p></p>        <h3 id="s3.1">3.1 node如何实现模块化</h3>        <p></p>        <p>node实现模块化的方法很简单，就是闭包，每个模块在运行时默认都是在最外层放了一个模块包装函数（Module Wrapper Function）中，node通过调用这个封装过的函数实现的模块化</p>        <p></p>        <div class="codeMirror">            <pre><xmp>(function (exports, require, module, __filename, __dirname) {}</xmp></pre>        </div>        <p></p>        <p>每个模块中的代码都是包裹在一个立即执行函数中的,同时立即执行函数都有5个形参</p>        <p></p>        <ul>            <li>exports:专门用来暴露模块数据的一个对象</li>            <li>require:专门用来引入外部模块的函数</li>            <li>module:内置的模块系统对象，具体介绍见下</li>            <li>__filename:当前文件的绝对路径</li>            <li>__dirname:当前文件夹的路径</li>        </ul>        <p></p>        <p>注意:</p>        <p></p>        <ul>            <li>在node文件操作中,相对路径并不可靠,因为node中的文件路径被设计为相对于执行node命令所处的路径,所以推荐使用path.join加上__dirname和__filenmae把路径转换为绝对路径</li>            <li>而模块中的路径表示与文件操作中的不一致,用相对路径就好了</li>        </ul>        <p></p>        <h3 id="s3.2">3.2 全局对象global</h3>        <p></p>        <p>与浏览器端的window对象一样，global也是作为一个全局对象存在的，该对象中包含了许多node应用内置的属性和方法（比如我们使用的console对象其实在node环境中是挂载到global对象上的）。</p>        <p></p>        <p>可以见到，由node实现模块化的情况来看，所有的代码最后都集合在一起，而global是作为最外层和模块同作用域的顶级对象来存在的。</p>        <p></p>        <p>通过在global对象挂载属性可以在其他模块进行访问,通过不声明直接命名的方式可以实现</p>        <p></p>        <div class="codeMirror">            <pre><xmp>let a = 1global.a = a // 这样在另外的模块中也可以同global.a使用，但是不推荐这样做，或污染全局环境</xmp></pre>        </div>        <p></p>        <p>相比起全局对象，我们更希望通过挂在到exports对象上来实现</p>        <p></p>        <p>注意：</p>        <p></p>        <ul>            <li>即使是使用var声明的变量也不会默认挂载到全局对象上，这点和浏览器端的window对象有区别，需要手动挂载                <div class="codeMirror">                    <pre><xmp>console.log(global)var message = ''console.log(global.message) // undefinedglobal.message = message // 挂载到全局对象上，所有模块都能访问</xmp></pre>                </div>            </li>            <li>挂载到global对象上的属性同window对象上的一样，可以不加顶级对象直接使用挂载的属性（前提是有属性挂载过，否则会报错）                <div class="codeMirror">                    <pre><xmp>global.a = 1console.log(a) // 1</xmp></pre>                </div>            </li>        </ul>        <p></p>        <h3 id="s3.3">3.3 模块对象module</h3>        <p></p>        <p>module是node中内置的模块系统对象，该对象内部拥有几个与模块相关的属性。</p>        <p></p>        <div class="codeMirror">            <pre><xmp>console.log(module)/*    Module {        id: '.',        exports: {},        parent: null,        filename: 'E:\\demo\\学习项目\\node\\2.module-object.js',        loaded: false,        children: [],        paths:         [ 'E:\\demo\\学习项目\\node\\node_modules',           'E:\\demo\\学习项目\\node_modules',           'E:\\demo\\node_modules',           'E:\\node_modules'         ]        }*/</xmp></pre>        </div>        <p></p>        <p>属性：</p>        <p></p>        <ul>            <li>id:当前模块的唯一标识，是以node执行的入口js文件和项目工程为参照的绝对路径，默认入口的id为.，其余文件的id为其绝对路径</li>            <li>filename:当前文件的绝对路径，其实默认是和id的值是一样的</li>            <li>parent和children:相对而言的属性，一个模块被另一个模块引用，另一个模块就是该模块的父模块，相对的，该模块是另一模块的子模块</li>            <li>loaded:当前模块是否加载完成</li>            <li>path:node解析策略构成的一个数组</li>            <li>exports:与全局的exports共用一个内存，但是在导出模块的时候该属性下的内存起主导作用</li>        </ul>        <p></p>        <h3 id="s3.4">3.4 核心模块</h3>        <p></p>        <p>node为JS提供了很多服务器级别的API,这些API绝大多数都被包装到了一个具体的核心模块中了,例如文件操作的fs模块,http服务构建的http模块,path的路径模块,os操作系统信息模块,url专门对域名进行处理等querystring模块专门处理查询字符串,所有模块的使用都需要通过require()来获取</p>        <p></p>        <p></p>        <p></p>        <h4 id="s3.4.1">3.4.1 path模块</h4>        <p></p>        <ul>            <li>path.basename:获取一个路径的文件名(默认包含扩展名)</li>            <li>path.dirname:获取一个路径的目录部分</li>            <li>path.parse:把一个路径转为对象<br/>对象属性:</li>            <ul>                <li>root:根路径</li>                <li>dir:目录</li>                <li>base:包含后缀名的文件名</li>                <li>ext:后缀名</li>                <li>name:不包含后缀名的文件名</li>            </ul>            <li>path.join:当需要进行路径拼接的时候,推荐使用这个方法</li>            <li>path.isAbsolute:判断一个路径是否是绝对路径</li>        </ul>        <p></p>        <div class="codeMirror">            <pre><xmp>const path = require('path')const pathObj = path.parse(__filename)console.log(pathObj)/*{ root: 'E:\\',  dir: 'E:\\demo\\学习项目\\node',  base: 'app.js',  ext: '.js',  name: 'app' }*/</xmp></pre>        </div>        <p></p>        <h4 id="s3.4.2">3.4.2 os模块</h4>        <p></p>        <div class="codeMirror">            <pre><xmp>const os = require('os')const totalMemory = os.totalmem()const freeMemory = os.freemem()console.log(`Total Memory: ${totalMemory}`)console.log(`Free Memory: ${freeMemory}`)/*Total Memory: 8468779008Free Memory: 1898426368*/</xmp></pre>        </div>        <p></p>        <h4 id="s3.4.3">3.4.3 fs模块</h4>        <p></p>        <p>浏览器中的JS是没有操作文件的能力的,但是node中的JS具有文件操作的能力</p>        <p></p>        <p>fs是file-system的简写,就是文件系统,在node中如果想进行文件操作,就要引入fs这个核心模块,这个核心模块中提供了所以文件相关的API操作</p>        <p></p>        <ul>            <li>读取文件                <div class="codeMirror">                    <pre><xmp>//例子:使用fs.readFile()读取文件var fs=require("fs");//使用require方法加载fs模块//读取文件,第一个参数是要读取的文件路径,第二个参数是options选项,包括度入文件的编码(这个参数可以不写),第三个参数是回调函数//读取文件时不管里面是什么文件,得到的都会是Buffer格式,除非在第二个参数写入了文件编码fs.readFile("a.txt","utf8",function(err,data){//如果不写第二个参数下面就要toString()    /*        如果读取成功,data就是得到的数据,而err为null        如果读取失败,data为undefined,err为错误对象    */    //对是否读取成功进行判断    if(err){        console.log("读取失败");    }else{         //注意:如果不进行toString()操作转换为我们可以认识的字符串,会输出16进制编码        console.log(data.toString());       }})//注意:fs.readFile()有局限性,只能读取体积较小的文件</xmp></pre>                </div>            </li>            <li>写入文件                <div class="codeMirror">                    <pre><xmp>//例子:通过fs.writeFile()写入文件,如果没有该文件则自动创建var fs=require("fs");/*第一个参数:文件路径第二个参数:文件内容,可以在文件里面写入任何的数据类型,所以数据都会被隐式转换为字符串第三个参数:options选项,包括写入文件的方式(这个参数可以不写)第四个参数:回调函数*///异步写入文件fs.writeFile("b.txt","hello world",function(err){/*    如果文件写入成功,error是null    如果文件写入失败,error是错误对象*///判断是否写入成功if(err){     console.log(err);   }else{     console.log("写入成功");   }});//同步写入文件fs.writeFileSync("b.txt","hello world");//注:可通过先读再写入文件的方式实现文件的复制</xmp></pre>                </div>            </li>            <li>流式读取写入文件                <div class="codeMirror">                    <pre><xmp>var fs=require("fs");var rs=fs.createReadStream("a.txt");//流体式打开一个文件var ws=fs.createWriteStream("b.txt");//流体式写入一个文件                                rs.resum();//同过该方法可以让可读流中的数据流动,否则不会进行读取操作rs.on("data",(chunk)=>{//也可已通过绑定data事件让可读流运动    ws.write(chunk);//chunk就是读取到的数据,通过可写流可以直接写入可读流读取的数据});//通过这样的方法复制文件是通过两根管子进行复制的/*rs.pipe(ws);//直接使用pipe函数可以只通过一个函数进行复制*/rs.on("end",()=>{//全部读取完成后才会执行该方法   console.log("读取完成"); });</xmp></pre>                </div>            </li>            <li>删除文件                <div class="codeMirror">                    <pre><xmp>//使用fs.unlinkSync()删除文件,返回值为undefinedvar fs=require("fs");fs.unlinkSync("b.txt");</xmp></pre>                </div>            </li>            <li>删除目录                <div class="codeMirror">                    <pre><xmp>var fs=require("fs");fs.rmdir("testDir",(err,data)=>{    if(err){        onsole.log(err);    }else{        console.log(data);    }})</xmp></pre>                </div>            </li>            <li>新建目录                <div class="codeMirror">                    <pre><xmp>var fs=require("fs");fs.mkdirSync("testDir");</xmp></pre>                </div>            </li>            <li>查看目录                <div class="codeMirror">                    <pre><xmp>const os = require('os')const totalMemory = os.totalmem()const freeMemory = os.freemem()console.log(`Total Memory: ${totalMemory}`)console.log(`Free Memory: ${freeMemory}`)/*Total Memory: 8468779008Free Memory: 1898426368*/</xmp></pre>                </div>            </li>            <li>其他</li>            <ul>                <li>限制指定文件字节长度</li>                <li>判断指令路径下的文件或目录是否存在</li>                <li>查看文件信息</li>                <li>移动文件</li>                <li>监听文件</li>            </ul>            <div class="codeMirror">                <pre><xmp>var fs=require("fs");fs.truncateSync("b.txt",5);//会将文件中的字节进行限制,如果该文件里有超过5个字节,会出现乱码                            let result=fs.existsSync("b.txt");//判断文件是否存在,存在返回true                            let result2=fs.statSync("b.txt");console.log(result2);//查看文件信息,返回的是一个对象/*    rename(旧路径,新路径,回调函数)    1.把旧路径的文件移动到新路径    2.改名*/fs.rename("../b.txt","b.txt",(err)=>{    if(err){    console.log(err);    }})fs.watchFile("b.txt",(cur,pre)=>{    console.log(cur,pre);//cur为现在文件的状态,pre为上次文件的状态})</xmp></pre>            </div>        </ul>        <p></p>        <h4 id="s3.4.4">3.4.4 events模块</h4>        <p></p>        <p>大多数 Node.js 核心 API 构建于惯用的异步事件驱动架构，其中某些类型的对象（又称触发器，Emitter）会触发命名事件来调用函数（又称监听器，Listener）。</p>        <p></p>        <p>例如，net.Server 会在每次有新连接时触发事件，fs.ReadStream 会在打开文件时触发事件，stream会在数据可读时触发事件。</p>        <p></p>        <p>所有能触发事件的对象都是 EventEmitter 类的实例。 这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上。 事件的命名通常是驼峰式的字符串，但也可以使用任何有效的 JavaScript 属性键。</p>        <p></p>        <p>当 EventEmitter 对象触发一个事件时，所有绑定在该事件上的函数都会被同步地调用。 被调用的监听器返回的任何值都将会被忽略并丢弃。</p>        <p></p>        <div class="codeMirror">            <pre><xmp>// 注意，导入的对象其实是一个事件类，events模块的许多方法都是基于这个类实现const EventEmitter = require('events')const emitter = new EventEmitter()                        // 注册一个监听器 on 与 addeventListener 是一样的emitter.on('messageLogged', arg => {  console.log('Listener called', arg)})emitter.addListener('messageLogged', arg => {  console.log('Listener2 called', arg)})// 抛出事件，传参数更好的方法是通过传一个对象，而不是传多个形参emitter.emit('messageLogged', { id: 1, url: 'http://' })// 注意要先监听，不然没效果/*Listener called { id: 1, url: 'http://' }Listener2 called { id: 1, url: 'http://' }*/</xmp></pre>        </div>        <p></p>        <p>注意：一般来说我们只会包装整个程序中有一个EventEmitter的实例，因为不同实例的监听与抛出事件是不会有效果的</p>        <p></p>        <div class="codeMirror">            <pre><xmp>// logger.jsconst EventEmitter = require('events')const url = 'http://mylogger.io/log'                        class Logger extends EventEmitter {  log(message) {    // send a http request    console.log(message)    // raise an event    this.emit('messageLogged', { id: 1, url: 'http://' })  }}module.exports = Logger</xmp></pre>        </div>        <p></p>        <div class="codeMirror">            <pre><xmp>// app.jsonst Logger = require('./logger')const logger = new Logger()                        logger.on('messageLogged', arg => {  console.log('Listener called', arg)})logger.log('message')</xmp></pre>        </div>        <p></p>        <h4 id="s3.4.5">3.4.5 http模块</h4>        <p></p>        <p>使用node可以轻松得构建一个web服务器,在Node中专门提供了一个核心模块http,这个模块就是用来编写创建服务器的</p>        <p></p>        <div class="codeMirror">            <pre><xmp>const http = require('http')// 返回值其实是一个EventEmitter，继承了前者所有的方法const server = http.createServer((req, res) => {    if (req.url === '/') {      res.write('Hello World')      res.end()    } else if (req.url === '/api/courses') {      res.write(JSON.stringify([1, 2, 3]))      res.end()    }  })    // 监听连接的句柄，如果有人进入了监听的端口就会有响应,  当然，一般不这样写，一般是在http.createServer函数的回调函数中邪  // server.on('connection', socket => {  //   console.log('New connection...')  // })    server.listen(3000, () => {    console.log('connect completely...')  })</xmp></pre>        </div>        <p></p>        <div class="codeMirror">            <pre><xmp>//加载http模块var http=require("http");//使用http.createServer()方法创建一个web服务器,该方法返回一个Server实例var server=http.createServer();/*也可以直接var server=http.createServer((request,response)=>{        });不用注册请求事件,默认为请求事件*///客户端发送请求->服务端接收处理反馈请求/*注册request（与上面的connection事件是一个效果）请求事件,当客户端请求过来,就会自动触发服务器的request请求事件,然后执行回调函数*/server.on("request",function(request,response){    /*        request请求事件的处理函数接收两个参数:        1.request请求对象,请求对象可以用来获取客户端的一些请求信息,如请求路径(url属性)等        2.response响应对象,响应对象可以给客户端发送信息                一个请求对应一个响应,如果一个请求的过程中已经结束响应了,        则不能重复发出响应,同时没有请求就没有响应    */    console.log("接收到请求,请求的路径为"+request.url);    /*        response对象有一个write方法可以接收到请求后给服务端发出响应数据        注意:响应内容只能是二进制数据或者字符串,如果要传入一个对象可以用JSON转换    */        response.write("hello world");        response.write("你好世界");    /*注意:        1.write方法可以使用多次,但最后一定要加上end方法表示响应完成,否则会一直响应        2.在服务端默认发送的数据其实是UTF-8编码的内容,但是浏览器不知道是UTF-8d的编码,        会默认按照当前操作系统的默认编码去解析,中文操作系统的默认编码是gbk,        所以需要告诉浏览器发送的是什么编码    */        response.setHeader("Content-Type","text/plain;charset=utf-8");        //在http协议中,Content-Type就是告知要发送的数据类型是什么,不同的响应内容对应的类型不一样        //plain为普通文本        response.end();    /*        上面的写法几乎不用,可以直接用response.end("hello world你好事件");        并且这种写法每次请求的结果都一样,即使访问的路径不同    */    });//绑定端口号,启动服务器server.listen(3000,function(){   console.log("服务器已成功启用在3000端口,可以通过localhost:3000访问");           });</xmp></pre>        </div>        <p></p>        <div class="codeMirror">            <pre><xmp>var http=require("http");var server=http.createServer();erver.on("request",function(request,response){    /*    根据不同的请求路径发送不同的响应结果    1.获取请求路径,request.url获取到的是端口号之后的那一部分路径,也就是说所有的url都是以\开头的    2.判断路径处理响应*/var url=request.url;if(url==="/"){    response.end("index page");}else if(url==="/login"){    response.end("login page");}else{    response.end("404 Not Found");}});server.listen(3000,function(){console.log("服务器已成功启用在3000端口,可以通过localhost:3000访问");           });</xmp></pre>        </div>        <p></p>        <div class="codeMirror">            <pre><xmp>var http=require("http");var server=http.createServer();                        server.on("request",function(request,response){    /*        根据不同的请求路径发送不同的响应结果        1.获取请求路径,request.url获取到的是端口号之后的那一部分路径,也就是说所有的url都是以\开头的        2.判断路径处理响应    */    var url=request.url;    if(url==="/plain"){        response.setHeader("Content-Type","text/plain;charset=utf-8");        response.end("你好世界");    }else if(url==="/html"){        //如果不写类型浏览器会默认解析html标签,但是又不会转换为UTF-8的编码        response.setHeader("Content-Type","text/html;charset=utf-8");        response.end("<p>你好世界</p>");    }else{        response.end("404 Not Found");    }    });server.listen(3000,function(){   console.log("服务器已成功启用在3000端口,可以通过localhost:3000访问");           });</xmp></pre>        </div>        <p></p>        <div class="codeMirror">            <pre><xmp>//用fs和http搭建简易服务器环境var fs=require("fs");var http=require("http");var url=require("url");//引入url模块可以更好的解决域名的传输var server=http.createServer();server.on("request",function(request,response){    var {pathname,query}=url.parse(request.url,true);//pares方法会将request请求发起的域名进行打包,    而后面的参数true是讲打包后的字符串转换为对象,pathname就是要请求的地址,query是后面的参数    if(pathname==="/html"){/*要注意的是如果请求的html页面有图片等需要再次加载的后台资源,在请求这里必须要设置一个pathname对应的请求分支*/    fs.readFile("index.html",function(err,data){            if(err){                  response.setHeader("Content-Type","text/plain;charset=utf-8");                        response.end("文件读取失败");              }else{                  response.setHeader("Content-Type","text/html;charset=utf-8");                //其实可以不要上面的代码,因为在网页中也可用申明是UTF-8编码                response.end(data);                //response.end()支持两种数据类型,二进制和字符串,不需要用toString()转换            }        })    }else if(pathname==="/plain"){         fs.readFile("a.txt",function(err,data){            if(err){                  response.setHeader("Content-Type","text/plain;charset=utf-8");                        response.end("文件读取失败");              }else{                  response.setHeader("Content-Type","text/plain;charset=utf-8");                response.end(data);            }        });    }else if(pathname==="/image.jpg"){//这是如果请求的html文件中有图片需要加载时请求对应图片的分支         fs.readFile("image.jpg",function(err,data){            if(err){                  response.setHeader("Content-Type","text/plain;charset=utf-8");                        response.end("文件读取失败");              }else{                  response.setHeader("Content-Type","image/jpeg");                //图片不需要字符编码,一般我们说字符编码都是字符                response.end(data);            }        })    }else{        response.setHeader("Content-Type","text/plain;charset=utf-8");        response.end("404 Not Found");    }    });//可以对读取的文件进行修改后再传输出去server.listen(3000,function(){   console.log("服务器已成功启用在3000端口,可以通过localhost:3000访问");           });</xmp></pre>        </div>        <p></p>        <h3 id="s3.5">3.5 用户自定义模块</h3>        <p></p>        <p>在node中没有全局作用域,只有模块作用域,默认都是封闭的,外部不能访问到内部的数据,而内部也无法访问到外部,所有不会有污染的问题,但是只能通过require()方法来加载多个JS脚本文件,如果想要访问一个模块作用域中的内容,需要同时使用require()方法与exports对象</p>        <p></p>        <p></p>        <p>require()的作用</p>        <p></p>        <ul>            <li>加载文件模块并执行里面的代码</li>            <li>拿到被加载文件模块导出的接口对象</li>        </ul>        <p></p>        <p>exports的作用</p>        <p></p>        <p>在每个文件模块中都提供了一个接口对象exports,exports默认是空对象,用户所要做的就是将想要被外部访问的变量或方法挂载到这个对象上,然后通过require()方法就会返回这个exports对象,通过赋值给变量就能实现对模块内部成员的使用了</p>        <p></p>        <div class="codeMirror">            <pre><xmp>//a.jsvar a=require("./b.js");console.log(a.foo);//123console.log(a.add());//3</xmp></pre>        </div>        <p></p>        <div class="codeMirror">            <pre><xmp>//b.jsvar foo=123;exports.foo=foo;exports.add=function(){    return 1+2;}</xmp></pre>        </div>        <p></p>        <p>exports与module.exports</p>        <p></p>        <p>两者默认情况下实际是连接的同一个对象,但真正起主导作用的是module.exports</p>        <p></p>        <div class="codeMirror">            <pre><xmp>//a.jsconsole.log(exports===module.exports);//trueexports={//此时exports为另一个对象    a:1}module.export={    b:2}//b.jsa=require("./a.js");console.log(a.a);//undefinedconsole.log(a.b);//2</xmp></pre>        </div>        <p></p>        <p>我们可以理解为模块导出的是module.exports这个属性上的值，而最开始exports和module.exports相同是因为有同一个引用，我们主动将exports变量上的引用改变了，所以导出的值是不一样的，我们不应该改变exports上面的引用</p>        <p></p>        <p>前后端的区别</p>        <p></p>        <ul>            <li>require:node和es6都支持的引入</li>            <li>export / import:只有es6支持的导出引入(node 8.x版本以后已经支持)</li>            <li>module.exports / exports:只有node支持的导出</li>        </ul>        <p></p>        <h3 id="s3.6">3.6 第三方模块</h3>        <p></p>        <p>模块导入：如果模块的加载是以./、../、/开始的，那么就是路径模块加载模式不以./、../、/开始的模块，按照的是node默认的模块解析机制，会从当前目录一次向上级目录查找node_modules，直到不能再往上查找，例如如果是windows系统就会查找到盘符</p>    </div>    <p></p>    <p></p>    <div class="list" id="s4">        <h2>4.npm</h2>        <p></p>        <p>npm全称为node package manager(包管理工具)</p>        <p></p>        <h3 id="s4.1">4.1 npm网站</h3>        <p></p>        <a href="">npm官网 专门用来下载包的地方</a>        <p></p>        <h3 id="s4.2">4.2 npm命令行工具</h3>        <p></p>        <p>升级npm(自己升级自己)</p>        <p></p>        <div class="codeMirror">            <pre><xmp>npm install --global npm</xmp></pre>        </div>        <p></p>        <h3 id="s4.3">4.3 常用命令</h3>        <p></p>        <ul>            <li>npm init,初始化项目,npm init -y可以跳过向导,快速生成初始化项目`</li>            <li>npm install,一次性下载package.json文件中的dependencies选项中的所有依赖项<br/>简写:npm i</li>            <li>npm install 包名,只下载包名<br/>简写:npm i 包名<br/>注：如果想下载指定版本，需要在后面加上@版本号</li>            <li>npm intall --save 包名,下载指定包名并保存依赖项(保存在package.json文件中的dependencies选项)                <br/>简写:npm i -S 包名</li>            <li>npm uninstall 包名,只删除包名<br/>简写:npm un 包名<br/>注：如果想删除指定版本，需要在后面加上@版本号</li>            <li>npm uninstall --save 包名,删除包名的同时也会把依赖信息去除<br/>简写:npm un -S 包名</li>            <li>npm list,以树形的形式列出所有的包依赖。npm list --depth=0,列出当前项目直接的包依赖</li>            <li>npm view 包名,查看指定包的package.json文件，如果只想看该文件中的某个属性，后面再加个空格更上属性名。同时，npm view 包名 versions可以查看该包发布过的所有版本</li>            <li>npm outdated,对比查看依赖包的版本信息</li>            <li>npm update,更新依赖包的次要版本和补丁版本<br/>注：如果主要版本改变，只会更新到次要版本的最高版本。如果要更新主要版本，需要再全局按照一个包管理工具npm-check-updates</li>            <div class="codeMirror">                <pre><xmp>npm i npm-check-updates -g</xmp></pre>            </div>            <p>然后在项目中运行npm-check-updates就能找到需要更新的包，再运行ncu -u就能更新大版本了。<br/>注：只是更新了package.json中的版本，并没有安装依赖，需要npm i安装依赖</p>            <p></p>            <p></p>            <li>npm login,登录npm账号</li>            <li>npm publish,发布一个包到npm（需要登录）</li>            <li>npm help,查看命令使用帮助</li>            <li>npm 命令 --help,查看指定命令使用帮助</li>        </ul>        <p></p>        <h3 id="s4.4">4.4 包版本管理</h3>        <p></p>        <p>npm使用语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新：</p>        <p></p>        <ol>            <li>如果只是修复bug，需要更新Z位。</li>            <li>如果是新增了功能，但是向下兼容，需要更新Y位。</li>            <li>如果有大变动，向下不兼容，需要更新X位。</li>        </ol>        <p></p>        <p>同时，npm还使用了~和^来帮忙推断安装依赖时应该选择哪个版本：</p>        <p></p>        <ul>            <li>~version（也就是X.x）</li>            <ul>                <li>如果次版本号指定，那么次版本号不变，而补丁版本号可以任意</li>                <li>如果次版本号和补丁版本号未指定，那么次版本号和补丁版本号可以任意</li>            </ul>            <li>^version（也就是X.Y.x）</li>            <ul>                <li>版本号中最左非零位不变，它右侧其他位可以任意</li>                <li>如果缺少某个版本号，那么这个版本号可以任意</li>            </ul>        </ul>        <p></p>        <p>当然，如果要安装指定版本直接改成x.y.z的形式就行了。</p>    </div>    <p></p>    <div class="list" id="s5">        <h2>5.进程process</h2>        <p></p>        <p>process 对象是一个全局变量（默认挂载在global对象上的），它提供有关当前 Node.js 进程的信息并对其进行控制。 作为一个全局变量，它始终可供 Node.js 应用程序使用，无需使用 require()。 它也可以使用 require() 显式地访问：</p>        <p></p>        <div class="codeMirror">            <pre><xmp>const process = require('process')</xmp></pre>        </div>        <p></p>        <p>它提供当前Node.js的进程有关的信息，以及控制当前Node.js进程，该变量下面有很多属性，下面列出几个属性:</p>        <p></p>        <ul>            <li>argv：接收在命令行输入的参数的数组</li>            <li>env：列举出当前系统的所有环境变量，是一个json对象，在windows中环境变量通过set来申明，mac是export<br/>注：一个好用的获取环境变量的库config，npm i config -S</li>        </ul>        <p></p>        <h3 id="s5.1">5.1 处理未被捕获的错误</h3>        <p></p>        <p>在node的运行中，如果在中途遇到错误会直接导致node程序崩溃，在很多情况下我们都能够去捕获到这些错误，但是如果并没有捕获，又不想程序崩溃，我们可以善用process监听uncaughtException事件与unhandledRejection（可以看出process也继承了事件触发器）</p>        <p></p>        <p></p>        <div class="codeMirror">            <pre><xmp>// 同步错误process.on('uncaughtException', (e) => {    console.log(e)})// 没有被catch的promise的rejectprocess.on('uncaughtException', (e) => {    console.log(e)    // throw e // 也可以抛出错误变成同步的})</xmp></pre>        </div>        <p></p>        <p>注：使用uncaughtException只能够捕获到如throw Error()这样的同步代码错误，无法监听到被rejected的promise。</p>        <p></p>        <p>注意：在程序报异常的时候，我们最好的做法是立刻终止程序，而不是让它处于未完成的状态。</p>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/Mongodb/"/>
    <url>/CodeNote/2020/10/23/zone/html/Mongodb/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title">            <h1>Mongodb</h1>        </div>    </div>    <div class="list" id="s1">        <h2>1. 安装并启动Mongodb</h2>        <p></p>        <ul>            <li>下载安装包并傻瓜式安装</li>            <li>配置环境变量,将安装的mongodb路径添加在环境变量中去</li>            <li>在C盘(或D盘等)的根目录下创建一个data文件夹,文件夹里面创建一个db文件夹(这是mongodb默认的路径)<br/>注:如果不想用默认路径可以自己选择一个空的文件夹创建db文件</li>            <li>打开命令行窗口输入mongod启动mongdb服务器,默认在27017端口访问mongodb<br/>注:</li>            <ul>                <li>如果只输入mongod就会使用默认的路径打开数据库,如果没有使用默认路径,需要使用 mongod --dbpath 自己设置的数据库db目录路径</li>                <li>如果不想在27017端口访问mongodb,可以在最后的路径后面输入空格再加上--port 端口号</li>            </ul>            <li>重新打开一个cmd窗口(前面那个不要关闭 ),输入mongo链接mongodb,出现>证明就能运行了</li>            <p></p>            <p>数据库(database)</p>            <p></p>            <li>数据库的服务器</li>            <ul>                <li>服务器用来保存数据</li>                <li>mongod命令用于启动服务器</li>            </ul>            <li>数据库的客户端</li>            <ul>                <li>客户端用来操作服务器,对数据进行增删查改的操作</li>                <li>mongo用来启动客户端</li>            </ul>    </div>    <div class="list" id="s2">        <h2>2.Mongodb系统服务</h2>        <p></p>        <p>将mongodb设置为系统服务,可以在后台启动,不需要每次都要手动启动</p>        <p></p>        <ul>            <li>在C盘根目录下创建的data文件夹中创建db和log文件夹</li>            <li>创建配置文件,在下载的mongdb目录中(与bin文件夹在同一层级),添加一个配置文件mongod.cfg,内容如下:                <div class="codeMirror">                    <pre><xmp>systemLog:    destination: file    path: c:\data\log\mongod.logstorage:    dbPath: c:\data\db</xmp></pre>                </div>                注意:path路径必须是要和前面的操作相对应            </li>            <li>然后以管理员身份打开cmd窗口,输入C:\mongodb安装目录\bin\mongo.exe --config "C:\mongodb安装目录\mongod.cfg" --install<br/>例子:C:\mongodb\bin\mongod.exe --config "C:\mongodb\mongod.cfg" --install</li>            <li>输入net start MongoDB启动mongodb服务(如果不生效，也可以打开任务管理器，找到相关服务，手动打开)</li>            <p></p>            <p>相关操作</p>            <p></p>            <li>net stop MongoDB关闭服务</li>            <li>sc.exe delete MongoDB删除服务</li>        </ul>    </div>    <div class="list" id="s3">        <h2>3.基本概念</h2>        <p></p>        <ul>            <li>数据库(database)</li>            <li>集合(collection)</li>            <li>文档(document)</li>            <p></p>            <p>注:在mongodb中,数据库和集合都不需要手动创建,当我们创建文档时,如果文档所在的集合或数据库不存在会自动创建数据库和集合</p>        </ul>        <p></p>        <h3 id="s3.1">3.1 导入导出数据</h3>        <p></p>        <ul>            <li>在mongodb中可以使用mongodump命令来备份mongodb数据。该命令可以导出所有数据到指定目录.可通过参数指定导出到数据量级转存的服务器                <div class="codeMirror">                    <pre><xmp>#mongodump -h dbhost(IP端口号) -d dbname(数据库名称) -o dbdiectory(存储备份数据的目录)mongodump -h 127.0.0.1 -d koa -o C:\Users\asus\Desktop\koaDb</xmp></pre>                </div>            </li>            <li>在mongodb中可以使用mongorestore命令可以用来恢复备份的数据                <div class="codeMirror">                    <pre><xmp>#mongorestore -h dbhost -d dbname &lt;path>mongorestore -h 127.0.0.1 -d koademo C:\Users\asus\Desktop\koaDb\koa#因为在上面导出数据库的时候是导出一整个数据库文件夹,所以需要进入到里面拿到koa文件夹</xmp></pre>                </div>            </li>        </ul>    </div>    <div class="list" id="s4">        <h2>4.指令</h2>        <p></p>        <h3 id="s4.1">4.1 基本指令</h3>        <p></p>        <ul>            <li>show dbs和show databases——显示当前的所有数据库</li>            <li>use 数据库名——进入到指定的数据库中</li>            <li>db——表示当前所处的数据库</li>            <li>show collections——显示数据库中所有的集合</li>        </ul>        <p></p>        <h3 id="s4.2">4.2 CRUD(增删改查)指令</h3>        <p></p>        <h4 id="s4.2.1">4.2.1 插入文档</h4>        <p></p>        <p>db.&lt;collection>.insert(),在insert()中接受一个对象或数组</p>        <p></p>        <div class="codeMirror">            <pre><xmp>db.test.insert({name:"张三",age:18}); db.test.insert([ {name:"张三",age:18}, {name"李四",age:19}]);</xmp></pre>        </div>        <p></p>        <p>注意:mongodb的属性值也可以是一个文档或一个数组,当一个文档的属性是文档时,我们说它是内嵌文档</p>        <p></p>        <h4 id="s4.2.2">4.2.2 查询文档</h4>        <p></p>        <ul>            <li>db.&lt;collection>.find(),在find()可以接受一个对象作为条件参数,如果传入一个空对象就和不传一样会查找集合中所有的文档,{属性:值}查询指定属性对应值的文档                <div class="codeMirror">                    <pre><xmp>db.test.find({name:"张三"});</xmp></pre>                </div>            </li>            <ul>                <p>注:</p>                <li>在开发时绝对不会执行不带条件的查询</li>                <li>find()的结果返回是一个数组,可以加上[0]等来查找指定的第几个文档</li>                <li>在后面可以加上count()或length()可以返回一共查找到的文档数量                    <div class="codeMirror">                        <pre><xmp>db.test.find({name:"张三"}).count();</xmp></pre>                    </div>                </li>                <li>在后面可以加上pretty()来格式化查询到的对象,便于观察结果</li>                <li>在后面可以使用limit()来限制显示文档的数量                    <div class="codeMirror">                        <pre><xmp>db.test.find({name:"张三"}).limit(10);//显示找到的从第一到第十条数据</xmp></pre>                    </div>                </li>                <li>在后面可以使用skip()来跳过指定数量的数据,常和limit()配合使用                    <div class="codeMirror">                        <pre><xmp>db.test.find({name:"张三"}).skip(10).limit(10);//显示找到的从第十到第二十条数据</xmp></pre>                    </div>                    注意:按照常规的逻辑应该是先用skip()再用limit(),但是如果两者交换了顺序mongodb也会进行自动的调整(如果在其中加入了sort()也会先执行sort()再执行其他两个)                </li>                <li>在后面加上populate()可以进行查询关联,查询可以关联到其他的集合</li>                <li>查询文档时,默认是按照_id的值进行升序排列,如果需要按照自己指定的顺序进行查询的排列,需要用sort()来指定排序的规则,sort()需要传递一个对象来指定排序规则,1表示升序,-1表示降序<br/>注:可以在一个对象中传递多个排序规则,按照从左到右的规则进行排序,如果一样就按照下一个规则排序                    <div class="codeMirror">                        <pre><xmp>db.test.find({name:"张三"}).sort({age:1}).skip(10).limit(10);db.test.find({name:"张三"}).sort({age:1,_id:-1}).skip(10).limit(10);</xmp></pre>                    </div>                </li>                <li>mongodb支持直接通过内嵌文档的属性进行查询,如果要查询内嵌文档则可以直接用第一个文档的属性名.第二个文档的属性名的形式来匹配(类似于JS的对象嵌套),此时的属性名必须要带上引号</li>                <li>如果要对查找的文档的属性进行大小等限制时,传入对象的属性值就为一个对象,该对象里面可以包含以下修饰操作符:</li>                <ul>                    <li>$gt(>),$gte(>=),$lt(&lt;),$lte(&lt;=),$ne(!=),$eq(==)<br/>注:这些关系表示符都可以在对象中写多个,进行多条件的限制查找                        <div class="codeMirror">                            <pre><xmp>db.test.find({age:{$lt:25,$gt:18}});</xmp></pre>                        </div>                    </li>                    <li>$or在查询的时候可以表示或者的关系,放在最外层的对象属性中,其属性是一个数组                        <div class="codeMirror">                            <pre><xmp>db.test.find({$or:[{age:{$lt:18}},{age:{$gt:25}}]});//age大于25或小于18</xmp></pre>                        </div>                    </li>                </ul>                <li>在查询时,可以在find()中传入第二个参数,在该参数位置设置查询结果的投影,设置了后就只会查询到的信息的指定结果,1代表显示该信息,0代表不显示                    <div class="codeMirror">                        <pre><xmp>db.test.find({name:"张三"},{age:1});//查询到的结果只会显示age和_id(默认的)db.test.find({name:"张三"},{age:1,_id:0});//查询结果只会显示age</xmp></pre>                    </div>                </li>            </ul>            <li>db.&lt;collection>.findOne(),用来查询集合中符合条件的第一个文档,返回的是一个文档对象,所以可以直接.属性名查询到对应的属性值</li>        </ul>        <p></p>        <h4 id="s4.2.3">4.2.3 修改文档</h4>        <p></p>        <ul>            <li>db.&lt;collection>.update(查询条件,新对象)<br/>注意:</li>            <ul>                <li>update()默认会使用新对象替换旧对象,如果要修改指定的属性,而不是替换需要使用修改操作符</li>                <ul>                    <li>$set可以用来修改文档的指定属性</li>                    <li>$unset可以用来删除文档的指定属性</li>                    <li>$push可以向一个数组的文档属性中添加一个新的元素(可以添加相同的元素)</li>                    <li>$addToSet可以向一个数组的文档属性中添加一个新的元素(不可以添加相同的元素,如果匹配到了不会加到数组里面去)</li>                    <li>$inc可以将一个文档的指定属性值进行自增修改</li>                </ul>                <div class="codeMirror">                    <pre><xmp>db.test.update({name:"张三"},{$set:{        gender:"男"//只将gender属性加进去了,而其他两个属性依然还在    }});                  db.test.update({name:"张三"},{$unset:{        name:1//因为是删除属性,所以后面的数据不管是什么都可以    }})        db.test.update({name:"张三"},{$inc:{        age:2;//年龄自增2,如果要减2则前面加-号    }})</xmp></pre>                </div>                <li>update()默认只会修改第一个符合条件的文档,如果想要修改多个文档,需要传入第三个对象参数,并在其中的multi属性中写上true</li>            </ul>            <li>db.&lt;collection>.updateOne(查询条件,新对象),修改一个符合条件的文档</li>            <li>db.&lt;collection>.updateMany(查询条件,新对象),同时修改多个符合条件的文档</li>        </ul>        <p></p>        <h4 id="s4.2.4">4.2.4 删除文档</h4>        <p></p>        <ul>            <li>db.&lt;collection>.remove(),删除符合条件的所有的文档,如果不传入参数就会报错,如果传入的是一个空的对象,则会将所有的文档都删除<br/>注意:remove()默认情况下会删除所有复合条件的文档,如果只想删除第一个符合条件的文档,需要再给remove()传入第二个参数,该参数为一个布尔值,设置为true就为只删除第一个符合条件的文档                <div class="codeMirror">                    <pre><xmp>db.test.remove({name:"张三"});db.test.remove({name:"张三",true});                            db.test.remove({});//情况呢整个集合,但是性能较差//如果真的想把一整个集合删除,使用下面的方式db.test.drop();//该方法会直接将一个集合删除</xmp></pre>                </div>            </li>            <li>db.&lt;collection>.deleteOne(),删除集合中的第一个复合条件的文档</li>            <li>db.&lt;collection>.deleteMany(),删除集合中的所有复合条件的文档</li>            <li>db.&lt;collection>.drop(),删除集合</li>            <li>db.dropDatabase,删除数据库</li>        </ul>        <p>注意:一般数据库中的数据不会删除,所以删除的方法很少调用,一般会在数据库中添加一个字段来表示数据是否被删除</p>        <p></p>        <div class="codeMirror">            <pre><xmp>//如下面用isDel属性表示是否删除了某个文档db.test.updateMany({},{isDel:0});db.test.updateOne({name:"张三"},{$set:{    isDel:1}});db.test.find({isDel:0});</xmp></pre>        </div>        <p></p>        <p>注:数据库的方法调用的时候尽量少调用,因为会非常的消耗性能,如果要连续插入很多的数据,最好先装在一个数组中再将整个数组传入到数据库中</p>        <p></p>        <div class="codeMirror">            <pre><xmp>//如同时向数据库中插入20000条数据 for(var i=0;i<20000;i++){    db.numbers.insert({num:i});//花费7.2s}var arr=[];for(var i=1;i<20000;i++){    arr.push(i);}db.numbers.insert(arr);//花费0.4s</xmp></pre>        </div>    </div>    <div class="list" id="s5">        <h2>5.文档间的关系</h2>        <p></p>        <ul>            <li>一对一,通过内嵌文档的形式体现出一对一的关系</li>            <li>一对多/多对一,通过内嵌文档来映射一对多的关系(通过联表的文档查询)                <div class="codeMirror">                    <pre><xmp>var user_id=db.users.findOne({name:"张三"})._id;//在这获取到独立的_iddb.order.insert({name:"苹果",user_id:user_id});db.order.find({user_id:user_id});//通过两个文档的链接可以实现一对多的关系,通过_id进行查询</xmp></pre>                </div>            </li>            <li>多对多,通过数组形式的内嵌文档来映射一对多的关系(通过联表的文档查询)                <div class="codeMirror">                    <pre><xmp>var user_id1=db.users.findOne({name:"张三"})._id;var user_id2=db.users.findOne({name:"李四"})._id;db.order.insert([{name:"苹果",user_id:[user_id1,user_id2]}]);db.order.find({name:"苹果"});</xmp></pre>                </div>            </li>        </ul>    </div>    <div class="list" id="s6">        <h2>6.Mongodb聚合管道</h2>        <p></p>        <p>使用聚合管道可以对集合中的文档进行变换和组合</p>        <p></p>        <p>具体用法:使用aggregate()函数进行查询,内部传入一个数组作为参数,数组中是一个个聚合管道的对象,实现对应的功能</p>        <p></p>        <p>实际项目:表的关联查询、数据的统计</p>        <table>            <tr>                <td>管道操作符</td>                <td>描述</td>            </tr>            <tr>                <td>$project</td>                <td>增加、删除、重命名字段</td>            </tr>            <tr>                <td>$math</td>                <td>条件匹配,只有满足条件的文档才能进入下一阶段</td>            </tr>            <tr>                <td>$limit</td>                <td>限制结果的数量</td>            </tr>            <tr>                <td>$skip</td>                <td>跳过文档的数量</td>            </tr>            <tr>                <td>$sort</td>                <td>条件排序</td>            </tr>            <tr>                <td>$group</td>                <td>条件组合结果</td>            </tr>            <tr>                <td>$sum</td>                <td>求和,计算选中的数量,通过赋值每满足一个文档就会增加相应的数量</td>            </tr>            <tr>                <td>$lookup</td>                <td>用于引入其它集合的数据</td>            </tr>        </table>        <p></p>        <h3 id="s6.1">6.1 $project</h3>        <p></p>        <p>修改文档的结构,可以用来重命名、增加或删除文档中的字段</p>        <p></p>        <div class="codeMirror">            <pre><xmp>db.test.aggregate([    {        $project:{trade_no:1,all_price:1}        //会查询出同时含有这两个属性的文档,同时查找出来的文档只会显示出这两个属性    }])</xmp></pre>        </div>        <p></p>        <h3 id="s6.2">6.2 $match</h3>        <p></p>        <p>用于过滤文档,用法类似find()方法中的参数</p>        <p></p>        <div class="codeMirror">            <pre><xmp>db.test.aggregate([    {        $project:{trade_no:1,all_price:1}    },    {        $match:{"all_price":{$gte:90}}        //查找大于90价格的文档,该查询的初始数据是由上面的对象筛选下来的    }])</xmp></pre>        </div>        <p></p>        <h3 id="s6.3">6.3 $group</h3>        <p></p>        <p>将集合中的文档进行分组,可用于统计结果</p>        <p></p>        <div class="codeMirror">            <pre><xmp>db.test.aggregate([    {        $ground:{_id:"$order_id",total:{$sum:"$num"}}        /*            将所有order_id相同的文档进行分组,分组后的一组属性的属性值有_id和total(都是自己设置),            然后用$sum聚合管道将所有组的num属性值加起来赋值给新的total属性            注意:这里面只依据了order_id进行分组,total不是用来分组的        */    }])</xmp></pre>        </div>        <h3 id="s6.4">6.4 $sort</h3>        <p></p>        <p>将集合中的文档进行排序</p>        <p></p>        <div class="codeMirror">            <pre><xmp>db.test.aggregate([    {        $project:{trade_no:1,all_price:1}    },    {        $match:{"all_price":{$gte:90}}    },    {        $sort:{"all_price":-1}//-1表示降序排序,1为升序排列    }])</xmp></pre>        </div>        <p></p>        <h3 id="s6.5">6.5 $limit</h3>        <p></p>        <p>对查找到集合中的文档进行数量限制</p>        <p></p>        <div class="codeMirror">            <pre><xmp>db.test.aggregate([    {        $project:{trade_no:1,all_price:1}    },    {        $match:{"all_price":{$gte:90}}    },    {        $sort:{"all_price":-1}//-1表示降序排序,1为升序排列    },    {        $limit:1//只返回一条数据    }])</xmp></pre>        </div>        <p></p>        <h3 id="s6.6">6.6 $skip</h3>        <p></p>        <p>对查找到的集合中的文档进行一定的跳过忽略</p>        <p></p>        <div class="codeMirror">            <pre><xmp>db.test.aggregate([    {        $project:{trade_no:1,all_price:1}    },    {        $match:{"all_price":{$gte:90}}    },    {        $sort:{"all_price":-1}//-1表示降序排序,1为升序排列    },    {        $skip:1//跳过第一条数据,也就是说拿到的数据库中的文档默认是从第二条数据开始的    }])</xmp></pre>        </div>        <p></p>        <h3 id="s6.7">6.7 $lookup</h3>        <p></p>        <p>用于进行有关联集合的查找</p>        <p></p>        <div class="codeMirror">            <pre><xmp>//单表关联db.test.aggregate([{    $lookup:{//下面的写法左边为固定写法        from:"test2",//从哪个关联的集合中查找        localField:"order_id",//该集合中的关联项,名字只要相互对应就可以了        foreignField:"order_id",//关联集合的关联项        as:"items"//自定义的属性        /*        在关联集合中找到的文档会在返回结果的文档中的items属性中存在(作为一个自定义新增的属性),        该值为一个数组,查找到的关联集合中的文档为一个个对象成员        */    }}])</xmp></pre>        </div>        <p></p>        <div class="codeMirror">            <pre><xmp>//多表关联db.test.aggregate([{    $lookup:{        from:"test2",        localField:"order_id",        foreignField:"order_id",        as:"items"    }},{    $lookup:{        from:"test3",        localField:"order_id2",        foreignField:"order_id2",        as:"items2"    }}])</xmp></pre>        </div>    </div>    <div class="list" id="s7">        <h2>7.Mongoose</h2>        <p></p>        <h3 id="s7.1">7.1 下载安装Mongoose</h3>        <p></p>        <div class="codeMirror">            <pre><xmp>npm i mongoose --save</xmp></pre>        </div>        <p></p>        <h3 id="s7.2">7.2 在项目中引入Mongoose</h3>        <p></p>        <div class="codeMirror">            <pre><xmp>//导入mongoosevar mongoose=require("mongoose");        //链接mongosedb数据库mongoose.connect("mongodb://数据库的ip地址:端口号/数据库名",{userNewUrlParser:true});//如果端口号是默认端口号(27017)则可以省略不写//断开数据库链接(一般不需要调用)//mongodb数据库,一般情况下,只需要连接一次,连接一次后除非项目停止服务器关闭,否则连接一般不会断开mongoose.disconnect();/*监听mongodb数据库的连接状态:在mongoose对象中,有一个connection属性,该对象表示的就是数据库连接,通过监视该对象的状态,可以来监听数据库的连接与断开*///数据库连接成功的事件mongoose.connection.once("open",function(){});mongoose.connection.once("close",function(){});</xmp></pre>        </div>        <p></p>        <h3 id="s7.3">7.3 创建模型</h3>        <p></p>        <div class="codeMirror">            <pre><xmp>//将mogoose.Schema赋值给一个变量var Sechema=mongoose.Schema;//创建Schema(模式)对象var blogSchema = new Schema({//限制属性值    title:  String,    author: String,    body:   String,    comments: [{ body: String, date: Date }],    date: { type: Date, default: Date.now },//可以有默认值,用默认值时是这种写法    hidden: Boolean,    meta: {        votes: Number,        favs:  Number    },    authod_id:{        type:Schema.Types.ObjectId        //类型是一个ObjectId,在创建实例模型的时候可以直接传输ID字符串,会自动转换为ObjectId    }});var blogModel=mongoose.model("blog",blogSchema);//默认会在数据库中建立一个复数形式的blog集合//如果想要指定集合名字,可以传入第三个字符串参数,该参数的就是创建的集合名字blogMode.create({    title:"我的博客",    author:"Coloring"//假设只用填这两个},function(err){    if(!err){        console.log("插入成功");    }})</xmp></pre>        </div>        <p></p>        <p>另一种写法</p>        <p></p>        <div class="codeMirror">            <pre><xmp>//另一种方式const mongoose=require("mongoose");//连接mongodb服务器//通过这种方式返回一个对象const db=mongoose.createConnection(    "mongodb://localhost:27017/数据库名",//有就会直接连接,没有就会在数据库创建并连接    {userNewUrlParser:true});//用原生ES6的Promise取代mongoose自实现的Promisemongoose.Promise=global.Promise;//注意:在使用数据库之前,需要使用Schema设置每个字段的数据类型//将mogoose.Schema赋值给一个变量const Sechema=mongoose.Schema;//创建Schema(模式)对象const blogSchema = new Schema({//限制属性值    title:  String,    author: String,    body:   String,    comments: [{ body: String, date: Date }],    date: { type: Date, default: Date.now },//可以有默认值,用默认值时是这种写法    hidden: Boolean,    meta: {        votes: Number,        favs:  Number    }  });const blogModel=mongoose.model("blog",blogSchema);/*默认会在数据库中建立一个复数形式的blog集合如果想要指定集合名字,可以传入第三个字符串参数,该参数的就是创建的集合名字*/const d1=new blogModel({    title:"我的博客",    author:"Coloring"//假设只用填这两个});d1.save().then(res=>{//因为在之前用mongoose.Promise=global.Promise;所以现在可以用ES6的语法    console.log(res);}).catch(err=>{    console.log(err);})</xmp></pre>        </div>        <p></p>        <h4 id="s7.3.1">7.3.1 mongoose修辞符</h4>        <p></p>        <ul>            <li>trim:内置修饰符,用于将传入的String类型的数据进行去除两端的空格</li>            <li>set:自定义修辞符函数,用于用户自己定义传入后的参数的变化</li>        </ul>        <div class="codeMirror">            <pre><xmp>const blogSchema = new Schema({//限制属性值    name:{        type:String,        trim:true,        ser(value){//自定义修辞符,将传入name属性进行自定义的改变,第一个形参就是对应的属性            return value;        }    }});</xmp></pre>        </div>        <p></p>        <h4 id="s7.3.2">7.3.2 mongoose校验参数</h4>        <p></p>        <ul>            <li>内置校验参数</li>            <ul>                <li>type:指定类型</li>                <li>require:表示这个数据必须传入</li>                <li>max:用于Number类型数据的最大值</li>                <li>min:用于Number类型数据的最小值</li>                <li>maxlength:字符串最大值,注意的是这个参数和下面四个参数都是用于String类型的</li>                <li>minlength:字符串最小值</li>                <li>enum:枚举类型,要求数据必须为枚举值,如enum:['0','1','2']</li>                <li>match:增加的数据必须符合match(正则)的规则</li>            </ul>            <div class="codeMirror">                <pre><xmp>const blogSchema = new Schema({//限制属性值    name:{        type:String,        require:true,        maxlength:10,        minlength:1,        enum:["zhangsan","lisi"],//传入的数据必须为张三或者李四，        match:/^zhangsan$/i  //math的值应该是一个正则表达式    },    age:{        type:Number,        require:true,        max:100,        min:0,    }});</xmp></pre>            </div>            <li>自定义校验参数</li>            <ul>                <li>validate:该值应该赋值为一个函数,第一个形参就是要校验的属性</li>            </ul>            <div class="codeMirror">                <pre><xmp>const blogSchema = new Schema({//限制属性值    name:{        type:String,        validate:function(val){            return val.length>10;//如果返回false代表验证失败        }    }});</xmp></pre>            </div>        </ul>        <p></p>        <h4 id="s7.3.3">7.3.3 mongoose设置索引</h4>        <p></p>        <ul>            <li>index:设置普通索引,设置后就可以使用Model.getIndexes依靠设置的索引查找到对应的文档</li>            <li>unique:设置唯一索引,唯一索引的值在数据库中只能出现一次,不能够像普通索引一样可以是相同的值</li>        </ul>        <div class="codeMirror">            <pre><xmp>const blogSchema = new Schema({//限制属性值    name:{        type:String,        index:true    },    age:{        type:Number,        unique:true    }});</xmp></pre>        </div>        <p></p>        <h3 id="s7.4">7.4 Model的方法</h3>        <p></p>        <h4 id="s7.4.1">7.4.1 创建文档</h4>        <p></p>        <p>使用Model.create()用来创建一个或多个文档并添加到数据库中</p>        <p></p>        <p>参数:</p>        <ul>            <li>doc(s),可以是一个文档对象,也可以是一个包含文档对象的数组</li>            <li>callback,当操作完成以后调用的回调函数</li>        </ul>        <div class="codeMirror">            <pre><xmp>Candy.create({ type: 'jelly bean' }, { type: 'snickers' }, function (err, jellybean, snickers) {  if (err) // ...});                  var array = [{ type: 'jelly bean' }, { type: 'snickers' }];Candy.create(array, function (err, candies) {  if (err) // ...  var jellybean = candies[0];//第二个参数是插入的文档  var snickers = candies[1];  // ...});// 可以不写回调函数而写Promise的形式var promise = Candy.create({ type: 'jawbreaker' });promise.then(function (jawbreaker) {  // ...})</xmp></pre>        </div>        <p></p>        <h4 id="s7.4.2">7.4.2 查询文档</h4>        <p></p>        <ul>            <li>Model.find(conditions,[projection],[options],[callback])查询所有符合条件的文档,结果总会返回一个数组<br/>参数:</li>            <ul>                <li>condions,查询的条件<br/>注:如果传入的是一个空对象会返回所有的文档</li>                <li>projection,投影,拿到需要获取到的字段,该参数有两种写法</li>                <ul>                    <li>对象写法,同使用原始的mongodb查询数据一样,1代表显示,0代表不显示,默认显示_id,如{name:1, _id:0}</li>                    <li>字符串写法,用空格当分割符,如果写了就代表要投影出该属性,默认显示_id,如果不想显示在前面添加-号,如"name - _id"</li>                </ul>                <li>options,查询选项,如skip,limit等填写在该对象中,如{skip:3,limit:1}</li>                <li>callback,回调函数,查询结果会通过回调函数返回,回调函数必须传,如果不传回调函数,该查询方法不会进行,该回调函数的第一个参数是错误参数,第二个参数是查询到的文档</li>                <li>所以增删改查方法都会返回一个Promise对象,所以可以用then()来接收后续代码</li>            </ul>            <li>Model.findById(id(string),[projection],[options],[callback])根据文档的ID查询文档,返回一个对象<br/>注:该函数通过传入文档的字符串id进行查询</li>            <li>Model.findOne(conditions,[projection],[options],[callback])查询所有符合条件的第一个文档,总会返回一个具体的文档对象</li>        </ul>        <p></p>        <p>注意:</p>        <p></p>        <ul>            <li>通过find()等查询到的结果返回的对象就是Document文档对象,Document就是Model的实例</li>            <li>在mongoose中不能直接通过_id:"具体ID字符串"的进行查找文档,必须使用对应查找ID的API或者使用mongoose.Types.ObjectId("ObjectId字符串")封装成一个ObjectId对象来查找</li>        </ul>        <p></p>        <h4 id="s7.4.3">7.4.3 修改文档</h4>        <p></p>        <ul>            <li>Model.update(conditions,doc,[options],[callback])用来修改一个或多个文档<br/>参数:</li>            <ul>                <li>condions,查询条件</li>                <li>doc,修改后的对象</li>                <li>options,配置参数</li>                <li>callback,回调函数</li>            </ul>            <li>Model.updateOne(conditions,doc,[options],[callback])</li>            <li>Model.updateMany(conditions,doc,[options],[callback])</li>            <li>Model.replaceOne(conditions,doc,[options],[callback]),该函数不用传入$set来修改指定值,只需要传入要修改的对象就可以了</li>            <li>Model.findByIdAndUpdate(_id,doc,[options],[callback]),根据ID进行查找和更新</li>        </ul>        <p></p>        <h4 id="s7.4.4">7.4.4 删除文档</h4>        <p></p>        <ul>            <li>Model.remove(conditions,[callback]),默认删除多个文档,如果只想删除一个把conditons中的single设置为true</li>            <li>Model.deleteOne(conditions,[callback])</li>            <li>Model.deleteMany(conditions,[callback])</li>            <li>Model.findByIdAndRemove(id,[callback])</li>        </ul>        <p></p>        <h4 id="s7.4.5">7.4.5 计算文档总数</h4>        <p></p>        <p>Model.count(conditions,[callbcak])能计算查询到的文档总数,该值在callback的第二个参数中</p>        <p></p>        <div class="codeMirror">            <pre><xmp>Candy.count({},function(err,count){    console.log(count);})</xmp></pre>        </div>        <p></p>        <h4 id="s7.4.6">7.4.6 moogoose聚合管道</h4>        <p></p>        <p>moogoose中的聚合管道与原生的mongodb中的聚合管道用法类似,只需要用Model.aggregate()内部传入同样的管道操作符即可</p>        <p></p>        <div class="codeMirror">            <pre><xmp>Candy.aggregate([    {        $lookup:{//下面的写法左边为固定写法            from:"test2",//从哪个关联的集合中查找            localField:"order_id",//该集合中的关联项,名字只要相互对应就可以了            foreignField:"order_id",//关联集合的关联项            as:"items"//自定义的属性            /*            在关联集合中找到的文档会在返回结果的文档中的items属性中存在(作为一个自定义新增的属性),            该值为一个数组,查找到的关联集合中的文档为一个个对象成员            */        }    },    {        $lookup:{            from:"test3",            localField:"order_id2",            foreignField:"order_id2",            as:"items2"        }    },    {        $match:{_id:mongoose.Types.ObjectId("5d11b5e3ec794933d42f67e8")}        //在mongoose中使用mongoose.Types.ObjectId("ObjectId字符串")来查找Objectid    }],function(err,docs){    if(err){        console.log(err);        return;    }    console.log(JSON.stringfy(docs));})</xmp></pre>        </div>        <p></p>        <h4 id="s7.4.7">7.4.7 文档关联查询</h4>        <p></p>        <ul>            <li>mongoose大于3.2以上的版本推荐使用mongodb中的聚合管道的$lookup进行管理查询</li>            <li>mongoose自己实现了一个强大的关联查询的方法populate()实现表的关联查询<br/>注意:</li>            <ul>                <li>使用populate()方法需要引用所有用的的Model到同一个文件中</li>                <li>该方法常和exec()方法一起使用,exec()方法相当于then()方法,是前面所有方法执行完后才会执行,传入一个回调函数,第一个参数是错误对象,第二个参数是查询到的文档数组对象</li>                <li>该方法使用时需要在Schema中的要被关联文档替代的属性设置{type: Schema.Types.ObjectId, ref: '要关联的集合'}</li>            </ul>            <p></p>            <p>Model中的用法:Model.populate(path, [select], [model], [match], [options])</p>            <ul>                <li>path:类型为String或Object</li>                <ul>                    <li>String类型的时, 指定要填充的关联字段,要填充多个关联字段可以以空格分隔。</li>                    <li>Object类型的时,就是把 populate 的参数封装到一个对象里。当然也可以是个数组,用于多个文档的关联查找</li>                </ul>                <li>select:类型为Object或String,可选,指定填充document文档中的哪些字段</li>                <ul>                    <li>Object类型的时,格式如:{name: 1, _id: 0},为0表示不填充,为1时表示填充</li>                    <li>String类型的时,格式如:"name -_id",用空格分隔字段,在字段名前加上-表示不填充</li>                </ul>            </ul>            <p></p>            <p>注:详细语法介绍</p>            <ul>                <li>model:类型为Model,可选,指定关联字段的model(所以如果没有在Schema中指定ref也是能进行操作的),如果没有指定就会使用Schema的ref</li>                <li>match:类型为Object,可选,指定附加的查询条件</li>                <li>options:类型为Object,可选,指定附加的其他查询选项,如排序以及条数限制等等</li>            </ul>        </ul>        <div class="codeMirror">            <pre><xmp>var mongoose = require('mongoose');var Schema   = mongoose.Schema;var UserSchema = new Schema({    name  : { type: String, unique: true },    posts : [{ type: Schema.Types.ObjectId, ref: 'Post' }]//关联多个帖子用数组,固定写法    /*    ref是用于指定关联的数据库,在使用populate方法的时候只需要传入要替换的字段,    就能通过该字段属性在Schema中的ref指定的关联文档进行查找,一般该属性传入的是一个ObjectId,    所以类型是ObjectId,通过这种方式就可以通过查找传入的ObjectId的字符串查找到对应的关联文档,    查找到的文档会直接覆盖掉这个属性原来的值,这样达到查找关联的效果    */});var User = mongoose.model('User', UserSchema);var PostSchema = new Schema({    poster   : { type: Schema.Types.ObjectId, ref: 'User' },    comments : [{ type: Schema.Types.ObjectId, ref: 'Comment' }],    title    : String,    content  : String});var Post = mongoose.model('Post', PostSchema);var CommentSchema = new Schema({    post      : { type: Schema.Types.ObjectId, ref: "Post" },    commenter : { type: Schema.Types.ObjectId, ref: 'User' },    content   : String});var Comment = mongoose.model('Comment', CommentSchema);</xmp></pre>        </div>        <p></p>        <div class="codeMirror">            <pre><xmp>//传入数据var user = User.findOne({name:"张三"});var post1 = Post.findOne({title:"第一篇帖子"});var post2 = Post.findOne({title:"第二篇帖子"});user.posts=[post1,post2];//设置一对多的关联//设置关联,可以直接把整个对象关联,会直接将这个对象的ObjectId存入,也可以直接[post1_id,post2_id]post1.poster=user;//设置一对一的关联,因为上面设置的时候不是一个数组,所以只能设置一个,可以直接user_id</xmp></pre>        </div>        <p></p>        <div class="codeMirror">            <pre><xmp>//填充所有 users 的 postsUser.find().populate('posts', 'title', null, {sort: { title: -1 }}).exec(function(err, docs) {    console.log(docs[0].posts[0].title); // post-by-aikin});//填充 user 'luajin'的 postsUser.findOne({name: 'luajin'}).populate({path: 'posts', select: { title: 1 }, options: {sort: { title: -1 }}}).exec(function(err, doc) {    console.log(doc.posts[0].title);  // post-by-luajin});//这里的 populate 方法传入的参数形式不同，其实实现的功能是一样的，只是表示形式不一样。</xmp></pre>        </div>        <p></p>        <div class="codeMirror">            <pre><xmp>Post.findOne({title: 'post-by-aikin'})    .populate('poster comments', '-_id')    .exec(function(err, doc) {        console.log(doc.poster.name);           // aikin        console.log(doc.poster._id);            // undefined        console.log(doc.comments[0].content);  // comment-by-luna        console.log(doc.comments[0]._id);      // undefined    });Post.findOne({title: 'post-by-aikin'})    .populate({path: 'poster comments', select: '-_id'})    .exec(function(err, doc) {        console.log(doc.poster.name);           // aikin        console.log(doc.poster._id);            // undefined        console.log(doc.comments[0].content);  // comment-by-luna        console.log(doc.comments[0]._id);      // undefined    });//上两种填充的方式实现的功能是一样的。就是给 populate 方法的参数不同。//这里要注意，当两个关联的字段同时在一个 path 里面时,select 必须是 document(s)具有的相同字段。//如果想要给单个关联的字段指定 select,可以传入数组的参数。如下：Post.findOne({title: 'post-by-aikin'})    .populate(['poster', 'comments'])    .exec(function(err, doc) {        console.log(doc.poster.name);          // aikin        console.log(doc.comments[0].content);  // comment-by-luna    });Post.findOne({title: 'post-by-aikin'})    .populate([        {path:'poster',   select: '-_id'},        {path:'comments', select: '-content'}    ])    .exec(function(err, doc) {        console.log(doc.poster.name);          // aikin        console.log(doc.poster._id);           // undefined        console.log(doc.comments[0]._id);      // 会打印出对应的 comment id        console.log(doc.comments[0].content);  // undefined    });</xmp></pre>        </div>        <p></p>        <h4 id="s7.4.7.1">7.4.7.1 文档关联高级用法</h4>        <p></p>        <p>使用populate()进行文档关联的时候也可以像聚合管道一样进行高级关联</p>        <p></p>        <p>比如:被关联的类别也可以拿到关联它的关联项,实现一对多的用法</p>        <p></p>        <div class="codeMirror">            <pre><xmp>const Post=mongoose.model("Post",new mongoose.Schema({    title:{        type:String    },    body:{        type:String    },    categories:[{type:mongoose.SchemaTypes.ObjectId,ref:"Category"}]}))const CategorySchema=new mongoose.Schema({    name:{type:String}},{    toJSON:{virtuals:true}//调用toJSON方法时默认会把虚拟字段加上,与express的res.send()配合})//想要获取关联词类别的的posts,需要定义一个虚拟字段//设置虚拟字段CategorySchema.virtul("posts",{//posts是设置的虚拟的属性    ref:"Post",//要关联的集合    localField:"_id",//自身要关联的字段    foreignField:"categories",//对方集合要关联的字段    justOne:false//表示查出来的数据是否只有一条,如果是false返回数组,如果是true返回对象})//要先设置虚拟字段再创建模型const Catagory=mongoose.model("Category",CategorySchema);Category.find().populate("posts").then((err,docs)=>{    console.log(docs);//注意,因为是虚拟字段,在mongoose的机制里默认不会显示,除非加了上面的参数    console.log(docs[0].posts);//但是如果真实的获取会获取到它的信息    console.log(JSON.stringify(posts));    /*    因为设置了参数    {    toJSON:{virtuals:true}    }    所以调用JSON.stringify会有虚拟字段,否则不会有虚拟字段    */        //也可以使用一种更好的方法    docs=docs.lean();//表示将对象转换为纯JSON对象,这样就可以得到虚拟字段中的数据了    console.log(docs);})</xmp></pre>        </div>        <p></p>        <h4 id="s7.4.8">7.4.8 扩展Model方法</h4>        <p></p>        <ul>            <li>静态方法:通过对Schema的statics属性上添加静态方法                <div class="codeMirror">                    <pre><xmp>UserSchema.statics.findById=function(uid,cb){    this.find({"_id":uid},function(err,docs){        cb(err,docs);    })}</xmp></pre>                </div>            </li>            <li>实例方法:通过对Schema的methods属性上添加实例方法                <div class="codeMirror">                    <pre><xmp>UserSchema.methods.print=function(){    console.log("这是一个实例方法");    console.log(this);}</xmp></pre>                </div>            </li>        </ul>        <p></p>        <h3 id="s7.5">7.5 Document方法</h3>        <p></p>        <p>Document和集合中的文档一一对应,Document是Model的实例,通过Model查询到结果都是Document</p>        <p></p>        <ul>            <li>Document.save([options].[fn]),该方法用于将文档保存到数据库</li>            <div class="codeMirror">                <pre><xmp>const candy=new Candy({    name:"candy",    age:18});//只这样是不会保存到数据库的,还需要使用save()方法candy.save(function(err){    if(!err){        conosole.log("保存成功");    }})</xmp></pre>            </div>            <li>Document.update(update,[options],[callback]),该方法用于修改对象,不过不用传入查找方式,直接修改调用该方法的文档</li>            <div class="codeMirror">                <pre><xmp>Candy.findOne({},function(err,doc){    if(!err){        doc.update({$set:{age:20}},function(err){            console.log("修改成功");        });    }})</xmp></pre>            </div>            <li>Document.remove([callback]),该方法用于删除当前文档对象</li>            <li>Document.get(name),该方法用于获取文档中的指定属性,等同于直接文档.属性</li>            <li>Document.set(name.value),该方法用于设置文档中的指定属性值,等同于直接文档.属性=值<br/>注意:使用该方法数据库中的值也不会改变,因为还没有调用save()方法</li>            <li>Document.id,用于获取文档的_id(当然直接使用Document._id也是可以获取到的)</li>            <li>Document.toObject(),该方法可以将一个Document对象转变为普通的对象,转变后不能再使用Document对象的方法,但是其属性能被delete 属性名删除,而且也不能使用Document.id获取_id,但是可以使用Document._id来获取</li>        </ul>        <p></p>        <h3 id="s7.6">7.6 模块化导入数据库</h3>        <p></p>        <ul>            <li>先定义一个模板用来连接mongodb数据库</li>            <div class="codeMirror">                <pre><xmp>//connect.jsconst mongoose=require("mongoose");mongoose.connect("mongodb://数据库的ip地址:端口号/数据库名",{userNewUrlParser:true});//如果端口号是默认端口号(27017)则可以省略不写//可以用作测试mongoose.connection.once("open",function(){    console.log("数据库链接成功");})</xmp></pre>            </div>            <li>定义模板创建需要的模型</li>            <div class="codeMirror">                <pre><xmp>//student.jsconst mongoose=require("mongoose");const Schema=mongoose.Schema;let Student=new Schema({    name:String,    age:Number,    gender:{        type:String,        default:"female"    },    address:String})const StudentModel=mongoose.model("student",Student);module.exports=StudentModel;//导出模型对象</xmp></pre>            </div>            <li>使用模型</li>            <div class="codeMirror">                <pre><xmp>require("./connect.js");//因为不用导出数据,所以可以不赋值const Student=require("./student.js");//测试用Student.find({},function(err,docs){    if(!err){        console.log(docs);    }})</xmp></pre>            </div>        </ul>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/less/"/>
    <url>/CodeNote/2020/10/23/zone/html/less/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title">            <h1>less</h1>        </div>        <p></p>        <div class="list" id="s1">            <h2>1.认识less</h2>            <p></p>            <p>less是一种动态样式语言,属于CSS预处理器的范畴,它拓展了CSS语言,其余的CSS预处理器有sass和stylus等</p>            <p></p>            <p>less增加了变量,MIxin,函数等特性,使CSS更易维护和扩展,less既可以在客户端上运行,也可以借助node.js在服务端运行</p>            <p></p>            <p>less的编译工具</p>            <p></p>            <p>koala官网:www.koala-app.com</p>            <p></p>        </div>        <div class="list" id="s2">            <h2>2. less的引入</h2>            <p></p>            <p>less可以通过多种方式引入具体在http://lesscss.cn/中有详细说明</p>            <p></p>            <p>这里主要说明浏览器端的用法:</p>            <p></p>            <p>在上面的网址中下载less的js文件,然后放入项目中引入,然后在前面引入已经编写的less文件</p>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <title>less引入</title>        <link rel="stylesheet/less" type="text/css" href="css/less初见.less" />        <script src="js/less.min.js"></script><!--引入less的地址-->      </head>      <body>      </body>    </html><!--引入less文件的时候和引入普通外部CSS文件类似,只是需要在rel="stylesheet"后面加上/less表明引入的是less样式--></xmp></pre>            </div>            <p></p>            <p>注意:less在引入的时候js文件一定要写在引入的less文件的后面,这样才能实现less的编译</p>            <p></p>        </div>        <div class="list" id="s3">            <h2>3. less的注释</h2>            <p></p>            <p>less中的注释和CSS一样有两种单行注释//，多行注释/**/</p>            <p></p>            <p>注意:通过编译器转换的时候,以//开头的注释不会被编译到CSS文件中,而已/ /包裹的注释才会被编译在CSS文件中</p>            <p></p>        </div>        <div class="list" id="s4">            <h2>4. less的变量</h2>            <p></p>            <p>less中使用@来申明和使用一个变量</p>            <p></p>            <p>具体用法为:@变量名:属性值</p>            <p></p>            <div class="codeMirror">                <pre><xmp>@pink:pink//在以后的使用中就可以用@pink来代替pink </xmp></pre>            </div>            <p></p>            <ul>                <li>变量作为普通的属性值使用,直接用这个变量:@变量名</li>                <li>变量作为选择器或者属性名来使用,需要在变量两边加上{}:@{变量名}</li>                <li>变量作为url，使用时也需要在两边加上{}:@{url}。（其实就是如果变量是被引号包住的就需要加）</li>                <li>变量的加载会有延迟效果,当整个文件的所有东西被加载完时才会将变量赋值给对应的属性</li>                <li>变量运用的时候会现在自身的作用域里面找到是否定义了该变量,如果定义了就直接用自身作用域中的,如果没有才会在外层逐层寻找,如果在最外层都没有找到对应的变量就会报错</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp>@var:0;    .class{        @var:1;        .brass{            @var:2;            three:@var;            @var:3;        }      one:@var    }    /*        最终的结果为one:1;                three:3;        变量在最后赋完所有值才会赋值给属性,而且这个赋值也是只针对自身的作用域    */</xmp></pre>            </div>        </div>        <p></p>        <div class="list" id="s5">            <h2>5.嵌套规则</h2>            <p></p>            <h3 id="s5.1">5.1 基本嵌套规则</h3>            <p></p>            <div class="codeMirror">                <pre><xmp>.father{    position: relative;    margin: 200px auto;    width: 200px;    height: 200px;    border: 1px solid #000;    .child {      position: absolute;      top: 0;      left: 0;      right: 0;      bottom: 0;      margin: auto;      width: 100px;      height: 100px;      background-color: red;       }  }  /*      通过上方的写法可以分别对父元素和子元素进行样式设置  */</xmp></pre>            </div>            <p></p>            <h3 id="s5.2">5.2 &符号的使用</h3>            <p></p>            <p>&符号能取消默认的嵌套关系的中的空格,从而从父子关系变成兄弟关系,这个兄弟关系是本身拓展出的一些兄弟关系,如伪类选择器等，可以理解为&符号就是这个选择器本身</p>            <p></p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp>.father {     position: relative;     margin: 200px auto;     width: 200px;     height: 200px;     border: 1px solid #000;     .child {       position: absolute;       top: 0;       left: 0;       right: 0;       bottom: 0;       margin: auto;       width: 100px;       height: 100px;       background-color: red;       &:hover {         background-color: pink;       }     }   }   /*       如果在:hover前面没有写&符合,hover的效果就不能起作用   */</xmp></pre>            </div>        </div>        <p></p>        <div class="list" id="s6">            <h2>6.less的混合</h2>            <p></p>            <p>混合就是将一系列属性从一个规则集引入到另外一个规则集的方式</p>            <p></p>            <h3 id="s6.1">6.1 普通混合与不带输出混合</h3>            <p></p>            <p>把样式中共同的代码单独提出来在最上方,单独的用一个类名或ID名来定义(因为在开头用了点号和#号,暂且叫作是类名和ID名),然后在下面输入的时候通过 .类名/ID名;来调用</p>            <p></p>            <p></p>            <p></p>            <p>注意:混合中写样式代码的方式和写普通CSS或less文件是一样的,混合的名字也是可以用选择器的方式的,只不过所有混合的名字都必须是看起来相识类名或者ID名,下面先统一说成是类名</p>            <p></p>            <p></p>            <p></p>            <p>普通混合定义的类名是会被编译到CSS文件中的,如果不想被编译到CSS文件中,需要使用不带输出的混合在名字后面再加上()</p>            <p></p>            <div class="codeMirror">                <pre><xmp>/*这是不混合的写法*/.father {  position: relative;  margin: 200px auto;  width: 200px;  height: 200px;  border: 1px solid #000;  .child1 {    position: absolute;    top: 0;    left: 0;    right: 0;    bottom: 0;    margin: auto;    width: 100px;    height: 100px;    background-color: red;  }  .child2 {    position: absolute;    top: 0;    left: 0;    right: 0;    bottom: 0;    margin: auto;    width: 100px;    height: 100px;    background-color: red;  }} </xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>/*这是混合后的写法*/.mix(){//不加()是普通混合,会被编译到CSS文件中    position: absolute;    top: 0;    left: 0;    right: 0;    bottom: 0;    margin: auto;    width: 100px;    height: 100px;    background-color: red;}.father {  position: relative;  margin: 200px auto;  width: 200px;  height: 200px;  border: 1px solid #000;  .child1 {    .mix;//调用混合样式  }  .child2 {   .mix;  }}</xmp></pre>            </div>            <p></p>            <h3 id="s6.2">6.2 带参数的混合</h3>            <p></p>            <p>混合的参数也是通过变量使用的形式来定义的,混合中加参数的用法和函数类似,为了方便记忆可以理解为函数,但是不是函数,同时这个参数还可以有默认的值,默认值的定义也是和变量的定义相同</p>            <p></p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp>/*定义形参*/.mix(@w:100px,@h:100px,@b:pink) {   /*这是定义的默认参数的写法,如果不定义默认的参数就是直接@w,@h,@b*/    position: absolute;  top: 0;  left: 0;  right: 0;  bottom: 0;  margin: auto;  width: @w;  height: @h;  background-color: @b;}.father {  position: relative;  margin: 200px auto;  width: 200px;  height: 200px;  border: 1px solid #000;  .child1 {    .mix(100px, 100px, pink);  }  .child2 {    .mix(200px, 200px, red);  }}</xmp></pre>            </div>            <p></p>            <h3 id="s6.3">6.3 命名参数</h3>            <p></p>            <p>在实参传递给形参值的时候可以不用按照顺序进行传递,而是直接通过参数的指定进行传参,这样就能够实现当只想传递某些参数而不是所有参数的时候参数的值不产生混乱</p>            <p></p>            <p></p>            <p></p>            <p>实参传入命名参数的时候和变量定义的时候是一样的</p>            <p></p>            <div class="codeMirror">                <pre><xmp>.father {    position: relative;    margin: 200px auto;    width: 200px;    height: 200px;    border: 1px solid #000;    .child1 {      .mix(100px, 100px, pink);    }    .child2 {      .mix(@b:red);/*直接通过命名参数传递*/    }  }</xmp></pre>            </div>            <h3 id="s6.4">6.4 匹配模式</h3>            <p></p>            <p>用一些专门的标识符放在形参的首位用做匹配,注意这个是标识符不用@符号,当使用的时候会根据传入的第一个参数,匹配到那个,就使用哪一个样式</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp>/* 很像函数重构的写法 */.float(l,@w){    float:left    width:@w}.float(r,@w){    float:right    width:@w}.box1{        height: 200px;        background: green;           .float(l,200px);    }.box2{        width: 300px;        height: 200px;        background: green;        .float(r,200px);    }/*匹配模式相当于if从句,当匹配到哪个正确的时候就会使用哪一个样式*/</xmp></pre>            </div>            <h3 id="s6.5">6.5 arguments变量</h3>            <p></p>            <p>arguments相当于是类中所有实参的集合,其作用和js中的arguments类似</p>            <p></p>            <p>这个变量是less已经设置了的,可以直接调用它来使用,调用它的时候它包含了所有传入的实参,同时每个实参是通过空格隔开的</p>            <p></p>            <div class="codeMirror">                <pre><xmp>.border(@size,@style,@color){    border:@arguments;}div{     width:200px;     height:200px;       .border(1px,solid,#000);}</xmp></pre>            </div>            <p></p>            <p>注意:和js中不一样的是这个属性虽然保留着所有实参但是在命名类的时候还是需要写入对应的形参,不然会出现报错</p>        </div>        <p></p>        <div class="list" id="s7">            <h2>7.less的运算</h2>            <p></p>            <p>在less中可以进行加减乘除的运算</p>            <p></p>            <p>注意:在less的计算中计算的双方只需要一方带单位,最后再计算的时候单位会保留下来加在新值的后面</p>            <p></p>            <div class="codeMirror">                <pre><xmp>.box{    widht:(100+100px)}</xmp></pre>            </div>        </div>        <p></p>        <div class="list" id="s8">            <h2>8.less的继承</h2>            <p></p>            <p>less的继承性能上高于less的混合,但是灵活性弱于混合,继承不支持参数的形式,同时后面也不加(),继承的类是需要被编译到CSS文件中的</p>            <p></p>            <p></p>            <p>less的继承用关键词&:extend()函数来实现,下面是一种用法</p>            <p></p>            <div class="codeMirror">                <pre><xmp>.center {    position: absolute;    top: 0;    left: 0;    right: 0;    bottom: 0;    margin: auto;  }    .father {    position: relative;    margin: 200px auto;    width: 200px;    height: 200px;    border: 1px solid #000;    .child {      &:extend(.center);      &:nth-child(1) {        width: 100px;        height: 100px;        background-color: pink;      }      &:nth-child(2) {        width: 200px;        height: 200px;        background-color: red;      }    }  }  /*      上面的.child通过继承效果能够得到.center里面的样式      转换为CSS样式如下  */  .center,  .father .child {    position: absolute;    top: 0;    left: 0;    right: 0;    bottom: 0;    margin: auto;  }  .father {    position: relative;    margin: 200px auto;    width: 200px;    height: 200px;    border: 1px solid #000;  }  .father .child:nth-child(1) {    width: 100px;    height: 100px;    background-color: pink;  }  .father .child:nth-child(2) {    width: 200px;    height: 200px;    background-color: red;  }  /*      实质上继承是让两个选择器之间通过并集选择器把公共的代码合并起来  */</xmp></pre>            </div>            <p></p>            <p>注意:继承如果只是传入了一个需要被继承的参数到extend函数里面,只会接受这一个选择器,与它相关的兄弟选择器如:hover等是不会继承的,如果想要继承所有,需要在后面加上:空格all</p>            <p></p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp>.center {    position: absolute;    top: 0;    left: 0;    right: 0;    bottom: 0;    margin: auto;  }  .center:hover{      background:black !important;/*因为权重不够,就这样写了*/  }    .father {    position: relative;    margin: 200px auto;    width: 200px;    height: 200px;    border: 1px solid #000;    .child {      &:extend(.center all);      &:nth-child(1) {        width: 100px;        height: 100px;        background-color: pink;      }      &:nth-child(2) {        width: 200px;        height: 200px;        background-color: red;      }    }  }  /*      最终.child能继承到:hover中的样式  */</xmp></pre>            </div>        </div>        <p></p>        <div class="list" id="s9">            <h2>9.less的避免编译</h2>            <p></p>            <p>在less中如果想要一些值不被运算想要原封不动的变成CSS文件,可以用~"值"的方式直接将值原封传递给CSS文件</p>            <p></p>            <div class="codeMirror">                <pre><xmp>*{    margin:~"calc(100px + 100)";//calc()是CSS中本来就有的计算形式的函数} </xmp></pre>            </div>        </div>        <p></p>        <div class="list" id="s10">            <h2>10.less的导入</h2>            <p></p>            <p>在less中使用@import关键字能够将需要的文件中的代码导入到当前的less文件中</p>            <p></p>            <ul>                <li>导入less文件可一直接导入                    <div class="codeMirror">                        <pre><xmp>@import "a.less"</xmp></pre>                    </div>                </li>                <li>导入CSS文件时需要申明这是CSS文件                    <div class="codeMirror">                        <pre><xmp>@import (CSS) "b.css"</xmp></pre>                    </div>                </li>            </ul>        </div>        <div class="list" id="s11">            <h2>11.条件语句</h2>            <p></p>            <p>less没有if / else 但是less具有一个when，and，not与","语法。</p>            <p></p>            <div class="codeMirror">                <pre><xmp>/* Less */#card{    // and 运算符 ，相当于 与运算 &&，必须条件全部符合才会执行    .border(@width,@color,@style) when (@width>100px) and(@color=#999){        border:@style @color @width;    }    // not 运算符，相当于 非运算 !，条件为 不符合才会执行    .background(@color) when not (@color>=#222){        background:@color;    }    // , 逗号分隔符：相当于 或运算 ||，只要有一个符合条件就会执行    .font(@size:20px) when (@size>50px) , (@size<100px){        font-size: @size;    }}#main{    #card>.border(200px,#999,solid);    #card .background(#111);    #card > .font(40px);}/* 生成后的 CSS */#main{    border:solid #999 200px;    background:#111;    font-size:40px;}</xmp></pre>            </div>            <p></p>            <h3 id="s11.1">11.1 条件运算符</h3>            <p></p>            <p>比较运算符：>、>=、 = 、&lt;= 、&lt;</p>            <p></p>            <p>注意：</p>            <p></p>            <ul>                <li>=代表是等于</li>                <li>less中有布尔值true和false，除去关键字true以外的值其他都会被默认为false</li>            </ul>        </div>        <p></p>        <div class="list" id="s12">            <h2>12.循环语句</h2>            <p></p>            <p>less并没有提供一个for等循环的方法但是可以使用递归的方法实现</p>            <p></p>            <div class="codeMirror">                <pre><xmp>/* Less */.generate-columns(4);.generate-columns(@n, @i: 1) when (@i =< @n) {    .column-@{i} {        width: (@i * 100% / @n);    }    .generate-columns(@n, (@i + 1));}/* 生成后的 CSS */.column-1 {    width: 25%;}.column-2 {    width: 50%;}.column-3 {    width: 75%;}.column-4 {    width: 100%;}</xmp></pre>            </div>            <p></p>            <p>案例：less循环输出类名</p>            <p></p>            <p>目标输出</p>            <p></p>            <div class="codeMirror">                <pre><xmp>.a{    background: url("./resource/a.png") top/100% no-repeat;}.b{  background: url("./resource/b.png") top/100% no-repeat;}.c{  background: url("./resource/c.png") top/100% no-repeat;}</xmp></pre>            </div>            <p></p>            <p>实现思路</p>            <p></p>            <ul>                <li>由于形式上面很类似，所以先定义一个模板函数。</li>                <li>定义一个less列表，把需要的类名都写上。</li>                <li>循环遍历列表，调用函数。</li>            </ul>            <p></p>            <p>实现步骤</p>            <p></p>            <ol>                <li>定义函数                    <div class="codeMirror">                        <pre><xmp>.backgroundcard(@className,@pngName){    .@{className}{        background: url("./resource/@{pngName}.png") top/100% no-repeat;    }}</xmp></pre>                    </div>                </li>                <li>定义一个数组                    <div class="codeMirror">                        <pre>xmp>@bgcardList:a,b,c,d,e,f,g;</xmp></pre>                    </div>                </li>                <li>循环遍历                    <div class="codeMirror">                        <pre><xmp>.loop(@i) when (@i < length(@bgcardList)+1){    .backgroundcard(extract(@bgcardList, @i),extract(@bgcardList, @i));    .loop(@i+1);    }    .loop(1);</xmp></pre>                    </div>                </li>            </ol>            <p></p>            <p>语法</p>            <p></p>            <div class="codeMirror">                <pre><xmp>+ 列表函数    - 获取列表的长度  length(@bgcardList)  //7    - 获取列表元素  extract(@bgcardList, 3)  //c+ 循环函数    - loop定义循环次数，when条件判断，符合进入函数，不符合不进入函数。之后次数+1，形成循环。    - loop函数调用，直接传值1。</xmp></pre>            </div>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/js/"/>
    <url>/CodeNote/2020/10/23/zone/html/js/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div>        <div class="main">            <div class="title">                <h1>JS</h1>            </div>            <p></p>            <div class="list" id="s1">                <h2>1.认识JS</h2>                <p></p>                <p>js的三大组成部分:</p>                <p></p>                <ul>                    <li>ECMAScript:js语法的基础,定义了js的基本语法</li>                    <li>BOM:提供了操作浏览器这个软件的一些方法</li>                    <li>DOM:提供了操作标签元素的一些方法</li>                </ul>                <p>js的两个阶段</p>                <p></p>                <ul>                    <li>编译期:对代码进行静态分析,找到声明的变量和函数,检查语法是否符合规范</li>                    <li>执行期:运行js代码</li>                </ul>                <p></p>                <h3 id="s1.1">1.1 如何在用js书写</h3>                <p></p>                <p>通过js可以实现三种书写形式</p>                <p></p>                <ul>                    <li>document.write(),这种形式是直接在页面中书写值,会把传入的值当作字符串传递在页面中,可以直观在页面看到</li>                    <li>console.log(),这种形式是在控制台中打印值,在页面中看不到,必须通过F12查看控制台才能看见</li>                    <li>alert(),这种形式是在打开页面时生成弹窗效果,这种方式也是最直观的,因为很容易被关注,但是只能在页面出现一次,不能一直存在</li>                </ul>                <p></p>                <h3 id="s1.2">1.2 三种提示框</h3>                <p></p>                <ul>                    <li>alert()警告框,用法如上</li>                    <li>confirm()确认框,向其中传入参数代表要用户确认的内容,有确认和取消两个选项,如果用户选择确认则返回true，选择取消则返回false,可以用一个变量来接收返回值进行js判断</li>                    <li>prompt()提示框,传入的参数作为提示的内容,而用户可以在提示框中输入内容,返回值为用户输入结果转换的字符串，可以用一个变量接收<br/>注意:当想用两个提示框的返回值进行比较时,相当于比较的两个字符串,所以是用的Unicode编码进行比较,如果想比较的是两个数值,则需要在接收返回值时做强制类型转换</li>                </ul>                <div class="codeMirror">                    <pre><xmp>var a=+prompt("");//+号强制转换返回值为number类型</xmp></pre>                </div>            </div>            <p></p>            <div class="list" id="s2">                <h2>2.标识符及数据类型</h2>                <p></p>                <h3 id="s2.1">2.1 标识符</h3>                <p></p>                <ul>                    <li>标识符可以含有字母，数字，,$等;</li>                    <li>标识符不能以数字开头；</li>                    <li>标识符不能是JS中的关键字或保留字；</li>                    <li>标识符一般采用驼峰命名法：首字母小写，每个单词的开头字母大写，其余字母小写</li>                    <li>标识符就是JS中的变量(ES6有了常量的概念),变量使用前必须要先定义</li>                    <li>有3种命名符来命名表示符</li>                    <ul>                        <li>var，ES6之前用的命名符,但是作用域是函数作用域,并且支持在当前作用域中进行重复命名,有很大隐患</li>                        <li>let，ES6新增命名变量方法,作用域和其他语言的作用域一样都在块级作用域中,ES6推荐使用</li>                        <li>const,ES6新增的常量命名法,用这个命名符来命名的标识符为常量,只能用不能修改值,修改值就会报错,推荐在某一个量只用一次的时候用这个命名符<br/>>注意:用const声明的常量不是不能赋值,而是不能通过=进行二次赋值,在不改变原来常量结构的情况下可以改变这个常量的属性值</li>                    </ul>                </ul>                <p></p>                <h3 id="s2.2">2.2 数据类型</h3>                <p></p>                <h4 id="s2.2.1">2.2.1 六大数据类型</h4>                <p></p>                <p>注：ES6新增为7种,多了一种symbol符号的数据类型用作私有变量的使用</p>                <p></p>                <p>JS的数据类型分为5大基本数据类型和一个复杂数据类型object</p>                <ul>                    <li>字符串string</li>                    <ul>                        <li>字符串可以用""(单引号)或者''(双引号)或者``(反引号:ES6支持)</li>                        <li>单双引号没有区别，但是不要混合用</li>                        <li>在字符串中要使用js的变量有两种写法</li>                        <ul>                            <li>ES5支持的用字符串拼接的方法</li>                            <li>ES6中支持的必须用``(反引号)才支持的${变量名}的写法<br/>用``写的字符串又被称作模板字符串,能够更轻松的在字符串中插入变量</li>                        </ul>                        <li>当需要用一些特殊符号表示时，可以在特殊符号前加一个\和转义字符的用法基本相似比如用\ "表示" \ \ 表示 \</li>                    </ul>                    <li>数值number</li>                    <ul>                        <li>JS中可以表示数值的最大值Number.MAX_VALUE</li>                        <li>如果超过了最大值,就会返回一个Infinity意为无穷,此时这个无穷是正无穷,而-Infinity为负无穷</li>                        <li>NaN也是一个特殊的数字，意为not a number,可以用很多方法得到这个数 比如:两个字符串相乘返回NaN                        </li>                        <li>Number.MIN_VALUE为最小值,但是是0以上的最小值,并不是负数</li>                        <li>JS中的整数运算可以基本保证精确，浮点运算得到的结果不够精确</li>                    </ul>                    <li>布尔值boolean<br/>该类型只有两个值:true(正确),false(错误)</li>                    <li>null<br/>null的值就是null，专门用来表示空对象</li>                    <li>undefined</li>                    <ul>                        <li>undefined的类型只有一个,就是undefined,当声明一个变量,却不给它赋值时,它的值就是undefined</li>                        <li>使用typeof来检验undefined也会返回undefined</li>                    </ul>                    <li>object<br/>这个类型的值最多,应为所有事物都可以看做是对象</li>                </ul>                <p></p>                <h3 id="s2.2.2">2.2.2 强制类型转换</h3>                <p></p>                <ul>                    <li>将其他数据类型转换为String</li>                    <p></p>                    <p>1.调用被转换数据类型的toString()方法</p>                    <p></p>                    <p>注:</p>                    <p>1.该方法不能影响原来变量，而是有一个返回值</p>                    <p>2.null和undefined这两个值没有toString()方法，如果调用会报错</p>                    <div class="codeMirror">                        <pre><xmp>var a=123;a=a.toString();</xmp></pre>                    </div>                    <p></p>                    <p>原型prototype后说明toString()方法</p>                    <p>当我们直接在页面中打印一个对象时，实际上是输出对象的toString()方法的返回值,所以直接打印一个对象和打印这个对象用toString后的值是一样的,如果我们希望在输出对象时不输出[Object Object],可以为对象的原型添加一个toString()方法来改变输出的值,所以可以在里面写入自己想要的提示(直接只写return就可以),如果用的构造函数的方法最好加上this</p>                    <p></p>                    <p></p>                    <p>2.调用String()函数</p>                    <p></p>                    <p>使用String()函数做强制转换时，实际对于Number和Boolen等调用toString()方法,但是对于null和undefined会直接转换为"null"和"undefined"</p>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>var a=null; a=String(a);</xmp></pre>                    </div>                    <li>将其他数据类型转换Number<br/>1.使用Number()函数</li>                    <ul>                        <li>字符串转换为数字</li>                        <ul>                            <li>如果是纯数字字符串，则直接转化为数字</li>                            <li>如果字符串中有非数字字符，则返回NaN,只要有就会</li>                            <li>如果是一个空串或者一个全是空格的字符串则会返回0<br/>如：</li>                            <div class="codeMirror">                                <pre><xmp>var a="123";a=Number(a);//会返回123var b="abc"b=Number(b);//会返回NaN</xmp></pre>                            </div>                        </ul>                        <li>布尔值转换为数字<br/>true为1,false为0</li>                        <li>null转化为数字为0</li>                        <li>undefined转化为数字为NaN</li>                    </ul>                    <p>使用parseInt()和parseFloat()函数</p>                    <p>注:该方法在ES6已经移植到Number对象下,作为Number的方法使用,与全局时的行为一样</p>                    <p>该方法可以取出字符串的有效数字内容,从头开始取,parseInt是只要遇到非数字就会立刻结束,而parseFloat允许接收到一个小数点,遇到其他的非数字或者第二个小数点时会停止,想要把a="123px"中的123取出来的时候用这种方法才能达到效果</p>                    <p></p>                    <p></p>                    <p>将一个小数转换为整数可以对它使用parseInt()函数</p>                    <p></p>                    <p>注意:</p>                    <p></p>                    <ul>                        <li>这个方法最好专门对字符串用 如果对非String用回先把它转换为String再进行操作<br/>如：如果是布尔值等会转换为"true"在这个字符串再进行转换，这样会返回NaN</li>                        <li>这个方法现在是可以直接作为window的方法调用,所以可以事件省略,但是ES6规定必须要通过Number内建函数来调用,所以最好还是通过Number对象调用                            <div class="codeMirror">                                <pre><xmp>var a="1.23px"console.log(Number.parseFloat(a));//1.23</xmp></pre>                            </div>                        </li>                        <p>对数值及parseInt函数实现进制转换的补充:</p>                        <li>在JS表达16进制数字，需要以0(零)x开头 。如:a=0x10,输出的时候得到a=16 任何用上方这种语法写的数字输出的时候都会转换为16进制的数字                        </li>                        <li>需要表示8进制的数字需要以0开头,用法如上</li>                        <li>2进制开头用0b表示(但不是所有浏览器都支持)</li>                        <li>实际上parseInt这个函数可以接收两个参数,第一个是要转换的字符串,第二个是需要转换的进制<br/>注意:把 a="070"转化为整数,a=parseInt(a)再输出有些浏览器会当成8进制，有些浏览器会省略掉前面的0直接变为10进制，如果想所有的浏览器一样，可以a=parseInt(a,10)，添加第二个参数，来指定数字的进制</li>                    </ul>                    <p></p>                    <li>将其他的数据类型转换为布尔值<br/>使用Boolean()函数</li>                    <p></p>                    <ul>                        <li>数字转换为布尔值，除了0和NaN都是true</li>                        <li>字符串转换为布尔值，除了空串都是true</li>                        <li>null转换为布尔值，false</li>                        <li>undefined转换为布尔值，false</li>                        <li>对象object也会转换为true</li>                    </ul>                    <p>六大假值:0 NaN undefined null "" false</p>                </ul>                <p></p>                <h4 id="s2.2.3">2.2.3 Symbol</h4>                <p></p>                <h5 id="s">1.用法</h5>                <p></p>                <p>Symbol实际上是ES6引入的一种原始数据类型,Symbol引入出来的基础就是为了保存私有属性名,确保属性名发生冲突,当引入一个别人创建的对象时,如果不清楚这个对象有哪些属性,但是又想要为这个对象添加一个属性时,这时两者如果有相同的属性名就会发生属性名的冲突问题,为了避免这种问题,所以引入了Symbol来创建一个独一无二的值</p>                <p></p>                <p></p>                <div class="codeMirror">                    <pre><code>//Symbol类型的值不能字面量创建,而是通过Symbol()函数来创建var sym=Symbol();console.log(sym);//Symbol();console.log(typeof sym);//symbol//现在当使用sym来做属性名时就不会与其他的属性名发生冲突</code></pre>                </div>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>Symbo()函数不是一个构造函数,不能用new操作符。所以Symbol类型的值也不是一个对象,不能添加任何属性,它只是一个类似于字符串的数据类型,如果在声明一个Symbol类型的值前面加上new就会报错</li>                    <li>Symbol()类型的值不能够进行计算,包括Symbol类型的任意数据类型都不可以,一旦进行计算就会报错</li>                    <li>Symbol类型的值可以转换为字符串和布尔值,但是不能转换为数值,否则会报错,并且转换成布尔值时永远都是true,不管内部是什么参数                        <div class="codeMirror">                            <pre><code>var sym=Symbol();var sym1=Symbol(false);                                        console.log(String(sym));"Symbol()"console.log(String(sym1));"Symbol(false)"console.log(Boolean(sym));//trueconsole.log(Boolean(sym1));//true</code></pre>                        </div>                    </li>                    <li>因为是通过一个变量来接收的Symbol值,所以在使用Symbol值作为属性名时,获取对应的属性不能用点操作符,如果用点操作符实际上时获取一个字符串,而不是Symbol值。同时在对象内部用该变量创建属性名时也要要[]括起来,否则该属性名依然只是一个字符串,而不是用的Symbol变量                        <div class="codeMirror">                            <pre><xmp>//Symbol值作为属性名时有多种用法    var name=Symbol();    var a=&#123; &#125;;    //第一种    a[name]="孙悟空";        //第二种    a=&#123;        [name]:"孙悟空";      &#125;        //第三种    Object.defineProperty(a,name,&#123;value:"孙悟空"&#125;);//这里的name是变量        //输出    console.log(a.name);//undefined    console.log(a[name]);//孙悟空    console.log(a["name"]);//undefined </xmp></pre>                        </div>                    </li>                    <li>当遍历对象的属性值时,无法用for...in和for...of语句遍历到Symbol值的属性,也无法通过Object.keys() 、Object.getOwnPropertyNames()等函数来获取。但是可以通过使用Object.getOwnPropertySymbols()函数获取一个对象上的Symbol属性名,也可以使用Reflect.ownKeys()函数返回所有类型的属性名,包括常规的属性名和Symbol属性名                        <div class="codeMirror">                            <pre><xmp>var sym1=Symbol("sym1");var sym2=Symbol("sym2");var a=&#123;    [sym1]:"sym1",    [sym2]:"sym2",    hello:"hello"&#125;console.log(Object.getOwnPropertyNames(a));//[Symbol(sym1),Symbol(sym2)]console.log(Object.keys(a));//["hello",Symbol(sym1),Symbol(sym2)]</xmp></pre>                        </div>                        <p></p>                        <p>注:正因为Symbol值作为对象的属性值无法被遍历到的这一特性,可以对对象定义一些非私有的但是又希望只有内部可用的方法</p>                    </li>                    </li>                </ul>                <p></p>                <h5>2.Symbo()的参数</h5>                <ul>                    <li>字符串作参数<br/>在创建一个symbol类型的值的时候,如果不传入任何参数,在调用变量的时候不好进行去区分,打印的值全都是Symbol(),传入一个字符串作为参数,可以对Symbol的值进行描述,方便我们区分不同的Symbo值                        <div class="codeMirror">                            <pre><xmp>var sym1=Symbol("sym1");var sym2=Symbol("sym2");var sym3=Symbol("sym1");console.log(sym1);//Symbol(sym1)console.log(sym2);//Symbol(sym2)console.log(sym1===sym3);//false/*1.给Symbol()函数传入参数后可以在控制台输出的时候区分到底是哪一个值2.Symbol()函数中传入的参数只是用来对当前的Symbol变量的描述,而没有其他意思,相同参数的      Symbol()函数的返回值是不同的*/</xmp></pre>                        </div>                    </li>                    <li>其他类型作参数<br/>当用其它类型的值作为参数传入到Symbol()函数中时,会自动将该参数转换为字符串类型,但是注意当传入的值为undefined的时候此时Symbol()函数中相当于没有传入参数,所以返回的依然是Symbol()</li>                </ul>                <h5>3.Symbol.for与Symbol.keyFor函数</h5>                <p></p>                <ul>                    <li>Symbol.for()也函数可以用来生成Symbol值,但该函数有一个特殊的用处,该函数创建的Symbol值可以通过内部的参数重复使用一个Symbol值<br/>Symbol.for()函数接收一个字符串作为参数,先搜索有没有以该参数为名称的Symbol值,如果有直接返回这个Symbol值,如果没有就新建一个以给字符串为名称的Symbol值                        <div class="codeMirror">                            <pre><xmp>var sym=Symbol("sym1");var sym1=Symbol.for("sym1");var sym2=Symbol.for("sym2");var sym3=Symbol.for("sym1");console.log(sym===sym1);//fasle,因为用Symbol()创建的Symbol值没有计入Symbol值的登记中console.log(sym1===sym2);//false,因为参数标识不一样,重新创建了Symbol值console.log(sym1===sym3);//true,参数标识一样,相当于先前是sym3=sym1</xmp></pre>                        </div>                    </li>                    <li>Symbol.keyFor()函数用来查找一个Symbol值的登记信息(这个登记信息就是创建Symbol值时在函数中传入的参数),因为Symbol()函数创建的Symbol值没有登记机制,所以会返回undefined,而Symbol.for()函数会将生成的Symbol值的信息记录在全局环境中,所以Symbol.keyFor()函数可以查找到Symbol.for()函数创建的Symbol值，该函数的返回值是字符串                        <div class="codeMirror">                            <pre><xmp>var sym1=Symbol.for("sym1");console.log(Symbol.keyFor(sym1));//"sym1"console.log(Symbol.keyFor(sym1)==="sym1");//true</xmp></pre>                        </div>                    </li>                </ul>                <h3 id="s2.3">2.3 解构赋值</h3>                <p></p>                <p>解构赋值为ES6的语法,ES6中,允许按照一定模式,从数数组和对象中提取值,对变量进行赋值,这种行为被称为解构</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>//右边为数组var [a, b, c] = [1, 2, 3];console.log(a, b, c);//1,2,3//右边为对象var &#123;x:x,y:y,z:z&#125; = &#123;x: 1, y: 2, z: 3&#125;;console.log(x, y, z);//1,2,3var &#123;x,y,z&#125; = &#123;x: 1, y: 2, z: 3&#125;;console.log(x, y, z);//1,2,3/*注意:1.当右边为对象时,对象中的属性也是模式的一部分,所以必须也要在左边写上相同的属性名2.当左边的属性名和属性值的变量时相同时,可以只写属性值,这个属性值也是要用的变量名*///模式不一致var arr=[1,2,[3]];var [a,b,c]=arr;console.log(a,b,c);//1,2,[3]//模式一致var [a,b,[c]]=arr;console.log(a,b,c);//1,2,[3]var [json, arr, num, str] = [&#123; a: 1, b: 2 &#125;, [1, 2, 3], 8, 'str']; console.log(json, arr, num, str);//&#123; a: 1, b: 2 &#125;, [1, 2, 3], 8, 'str'</xmp></pre>                </div>                <p></p>                <p>注意:</p>                <ul>                    <li>左右两边模式必须一样(都是数组或对象字面量)</li>                    <li>声明和赋值赋值不能分开，必须在一句话里</li>                </ul>            </div>            <div class="list" id="s3">                <h2>3.运算符</h2>                <p></p>                <p>运算符不会对原来的值进行影响</p>                <p></p>                <p>运算符的运算时按住自身的层级进行顺序运算</p>                <p></p>                <h3 id="s3.1">3.1 JS功能运算符</h3>                <p></p>                <ul>                    <li>typeof,用于鉴定数据类型的时候使用,它会将值得类型以字符串的形式返回                        <div class="codeMirror">                            <pre><xmp>var a=123;var result=typeof a;console.log(result)/*这里会显示number*//*    注意:typeof对null用时会返回object    typeof对函数function用时会返回function,实际上函数也是一个对象    typeof对symbol数据的返回值就是symbol*/</xmp></pre>                        </div>                    </li>                    <li>in,用于检查一个对象中是否含有指定的属性,如果有则返回true,没有则返回false                        <div class="codeMirror">                            <pre><xmp>var obj=new Object();console.log("test2" in obj); //这里显示false,因为obj中没有这个属性//属性名实际上是字符串，所以要加""</xmp></pre>                        </div>                    </li>                    <li>instanceof,用于确定一个对象是否在另一个对象的原型链上,也就是一个对象是否属于另一个类对象的实例                        <div class="codeMirror">                            <pre><xmp>//可以使用instanceof可以检验一个对象是否是一个类的实例function Person(name)&#123;this.name=name&#125;  var per= new Person("孙悟空");  console.log(per instanceof Person);//如果per是Person类的实例返回true，否则返回false    console.log(per instanceof Object);//所有的对象都是Object的后代，所有任何对象和Object与instanceof检验都会返回true</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <h3 id="s3.2">3.2 算术运算符</h3>                <p></p>                <p>JS中的算术运算符和其他语言一样有+ - / %等</p>                <p></p>                <p>注意:</p>                <ul>                    <li>在用算术运算符进行运算的时候如果进行运算的两边有非number类型的,则会先转换为number类型,再进行运算,如:a=true a=-a会将a转化为number,所以可以利用这个特性用a=+a将一个其他类型的数很快的转化number类型</li>                    <li>在ES6中新增了三点(扩展)运算符(...)和指数运算符(**)等</li>                </ul>                <p>+的特殊用法:如果对两个字符串进行加法运算，则会做拼串并返回,任何值和字符串做加法运算，都会先转换为字符串，然后再拼串</p>                <p></p>                <p>注:可以利用+的特殊性这一特点将任意数据类型转换为String，将任意数据类型+一个""空串转换为String，实质上也是调用的String函数</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var result=1+"2"+3//结果会是字符串123var result=1++"2"+3//结果会是数字6，++"2"实际是是先计算的+"2"把字符2转换为数字2</xmp></pre>                </div>                <p></p>                <p>自增自减</p>                <p></p>                <p>自增有两种:a++和++a,两种方法用完a都马上+1<br/>自减和自增没有差别</p>                <p></p>                <p>注意:</p>                <p></p>                <p>a++和++a不同,a++是一个变量，而++a是一个表达式<br/>a++等于原值,++a等于+1后的值，调用一次就直接用表达式进行运算</p>                <p></p>                <p></p>                <h3 id="s3.3">3.3 逻辑运算符</h3>                <p></p>                <p>逻辑运算符有:! && ||三种</p>                <ul>                    <li>!(非运算符)对一个数进行非运算，如果不是布尔值会被转换为布尔值(这种运算方法只适合JS)<br/>可以利用这一特性为任意数据类型取两次反将其转换为布尔值，原理与Boolean()一样                        <div class="codeMirror">                            <pre><xmp>var a="hello"a=!!a//true</xmp></pre>                        </div>                    </li>                    <li>&&(与运算符)如果第一个值就是false就不会去看第二个值，第一个值是true会检查第二个值</li>                    <li>||(或运算符)如果第一个值是true就不会检查第二个值,直接返回第一个值                        <div class="codeMirror">                            <pre><xmp>true||alert("s")//不会执行弹窗false||alert("s")//执行弹窗</xmp></pre>                        </div>                    </li>                </ul>                <p>对于非布尔值进行运算，会先转换为布尔值，再进行运算，并返回原值，不会返回布尔值</p>                <p></p>                <p>总结:</p>                <p></p>                <p>&&运算如果第一个值为true则直接返回第一个值，如果第一个值是false，则直接返回第一个值<br/>||运算如果第一个值为true则直接返回第一个值，如果第一个值是false则直接返回第二个值</p>                <p></p>                <h3 id="s3.4">3.4 关系运算符</h3>                <p></p>                <p>通过关系运算符比较两个值之间的大小关系,关系成立则返回true,关系不成立则返回false</p>                <p></p>                <p>关系运算符有:> &lt; >= &gt;= 等</p>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>关系运算符比较的一般都是number类型的值,如果不是number类型会转换为number类型</li>                    <li>任何值和NaN做比较都会返回false</li>                    <li>如果符合两测的值都是字符串时(如果有一方不是字符串就是全部转换为number类型再比较)，不会将其转换为数字进行比较，而会分别比较Unicode编码(UTF-8)，和C语言中的strcmp一样。所以，在比较两个字符串型的数字时，一定要转型，至少在其中一个前面加上+</li>                </ul>                <p></p>                <p>Unicode编码</p>                <p></p>                <p>想输出一个Unicode编码需要在前面加上\和u 如\u1C00,在JS控制台中输入的编码是16进制数如果要在网页中输入为&#+编码;这里的编码是10进制数，所以会和在JS控制台里的输入不一样所以在需要用到unicode编码是要清楚写在网页的代码和写在控制台代码的区别</p>                <p></p>                <p></p>                <h3 id="s3.5">3.5 相等运算符</h3>                <p></p>                <p>相等运算符通过判断两边是否相等来返回值,如果符合返回true,不符合返回flase</p>                <p></p>                <p>相等运算符有== === != !===等</p>                <p></p>                <ul>                    <li>当==和!==两边类型不同时会进行类型转换再做比较，大部分情况都是转换为数字                        <div class="codeMirror">                            <pre><xmp>console.log(true=="1")//将两边都转换为number,返回true/*特殊情况*/console.log(null==0)//按理说null转换为number应该是0结果是true，但是这个返回falseconsole.log(unfined==null)//undefined衍生于null，所以这两个值做相等判断时会返回true</xmp></pre>                        </div>                    </li>                    <li>当===(全等)和!==(不全等)两边类型不同时不会进行自动类型转换,直接返回false</li>                </ul>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>字符串相等依然是比较的unicode编码</li>                    <li>NaN不和任何值相等，包括它本身,所以不能通过相等运算符来判断一个值是否是NaN,可以通过isNaN()函数来判断                        <div class="codeMirror">                            <pre><xmp>var a="abc";var b=NaN;console.log(isNaN(a));//true,先强制转换为数值类型console.log(isNaN(b));//返回true,如果b不是NaN返回false</xmp></pre>                        </div>                    </li>                    <p></p>                    <p>注意:</p>                    <ul>                        <li>在ES5中该方法是全局变量的方法,而在ES6中该方法是Number内置对象的方法,需要通过Number.isNaN()来调用</li>                        <li>通过Number.isNaN()来调用该方法时不会强制转换类型,如果是非数值类型直接返回false                            <div class="codeMirror">                                <pre><xmp>var a="abc";console.log(Number.isNaN(a));//false</xmp></pre>                            </div>                        </li>                    </ul>                    <p></p>                    <p>注:在ES6中引入了一个Object.is()方法作为判断,该方法能对NaN进行相等判断</p>                    <p></p>                    <p>Object.is()方法可以接收两个参数,这两个参数为进行比较的两个值，该函数不会进行强制类型转换,相当于===与全等(===)的区别</p>                    <p></p>                    <p></p>                    <li>+0不能用-0</li>                    <li>NaN等于自身</li>                </ul>                <div class="codeMirror">                    <pre><xmp>console.log(Object.is(NaN,NaN));//trueconsole.log(Object.is(+0,-0));//falseconsole.log(Object.is(123,"abc"));//falseconsole.log(Object.is(123,"123"));//false</xmp></pre>                </div>                <p></p>                <p>拓展:</p>                <p></p>                <ul>                    <li>Number.isFinite()方法用来检测一个数值是否为有限的(finite),该方法不会进行强制类型转换,非数值的类型将直接返回false                        <div class="codeMirror">                            <pre><xmp>console.log(Number.isFinite(1));//trueconsole.log(Number.isFinite(NaN));//falseconsole.log(Number.isFinite(Infinitey));//falseconsole.log(Number.isFinite(-Infinitey));//falseconsole.log(Number.isFinite(false));//falseconsole.log(Number.isFinite(true));//falseconsole.log(Number.isFinite("15"));//falseconsole.log(Number.isFinite(Math.PI));//true，JS里的PI只保留了前几位小数</xmp></pre>                        </div>                    </li>                    <li>Number.isInteger()方法用来判断一个值是否为整数,也不会强制转换类型console.                        <div class="codeMirror">                            <pre><xmp>console.log(Number.isInterger(1));//trueconsole.log(Number.isInterger(1.0));//trueconsole.log(Number.isInterger(1.1));//falseconsole.log(Number.isInterger("1"));//falseconsole.log(Number.isInterger(true));//false</xmp></pre>                        </div>                    </li>                    <p>注意:在JS内部,整数和浮点数时同样的储存方法,如1与1.0是同一个数</p>                </ul>                <p></p>                <h3 id="s3.6">3.6 扩展运算符</h3>                <p></p>                <p>为扩展运算符(ES6新增)，用作展开一些列表式的值(比如数组和JSON对象),会将列表以原本的方式展开</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var arr=[1,2,3];var arr2=[...arr];//arr展开为1,2,3var obj=["a":0,"b":1];var obj2=[...obj]console.log(arr2);//[1,2,3]console.log(obj2);//["a":0,"b":1]</xmp></pre>                </div>                <p></p>                <p>注:其它用法在后面有详细说明</p>                <p></p>                <h3 id="s3.7">3.7 运算符优先级</h3>                <p></p>                <p>js中的运算符优先级是一套规则,该规则在计算表达式时控制运算符执行的顺序,具有较高优先级的运算符先于较低优先级的运算符执行</p>                <p></p>                <p>下表按从最高到最低的优先级列出js运算符,具有相同优先级的运算符按从左至右的顺序求值</p>                <table>                    <tr>                        <td>运算符</td>                        <td>描述</td>                    </tr>                    <tr>                        <td>. [] ()</td>                        <td>字段访问、数组下标、函数调用以及表达式分组</td>                    </tr>                    <tr>                        <td>++ -- - ~ ! delete new typeof void</td>                        <td>一元运算符、返回数据类型、对象创建、未定义值</td>                    </tr>                    <tr>                        <td>* / %</td>                        <td>乘法、除法、取模</td>                    </tr>                    <tr>                        <td>+ - +</td>                        <td>加法、减法、字符串连接</td>                    </tr>                    <tr>                        <td>&lt;&lt; >> >>></td>                        <td>移位</td>                    </tr>                    <tr>                        <td>&lt;&lt;= > >= instanceof</td>                        <td>小于、小于等于、大于、大于等于、instanceof</td>                    </tr>                    <tr>                        <td>== != === !==</td>                        <td>等于、不等于、严格相等、非严格相等</td>                    </tr>                    <tr>                        <td>&</td>                        <td>按位与</td>                    </tr>                    <tr>                        <td>^</td>                        <td>按位异或</td>                    </tr>                    <tr>                        <td>|</td>                        <td>按位或</td>                    </tr>                    <tr>                        <td>&&</td>                        <td>逻辑与</td>                    </tr>                    <tr>                        <td>||</td>                        <td>逻辑或</td>                    </tr>                    <tr>                        <td>?:</td>                        <td>条件</td>                    </tr>                    <tr>                        <td>= oP=</td>                        <td>赋值、运算赋值</td>                    </tr>                    <tr>                        <td>,</td>                        <td>多重求值</td>                    </tr>                </table>            </div>            <div class="list" id="s4">                <h2>4.逻辑语句</h2>                <p></p>                <h3 id="s4.1">4.1 if语句</h3>                <p></p>                <p>if语句对一个属性或者表达式进行判断,里面的数或表达式最后会转换为布尔值，如果为真才执行执行if语句里面的代码</p>                <p></p>                <h4 id="s4.1.1">4.1.1 if</h4>                <p></p>                <div class="codeMirror">                    <pre><xmp>if(true)&#123;console.log(1);    &#125;    //只判断是否为真</xmp></pre>                </div>                <p></p>                <h4 id="s4.1.2">4.1.2 if...else</h4>                <p></p>                <div class="codeMirror">                    <pre><xmp>if(true)&#123;    console.log(1);    &#125;    else&#123;        consle.log(2);        &#125;//判断时否为真,如果为真执行上面的代码,如果为假执行下面的代码</xmp></pre>                </div>                <p></p>                <h4 id="s4.1.3">4.1.3 if....else if....else</h4>                <p></p>                <div class="codeMirror">                    <pre><xmp>var a=1;if(a===1)&#123;    console.log(1);    &#125;    else if(a===2)&#123;        console.log(2);            &#125;    else&#123;        console,log(3);        &#125;//从上到下一次进行判断,如果第一次判断为真则执行第一个判断里面的代码,如果第一次为假第二次为真则执行第二个判断里的代码,如果都为假则执行第三个判断里的代码                                //在这里else if可以写无数个,因为这个其实还是按照if...else的写法来写的</xmp></pre>                </div>                <p></p>                <h3 id="s4.2">4.2 switch语句</h3>                <p></p>                <div class="codeMirror">                    <pre><xmp> switch(x)&#123;    case 1：；    break;    case 2: ;    break;  default:&#125;//括号里的字姆依次与下面做全等(===)比较</xmp></pre>                </div>                <p></p>                <div class="codeMirror">                    <pre><xmp>可以在case里面用数字或者字符一起用，只是做全等比较而已，比如和以x="abc"switch(x)&#123;    case 1:;    break;    case 2:;    break;    case "abc":;    break;    default:    &#125;</xmp></pre>                </div>                <p></p>                <p></p>                <p>注意:</p>                <ul>                    <li>JS里面的switch中的case可以接受一个表达式，因为swich语句在其他语句时case里面只能是数字或者字符</li>                    <div class="codeMirror">                        <pre><xmp>var score=80;    switch(true)&#123;    case score>=60：    case score>=50:    &#125;</xmp></pre>                    </div>                    <li>• switch语句中每一个case后面需要加上break来表示跳出选择,不然就会一直往下面运行case直到遇到break或将里面的选项全部运行完</li>                </ul>            </div>            <div class="list" id="s5">                <h2>5.循环语句</h2>                <p></p>                <h3 id="s5.1">5.1 while与do...while语句</h3>                <p></p>                <p></p>                <p>while和do...while都是循环语句,在条件允许的情况下会一直循环语句内的代码</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var i=0;while(i>5)&#123;    console.log(i);&#125;do&#123;console.log(i);&#125;while(i>5)    //两个语句循环功能类似，不同的是while是先判断后执行，do...while是先执行后判断//所以在进行判断的时候while可以一次都不执行,而do...while至少会进行一次</xmp></pre>                </div>                <p></p>                <h3 id="s5.2">5.2 for循环语句</h3>                <p></p>                <div class="codeMirror">                    <pre><xmp>/*for(单次表达式;&#123;条件表达式&#125;;末尾循环体)    &#123;        中间循环体；    &#125;*/    for(var i=0;i<5;i++)&#123;        console.log(i);    &#125;//单次表达式只会在开始的时候进行一次,后面将不会进行,可以在单次表达式声明变量,也可以在前面先声明变量//执行末尾循环体后将再次进行条件判断，若条件还成立，则继续重复上述循环，当条件不成立时则跳出当下for循环</xmp></pre>                </div>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>表达式皆可以省略，但分号不可省略，因为“;”可以代表一个空语句，省略了之后语句减少，即为语句格式发生变化</li>                    <li>执行的中间循环体可以为一个语句，也可以为多个语句，当中间循环体只有一个语句时，其大括号&#123;&#125;可以省略，执行完中间循环体后接着执行末尾循环体</li>                    <li>可以用break和continue等提前中断循环语句,但是这两个只是中断离得最近的循环语句</li>                    <li>可以使用label(关联)加上break或continue来跳出多个循环(标记内容不一样是label单词，可以为任意符合标准的) 结束离标记最近的for循环,如果没有直接使用标记的话，break或continue结束的是当前的for循环</li>                    <div class="codeMirror">                        <pre><xmp>for(var k = 0;k<5;k++)&#123;    console.log( '我是第k:'+k+'个' );                                            jump://结束下面最近的for循环    for( var i = 0; i <3;i++ )&#123;      console.log( '我是第i:'+i+'个' )；         for( var s = 0;s<4;s++ )&#123;         if( s === 2 )&#123;         break zhuang; //结束            &#125;            console.log( '我是第s:'+s+'个' )；        &#125;    &#125;&#125;</xmp></pre>                    </div>                    <li>在用for循环循环一个数组的长度时,如果先在外边将数组的长度赋值,会提升程序性能</li>                    <div class="codeMirror">                        <pre><xmp>var arr=[1,2,3,4,5];for(let i=0,len=arr.length;i<len;i++)&#123;    console.log(i);&#125;</xmp></pre>                    </div>                </ul>                <h3 id="s5.3">5.3 性能测试</h3>                <p></p>                <p>用console.time()测试程序性能</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>/* console.time("计时器的名字")可以用来开启计时器，它需要一个字符串作为参数，这个字符串作为计时器的标识 然后在需要测试的代码后面加console.timeEnd("计时器的名字")停止一个计时器*/console.time("test");for(var i=0;i<5;i++)&#123;    console.log(i);&#125;console.timeEnd("test");// 会在控制台中显示之间一共用了多长时间</xmp></pre>                </div>            </div>            <div class="list" id="s6">                <h2>6.普通对象</h2>                <p></p>                <h3 id="s6.1">6.1 对象的分类</h3>                <p></p>                <p>JS中数据类型有String Number Boolean Null Undefined Object前五个为基本数据类型,Object对象为引用数据类型,值只要不是前5种,都是对象</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>//使用基本数据类型创建变量var name ="孙悟空";var gender="男";var age=18;//使用基本数据类型的创建数据，我们所创建的变量都是独立，不能成为一个整体//使用对象创建变量var obj=&#123;name:"孙悟空",gender:"男",age:18&#125;;//对象属于一个复合的数据类型，在对象中可以保存多个不同数据类型的属性</xmp></pre>                </div>                <p></p>                <p>对象的分类:</p>                <p></p>                <ul>                    <li>内建对象<br/>由es标准中定义的对象，在任何的ES的实现中都可以使用,如 Math String Number Boolean Function Object等</li>                    <li>宿主对象<br/>由js的运算环境提供的对象，目前来讲主要指由浏览器提供的对象如BOM DOM,如console.log中的console和document.write中的document就是一个对象</li>                    <li>自定义对象<br/>由开发人员自己创建的对象</li>                </ul>                <p></p>                <h3 id="s6.2">6.2 创建对象</h3>                <p></p>                <h4 id="s6.2.1">6.2.1 构造函数创建对象</h4>                <p></p>                <p>使用new关键字调用的函数，是构造函数construstor,构造函数是专门用来创建对象的函数</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var obj=new Object();//通过构造函数的方式创建对象console.log(typeof obj)//使用typeof检查一个对象时，会返回objectconsole.log(obj)//这里obj是一个空的对象,之间打印这个对象会返回Oject&#123;&#125;</xmp></pre>                </div>                <p></p>                <ul>                    <li>属性</li>                    <p></p>                    <p>在对象中保存的值称为属性,向对象中添加属性,语法:对象.属性名=属性值;或对象["属性名"]=属性值;</p>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>var obj=new Object();obj.name="孙悟空";obj.gender="男";obj.age=18;console.log(obj)//在这里obj中有值会打印出Object&#123;name:"孙悟空",gender:"男",age:18&#125;</xmp></pre>                    </div>                    <li>读取对象中的属性</li>                    <p></p>                    <p>语法:对象.属性名或对象["属性名"]</p>                    <p></p>                    <p>注:如果读取对象中没有的属性,不会报错而是会返回undefined</p>                    <p></p>                    <li>修改对象的属性值</li>                    <p></p>                    <p>语法:对象.属性名=新值或对象["属性名"]=新值</p>                    <p></p>                    <p>删除对象的属性</p>                    <p></p>                    <p>语法:delete 对象.属性名或delete 对象["属性名"]</p>                    <p></p>                    <p>注:删除后的属性不再存在于整个对象中,如果再次读取会返回undefined</p>                    <p></p>                    <li>验证对象中是否有该属性</li>                    <p></p>                    <p>语法:"属性名" in 对象</p>                    <p></p>                    <p>注:属性名实质上时字符串,所以要加引号</p>                    <p></p>                    <li>属性名</li>                    <li>对象的属性名不强制要求遵守标识符的规范,但是使用时尽量按照标识符的规范去做</li>                    <li>如果在创建属性名时用的是.或者[]方法中的一个,在调用和修改删除时也要用同样的方式调用</li>                    <li>要使用特殊的属性名，不能使用.的方式，需要用 对象["属性名"]=属性值的方式<br/>使用[]这种形式去操作属性更加的灵活，在[]中甚至可以直接传递一个变量,这样就能通过变量名来改变属性名,而.只能跟去掉了""的字符串.的方式,不能使用变量                        <div class="codeMirror">                            <pre><xmp>var obj=new Object();var x="name";                                        obj["name"]="孙悟空";obj["gender"]="男";                                        console.log(obj[x]);//打印结果为孙悟空x="gender";console.log(obj[x]);//打印结果为男</xmp></pre>                        </div>                    </li>                    <p></p>                    <p>注意:</p>                    <ul>                        <li>如果[]中是一个变量就不要加引号,否则会认为是一个字符串</li>                        <li>[]里面除了字符串必须加引号，其他的可以不加引号，和基本数据类型相似</li>                    </ul>                    <li>属性值</li>                    <p></p>                    <p>JS对象的属性值,可以是任意的数据类型,包括对象</p>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>var obj=new Object();obj.test=obj2;obj2=new Object();Obj2.name="猪八戒"；console.log(obj.test);//打印出obj2对象console.log(obj.test.name);//打印出猪八戒//由此可以说明对象的属性值可以是以对象来构成无限嵌套关系</xmp></pre>                    </div>                    <p></p>                    <li>枚举对象中的属性<br/>for…in语句与for...of语句能够枚举对象中的属性，对象中有几个属性，循环体就会执行几次</li>                    <p>注:</p>                    <ul>                        <li>for...of语句只能遍历数组,不能遍历JSON对象</li>                        <li>for...in的性能很差,因为会遍历对象的原型对象</li>                    </ul>                    <div class="codeMirror">                        <pre><xmp>/*语法:for(var 变量 in/of 对象）&#123;&#125;*/var obj=&#123;name:"孙悟空",gender:"男",age:18&#125;;for(var i in obj)&#123;    console.log(obj[i]);//打印出属性值&#125;/*for…in语句每次执行时，会将对象中的属性名赋值给变量可以利用console.log(n);来获取属性值，n取得的属性值都会转化为字符串的形式,和前面的查找一个属性是否在字符串里面用in的情况不同*/for(var i of obj)&#123;    console.log(i);//打印出属性值&#125;/*for...of语句每次执行时,会将数组中的值赋值给变量，和for...in语句有所差别*/</xmp></pre>                    </div>                </ul>                <p></p>                <h4 id="s6.2.2">6.2.2 对象字面量创建对象</h4>                <p></p>                <p>语法:&#123;属性名:属性值,属性名:属性值....&#125;</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var obj=&#123;name:"孙悟空",gender:"男",age:18&#125;;</xmp></pre>                </div>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>属性名和属性值之间的=要变成:</li>                    <li>对象字面量的属性名加引号也可以不加，建议不加。但是如果使用一些特殊非法的名字，必须加引号，汉字也可以使用，对象字面量里面也可以嵌套使用对象字面量</li>                </ul>                <p></p>                <p>对象字面量创建对象的简化操作</p>                <p></p>                <ul>                    <li>在创建函数的时候可以省略:function,直接用函数名</li>                    <li>可以使用[]对属性名进行操作</li>                    <div class="codeMirror">                        <pre><xmp>var obj=&#123;    ["a"+"b"]:123,                                            /*    say:function()&#123;        alert("hello");    &#125;    */    //方法的简写    say()&#123;        alert("hello");    &#125;&#125;</xmp></pre>                    </div>                </ul>                <p></p>                <h3 id="s6.3">6.3 JSON</h3>                <p></p>                <p>JSON全称为JavaScript Object Notation(javaScript对象表示法),JS中的对象只有JS才能够解析并识别,其它语言都不能识别,所以如果需要做数据传输,就需要一个所有语言都能够识别的通用数据类型</p>                <p></p>                <p>JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言识别，并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互,JSON和JS中对象的格式一致，只不过JSON字符串中的属性名和属性值必须用双引号括起来,除此之外内部结构的语法和JS中的语法一致</p>                <p></p>                <p></p>                <p></p>                <h4 id="s6.3.1">6.3.1 JSON分类</h4>                <p></p>                <ul>                    <li>对象&#123;&#125;</li>                    <li>数组[]</li>                </ul>                <p></p>                <p>注意:无论是对象还是数组都必须使用字面量形式的,并且在最外层都需要用引号包裹让整体成为字符串</p>                <p></p>                <h4 id="s6.3.2">6.3.2 属性值</h4>                <p></p>                <p>在JSON中的属性值只允许以下六种</p>                <p></p>                <ul>                    <li>字符串</li>                    <li>数值</li>                    <li>布尔值</li>                    <li>null</li>                    <li>对象</li>                    <li>数组</li>                </ul>                <p></p>                <p>注:undefined,symbol值和函数都不能作为属性值,对象形式如果有这三种类型的值会在转换为JSON的时候被过滤掉,数组形式如果有会被转换为null传入JSON中</p>                <p></p>                <p></p>                <h4 id="s6.3.3">6.3.3 JSON与对象的转换</h4>                <p></p>                <p>JS为我们提供了一个工具类对象JSON,这个对象可以帮助我们将一个JSON转换为JS对象，也可以将一个JS对象转换为JSON</p>                <p></p>                <ul>                    <li>JSON-->JS对象<br/>通过JSON.parse()函数可以将以JSON字符串转换为JS对象，该函数需要一个JSON字符串作为参数，会将JSON字符串转换为JS对象并返回                        <div class="codeMirror">                            <pre><xmp>var json='&#123;"name":"孙悟空","age":"18"&#125;';var obj=JSON.parse(json);console.log(obj.name);//"孙悟空"</xmp></pre>                        </div>                    </li>                    <li>JS对象-->JSON<br/>通过JSON.stringify()函数可以将一个JS对象转换为JSON字符串,该函数需要一个JS对象作为参数，会返回一个JSON字符串                        <div class="codeMirror">                            <pre><xmp>var json=&#123;name:"孙悟空",age:"18"&#125;;var json=JSON.stringify(obj);console,log(json);//'&#123;"name":"孙悟空","age":"18"&#125;'</xmp></pre>                        </div>                    </li>                    <p></p>                    <p>确认一个对象是否为空对象</p>                    <div class="codeMirror">                        <pre><xmp>var obj=&#123;&#125;;var str=JSON.stringify(obj).replace(/\s|\r\n/g,"");if(str.length===2)&#123;console.log("这是一个空对象")&#125;</xmp></pre>                    </div>                </ul>                <p></p>                <p>注意:JSON这个类对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错</p>                <p></p>                <p>兼容方法</p>                <p></p>                <ul>                    <li>使用eval()函数来替代JSON的类对象                        <div class="codeMirror">                            <pre><xmp>/*eval()函数1.可以用来执行一段字符串形式的JS代码,并将指向结果返回2.如果使用eval()函数执行的字符串中含有&#123;&#125;,该函数会将&#123;&#125;当做代码块,如果不希望其被当成代码块解析,则需要用()将字符串包裹*/var str="alert('hello')";eval(str);//会出现弹框var json='&#123;"name":"孙悟空","age":"18"&#125;';var obj=eval("("+json+")");console.log(obj);//&#123;name:"孙悟空",age:"18"&#125;</xmp></pre>                        </div>                        <p></p>                        <p></p>                        <p>注意:eval()函数的功能很强大.可以直接执行一个字符串中的JS代码,但是在开发中尽量不要使用该函数,因为该函数不仅性能较差,而且存在非常大的安全隐患,容易被植入恶意代码造成损失</p>                    </li>                    <p></p>                    <li>直接用外部引用的JSON</li>                </ul>                <p></p>                <h3 id="s6.4">6.4 栈内存与堆内存</h3>                <p></p>                <p>在讲内存之前先将讲数据,在js中的数据分为两种,一种是引用型数据,一种是值类型数据</p>                <p></p>                <p>引用型数据只有object,而值类型数据有number,boolean,string,undefined,null。值类型数据在比较时,只比 较是否长的一样,而引用型数据在比较时是比较内存地址                </p>                <p></p>                <p></p>                <p>关于栈内存与堆内存</p>                <p></p>                <ul>                    <li>js中的变量都是保存到栈内存中</li>                    <li>基本数据类型的值在栈内存中存储，值与值之间是独立存在，修改一个变量不会影响其他变量</li>                    <li>对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟一个新的空间，而变量保存的是对象的 内存地址(对象的引用)，如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响                        <div class="codeMirror">                            <pre><xmp>var obj=&#123;name:"孙悟空",gender:"男",age:18&#125;;var obj2=obj;console.log(obj.age)//打印结果为18obj2.age=19;console.log(obj.age)//打印结果为19</xmp></pre>                        </div>                        <p></p>                        <p>注意:</p>                        <ul>                            <li>如果只是让obj2=null，obj并不会变化，因为这是让obj2的地址改变，而不是改变地址里面的值</li>                            <li>当比较两个基本数据类型的值时,就是比较值,而比较两个引用数据类型时,比较的是对象的地址,如果两个对象是一模一样的，但是地址不同，也会返回false</li>                        </ul>                </ul>            </div>            <div class="list" id="s7">                <h2>7.数组</h2>                <p></p>                <p>数组也是一个对象,它和普通对象功能类似,也是用来存储值,不同的是普通对象使用字符串作为属性名，而数组是使 用数字来作为属性名操作属性值,所以数组的存储性比普通对象要好，在开发中经常使用数组来存储数据                </p>                <p></p>                <p>注意:因为是使用数组索引来操作属性,所以不能使用.的方法来控制,只能用[]的形式</p>                <p></p>                <p>数组的值</p>                <p></p>                <p>数组的值可以是任何的数据类型,不一定是数值,也可以是一个对象,甚至一个函数,还可以是一个其他数组</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var arr=[&#123;name:"孙悟空",gender:"男",age:18&#125;];var arr2=[function()&#123;arlert("1")&#125;;arr2[0]();var arr3=[[1,2,3],[1,2,3]]；//这个就是我们说的二维数组</xmp></pre>                </div>                <p></p>                <h3 id="s7.1">7.1 创建数组</h3>                <p></p>                <p>创建数组时有四种方式,其中前三种都是通过构造函数来创建数组,只是传入的参数不同</p>                <ul>                    <li>声明或创建一个不指定长度的数组                        <div class="codeMirror">                            <pre><xmp>var arr=new Array();//这时创建的数组里面没有值,可以向里面加值</xmp></pre>                        </div>                    </li>                    <li>声明或创建一个指定长度的数组                        <div class="codeMirror">                            <pre><xmp>var arr=new Array(10);//创建一个length长度为10的数组,没有默认值</xmp></pre>                        </div>                    </li>                    <li>声明或创建一个带有默认值的数组                        <div class="codeMirror">                            <pre><xmp>var arr=new Array(10,20,50);//创建一个length长度为3,带有值10,20,50的数组</xmp></pre>                        </div>                    </li>                    <li>使用字面量创建数组(推荐使用这种方式)                        <div class="codeMirror">                            <pre><xmp>var arr=[1,2,3,4,5,10];//创建一个length长度为5,默认值为1,2,3,4,5,10的数组//也可以创建不定长度的数组var arr2=[];                                        //数组字面量和对象字面量的区别在于数组字母量是用[]括起来,并且不用写属性值,默认使用的索引作为属性值</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <p>数组中读取与添加元素</p>                <p></p>                <ul>                    <li>读取:数组[索引]<br/>注意:如果读取不存在的索引,不会报错而是返回undefined,但是数组的长度还是原来有内容的长度</li>                    <li>添加:数组[索引]=值<br/>注意:</li>                    <ul>                        <li>如果给已经存在值的索引添加一个新值,旧值会被覆盖掉,数组长度不变</li>                        <li>如果给不存在值的索引添加一个新值,数组的长度会变为添加新值的索引的值-1,中间没有值的索引中会存 入empty(空)                        </li>                    </ul>                </ul>                <p></p>                <h3 id="s7.2">7.2 length</h3>                <p></p>                <p>length是数组的一个属性,代表数组的长度</p>                <p></p>                <ul>                    <li>对于连续的数组,使用length可以获取到数组的长度(值的个数)</li>                    <li>对于非连续的数组,使用length会获取到数组的最大的索引加1(没有值的索引为empty),尽量不要创建非连续的 数组                    </li>                </ul>                <p></p>                <p>查看数组长度:数组名.length</p>                <p></p>                <div class="codeMirror">                    <pre><xmp> var arr=[1,2,3];console.log(arr.length);</xmp></pre>                </div>                <p></p>                <p>注意:数组的length属性是能修改的</p>                <p></p>                <ul>                    <li>如果length大于原长度，则多余的部分索引的值为empty</li>                    <li>如果length小于原长度，则多出的元素会被删除，所以可以修改length的长度为0来让数组为空</li>                </ul>                <p></p>                <p>向数组的最后一个位置添加元素</p>                <p></p>                <p>用法:数组名[数组名.length]=值</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var arr=new Array()arr[arr.length]=70；// 因为length永远是最大索引加1</xmp></pre>                </div>                <p></p>                <h3 id="s7.3">7.3 数组的方法</h3>                <p></p>                <p>数组的方法一般都不会使原数组发生变化,而是返回一个新的数组,只有改变原数组结果的方法才会使得原数组发生改变</p>                <p></p>                <h4>7.3.1 push与pop方法</h4>                <p></p>                <ul>                    <li>push()方法可以向数组的末尾添加一个或多个值,并返回数组的新长度</li>                    <ul>                        <li>添加一个值时,作用和用length向数组中最后添加一个值相同</li>                        <li>添加多个值时,参数用,隔开                            <div class="codeMirror">                                <pre><xmp>var arr=[];//将要添加的值作为该方法的参数传递,添加的值会自动在数组的最后console.log(arr.push(1));//返回的值为1,返回值是这个数组的新长度console.log(arr);//值为1的数组console.log(arr.push(2,3));console.log(arr);//值为1,2,3的数组</xmp></pre>                            </div>                        </li>                        <li>pop()方法可以删除数组的最后一个值，并将被删除的值作为返回值返回,不传入参数                            <div class="codeMirror">                                <pre><xmp> var arr=[1,2,3];console.log(arr.pop());//返回3console.log(arr);//每使用一次数组长度length减少1</xmp></pre>                            </div>                        </li>                    </ul>                </ul>                <h4 id="s7.3.2">7.3.2 unshift与shift方法</h4>                <p></p>                <ul>                    <li>unshift()方法向数组开头添加一个或多个值,并返回新的数组长度,添加多个值时,参数用,隔开。添加完成后其 它值的索引一次向后调整对象的值                        <br/>注意:只能通过该方法在数组最前方添加新的值                        <div class="codeMirror">                            <pre><xmp>var arr=[2,3];console.log(arr.unshift(1));//返回数组新长度3console.log(arr);//值为1,2,3的数组                                    console.log(arr.unshift(-1,0));console.log(arr);//值为-1,0,1,2,3的数组</xmp></pre>                        </div>                    </li>                    <li>shift()方法删除数组的第一个元素,并将被删除的元素作为返回值返回用法与pop()相反                        <div class="codeMirror">                            <pre><xmp>var arr=[1,2,3];console.log(arr.shift());//返回1console.log(arr);//每使用一次数组长度length减少1,并且其他值的索引依次-1</xmp></pre>                        </div>                    </li>                </ul>                <h4 id="s7.3.3">7.3.3 forEach方法</h4>                <p></p>                <p>数组的遍历</p>                <p></p>                <ul>                    <li>for循环遍历数组,通过数组的length属性来获取数组的长度                        <div class="codeMirror">                            <pre><xmp>var arr=[1,2,3,4,5];for(let i=0;i<arr.length;i++)&#123;    console.log(i);&#125;</xmp></pre>                        </div>                    </li>                    <li>forEach()方法遍历数组(该方法只支持IE8以上的浏览器,如果要兼容IE8,用for循环)<br/>forEach()方法需要一个函数作为参数才能使用,数组中有几个元素函数就会执行几次,不支持在函数中添加 返回值                        <div class="codeMirror">                            <pre><xmp>var arr=[1,2,3];arr.forEach(function()&#123;//这个函数只是我们创建,但是不需要我们调用,由浏览器自动调用,称为回调函数console.log("hello");    &#125;)</xmp></pre>                        </div>                    </li>                    <p></p>                    <p>每次执行时浏览器会将遍历到的数组以实参的形式传递进来,可以定义形参来读取这些内容</p>                    <p></p>                    <p> 该方法有两个参数</p>                    <p></p>                    <li>回调函数function(value,index,array)<br/>浏览器在回调函数中传递了三个参数</li>                    <ul>                        <li>第一个参数是遍历到的值value</li>                        <li>第二个参数是当前正在遍历元素的索引index</li>                        <li>第三个参数是正在遍历的数组(可选)</li>                    </ul>                    <div class="codeMirror">                        <pre><xmp>var arr=[1,2,3];arr.forEach(function(value,index,array)&#123;    console.log(index+","+value);    console.log(array);    &#125;)</xmp></pre>                    </div>                    <li>回调函数中this所指的对象,如果不写或者传入null和undefined,回调函数中的this为全局对象window(可选)</li>                </ul>                <h4 id="s7.3.4">7.3.4 map方法</h4>                <p></p>                <p>map(映射)()方法也是用做遍历数组,返回一个新数组,数组中的元素为原始数组元素调用函数处理后的值,并且按 照原始数组元素顺序依次处理元素                </p>                <p></p>                <p>该方法有两个参数</p>                <p></p>                <ul>                    <li>回调函数function(value,index,array)&#123;&#125;(和forEach中的回调函数一样),但是可以在回调函数里加返回值<br/>浏览器在回调函数中传递了三个参数</li>                    <ul>                        <li>第一个参数是遍历到的值value</li>                        <li>第二个参数是当前正在遍历元素的索引index</li>                        <li>第三个参数是正在遍历的数组(可选)</li>                    </ul>                    <li>回调函数中this所指的对象,如果不写或者传入null和undefined,回调函数中的this为全局对象window(可选)</li>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>let arr = [12, 5, 8];let result = arr.map(function (item) &#123;    return item*2;&#125;)let result2 = arr.map(item=>item*2);//map方法适合用箭头函数console.log(result);//[ 24, 10, 16 ]console.log(result2);//[ 24, 10, 16 ]let score = [18, 86, 88, 24];let result3 = score.map(item =>item>= 60?'及格':'不及格');console.log(result3);//[ '不及格', '及格', '及格', '不及格']let arr2=[1,2,3];let result4=arr2.map(function(value,index,array),arr2)&#123;    console.log(this);//this的指向为arr2    return value+index;&#125;</xmp></pre>                    </div>                </ul>                <h4 id="s7.3.5">7.3.5 reduce方法</h4>                <p></p>                <p>reduce(汇总)()方法接收一个函数作为累加器，数组中的每个值(从左到右)开始缩减,最终计算为一个值</p>                <p></p>                <p>该方法有两个参数</p>                <p></p>                <ul>                    <li>回调函数function(total, value, index, array)<br/>浏览器在回调函数中传递了四个参数</li>                    <ul>                        <li>第一个参数是每次计算结束后的返回值(第一次计算时默认值是0)</li>                        <li>第二个参数是遍历到的值value</li>                        <li>第三个参数是当前正在遍历元素的索引index</li>                        <li>第四个参数是正在遍历的数组(可选)</li>                    </ul>                    <li>回调函数的初始值initialValue(用于设置上方第一个参数第一次计算时的值)(可选)                        <p></p>                        <div class="codeMirror">                            <pre><xmp> //数组求和var arr=[1,2,3,4,5];var result=arr.reduce(function(prev,next)&#123;      return prev+next; &#125;)console.log(result);//值为15;//对象求和var ps = [&#123;'p':1,'num':1&#125;,&#123;'p':2,'num':2&#125;,&#123;'p':3,'num':3&#125;,&#123;'p':4,'num':4&#125;];ps.reduce(function(prev,next)&#123;      return prev+next.p*next.num;&#125;,10)//回调函数的第一次调用时，第一个参数是10，第二个参数是p[0]//检验数组中出现字符串的数目var arr=["HTML","JS","CSS","JAVA","CSS","HTML","HTML"];var result=arr.reduce(function(back,prop)&#123;back[prop]=back[prop]?++back[prop]:1;    return back;&#125;,&#123;&#125;)console.log(result);//&#123;HTML: 3, JS: 1, CSS: 2, JAVA: 1&#125;</xmp></pre>                        </div>                    </li>                </ul>                <h4 id="s7.3.6">7.3.6 filter方法</h4>                <p></p>                <p>filter(过滤器)()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素</p>                <p></p>                <p>该方法有两个参数</p>                <ul>                    <li>回调函数function(value,index,array)</li>                </ul>                <p></p>                <p>浏览器在回调函数中传递了三个参数</p>                <p></p>                <ul>                    <li>第一个参数是遍历到的值value</li>                    <li>第二个参数是当前正在遍历元素的索引index</li>                    <li>第三个参数是正在遍历的数组(可选)</li>                    <li>回调函数中this所指的对象,如果不写或者传入null和undefined,回调函数中的this为全局对象window(可选)</li>                </ul>                <div class="codeMirror">                    <pre><xmp>//创建一个数组，判断数组中是否存在某个值var newarr = [  &#123; num: 1, val: 'ceshi', flag: 'aa' &#125;,  &#123; num: 2, val: 'ceshi2', flag: 'aa2'  &#125;];console.log(newarr.filter(item => item.num===2 ));//去掉空数组空字符串、undefined、nullvar arr = ['1',null,undefined, '3.jpg',''];var newArr = arr.filter(item => item);//因为null,undefined和null转换为布尔值都是falseconsole.log(newArr);//只有1和3.jpg</xmp></pre>                </div>                <h4 id="s7.3.7">7.3.7 slice方法</h4>                <p></p>                <p>slice()方法可以用来从数组截取指定一部分值,这个方法不会影响原数组</p>                <p></p>                <p>该方法有两个参数</p>                <p></p>                <ul>                    <li>截取开始的位置(必选)</li>                    <li>截取结束的位置(查找时不包括结束位置)(可选),如果不写结束位置会从截取位置开始将后面所有值都截取</li>                </ul>                <div class="codeMirror">                    <pre><xmp>var arr=[123,"孙悟空","猪八戒"]；var result=arr.slice(0,2);console.log(result);//值为123和孙悟空</xmp></pre>                </div>                <p></p>                <p>注意:</p>                <ul>                    <li>该方法只能从左往右边截取,如果第一个数比第二个数大,则会返回空串</li>                    <li>该方法接收负值,负值意味着从右往左数</li>                </ul>                <h4 id="s7.3.8">7.3.8 splice方法</h4>                <p></p>                <p>splice()方法可以用于删除数组中的指定元素，并向数组中添加新元素,可以看作是push,pop和unshift,shift四种方 法的结合,该方法会影响到原数组,会将指定元素从元素组中删除,并将被删除的元素作为返回值返回                </p>                <p></p>                <p>注意:如果没有删除任何元素,返回空数组</p>                <p></p>                <p>该方法有任意多个参数,但是有两个必选参数</p>                <p></p>                <ul>                    <li>第一个参数规定开始删除元素的索引位置</li>                    <li>第二个参数规定应该删除的元素数量,值可以为0</li>                    <li>第三个及以后的参数是要添加到数组中的新元素,这些元素将会自动插入到开始位置索引的前边</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>var arr=[0,1,2,3,4];var result=arr.splice(0，2);console.log(arr);//值为2,3,4的数组console.log(result);//值为0,1的数组</xmp></pre>                </div>                <p></p>                <div class="codeMirror">                    <pre><xmp>//用作去除相等的数组中的数值时,可以用splice()方法来删除一个数组元素    //方法一    var arr=[1,2,3,5,3,3,6];    for(var i=0;i<arr.length-1;i++)    &#123;        for(var j=i+1;j<arr.length;j++)        &#123;            if(arr[i]===arr[j])            &#123;                arr.splice(j,1);                j--;//当删除了当前的j所在元素以后,后面的元素会自动补位，                此时将不会再比较这个元素，所以需要自减才能比较            &#125;        &#125;    &#125;    //方法二    var arr2=[1,2,3,5,3,3,6];    for(var i=arr2.length-1;i>=0;i--)//从后往前判断    &#123;        for(var j=i-1;j>=0;j--)        &#123;            if(arr2[i]===arr2[j])            &#123;                arr2.splice(j,1);            &#125;        &#125;    &#125;    //方法三(ES6方法去重)    var arr3=[1,2,3,5,3,3,6];    var arr4=[...new Set(arr3)];    /*    用new Set()会将传入的数组转换为Set结构数组,因为Set结构是不允许有重复的数据,所以会自动去重,    最后通过解构将Set结构数组重新转换为普通数组    */</xmp></pre>                </div>                <h4>7.3.9 concat方法</h4>                <p></p>                <p>concat()方法可以连接两个或多个数组,也可以连接单个的元素,并将新数组返回,该方法不会对原数组产生影响</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var arr=[123,245];    var arr2=[566,156];        var result=arr.concat(arr2);//将两个数组连接起来    console.log(result);//result的值为123,245,566,156        //可以连接多个数组或值    var arr3=[1,2,3]    var result2=arr.concat(arr2,arr3,"999");    console.log(result2);//值为123,245,566,156,1,2,3,"999"   </xmp></pre>                </div>                <p></p>                <p>注意:将一个数组放在另一个数组中最好的方法还是通过ES6的语法: ...数组名 来实现</p>                <h4 id="s7.3.10">7.3.10 join方法</h4>                <p></p>                <p>join()方法可以将数组转换为一个字符串,并将转换后的字符串返回,不会对原数组产生影响</p>                <p></p>                <p>join中的参数为一个字符串,用这个字符串代替数组中的,(逗号)将数组分开,默认值为,(逗号),与对整个数组使用 toString()方法效果一样                </p>                <p></p>                <p>注意:如果在join()中传入了空串""作为参数,那么返回的字符串是整个数组合并后的值,相当于把数组中每个值用+连 接                </p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var arr=[1,2,3];    var str=arr.join();//默认用,分开    var str2=arr.join("");//空串将整个数组的值合并    var str3=arr.join("H");//用字符H隔开    console.log(str);//"1,2,3"    console.log(str2);//"123"    console.log(str3);//"1H2H3"</xmp></pre>                </div>                <h4 id="s7.3.11">7.3.11 reverse方法</h4>                <p></p>                <p>reverse()方法用作将数组里的值反转(左边的值到右边,右边的值到左边),该方法会直接修改原数组，返回值也是 修改后的数组                </p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var arr=[1,2,3];var result=arr.reverse();console.log(arr);//值依次为3,2,1console.log(result);//值依次为3,2,1</xmp></pre>                </div>                <h4 id="s7.3.12">7.3.12 sort方法</h4>                <p></p>                <p>sort()方法会对数组的元素进行排序,默认会按照Unicode编码进行排序(不是比较值的大小,即使对于纯数字的数 组,也会按照Unicode编码来排序),该方法会影响原数组</p>                <p></p>                <p>自己指定排序的规则</p>                <p></p>                <p>在sort()添加一个回调函数,回调函数中需要定义两个形参,浏览器将会分别使用数组中的元素作为实参去调用回 调函数，使用哪个元素调用不确定，但是肯定的是在数组中a一定在b的前面,浏览器会根据回调函数的返回值来决定元素的顺序                </p>                <p></p>                <p>如果返回一个大于0的值 ，则元素会交换位置，如果返回一个小于0的值，则元素位置不变，如果返回0，则认为两个元素相等，也不交换位置</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var arr=[5,4,2,1,3,8,9]    arr.sort(function(a,b)&#123;        if(a>b)&#123;            return 1        &#125;        else if(a<b)&#123;            return -1;        &#125;        else        &#123;            return 0;        &#125;    &#125;)    console.log(arr);//[1,2,3,4,5,8,9]    //上面是升序排列，如果要降序排列只用改变返回值        arr.sort(function(a,b)&#123;        return a-b//上面写法的简写    &#125;)</xmp></pre>                </div>                <h4 id="s7.3.13">7.3.13 indexOf与lastIndexOf方法</h4>                <p></p>                <ul>                    <li>indexOf()方法可以检索一个数组中是否含有指定的元素,找到返回该元素在数组中的索引位置,没有找到则返 回-1                        <br/>该方法可以指定第二个参数,第二个参数是指定开始查找的位置(0是第一个位置)                        <div class="codeMirror">                            <pre><xmp>var arr=[1,2,3];        var result=arr.indexOf(1);        console.log(result);//0        result=str.indexOf(1,1);        console.log(result);//-1       </xmp></pre>                        </div>                    </li>                    <li>• lastIndexOf()方法用法和IndexOf()类似,不同的是检索数组时是从右到左检索,也可以指定开始查找的位置                        <vr/>注意:虽然是从右往左检索,但是在设置第二个参数的时候指定开始查找的位置还是从左往右数的,只是查找的时 候是从右往左                    </li>                </ul>                <h4 id="s7.3.14">7.3.14 valueOf方法</h4>                <p></p>                <p>valueOf()返回数组原始值(数组本身)</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var arr=[1,2,3];var result=str.valueOf();console.log(str===result);//true</xmp> </pre>                </div>                <h4 id="s7.3.15">7.3.15 fill方法</h4>                <p></p>                <p>fill() 方法用于将一个固定值替换数组的元素,该方法有三个参数,会改变原数组</p>                <p></p>                <p>参数:</p>                <p></p>                <ul>                    <li>value,表示填充的值(必填)</li>                    <li>start,表示开始填充的位置(选填)</li>                    <li>end,表示停止填充的位置(选填,默认是整个数组长度)</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>var arr=new Array(100);//创建长度为100的数组arr.fill(1);//将1填充到所有的空位置/*上面相当于for(var i=0;i<arr.length;i++)&#123;    arr[i]=1;&#125;*/console.log(arr);//[1,1,1,1,1,1....1]</xmp></pre>                </div>                <h4 id="s7.3.16">7.3.16 find与findIndex方法</h4>                <p></p>                <ul>                    <li>find()方法返回通过测试的数组的第一个元素的值，接收一个回调函数,不会改变原始数组<br/>浏览器在回调函数中传递了三个参数</li>                    <ul>                        <li>第一个参数是遍历到的值value</li>                        <li>第二个参数是当前正在遍历元素的索引index</li>                        <li>第三个参数是正在遍历的数组(可选)</li>                    </ul>                    <p>find() 方法为数组中的每个元素都调用一次函数执行</p>                    <ul>                        <li>当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数</li>                        <li>如果没有符合条件的元素返回 undefined</li>                    </ul>                    <li>findIndex() 方法返回传入一个测试条件中符合条件的数组第一个元素位置,用法同find()方法相同,接收一个回调函数,不会改变原始数组<br/>findIndex()方法为数组中的每个元素都调用一次函数执行</li>                    <ul>                        <li>当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。</li>                        <li>如果没有符合条件的元素返回 -1</li>                    </ul>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>var arr=[1,2,3,4];var result1=arr.find(function(value,index,array)&#123;    return value>2;&#125;)var result2=arr.findIndex(function(value,index,array)&#123;    return value>2;&#125;)console.log(result1);//3console.log(result2);//2</xmp></pre>                    </div>                </ul>                <h4 id="s7.3.17">7.3.17 some与every方法</h4>                <p></p>                <ul>                    <li>some()方法用于检测数组中的元素是否满足指定条件,接收一个回调函数, 不会改变原始数组<br/>浏览器在回调函数中传递了三个参数</li>                    <ul>                        <li>第一个参数是遍历到的值value</li>                        <li>第二个参数是当前正在遍历元素的索引index</li>                        <li>第三个参数是正在遍历的数组(可选)</li>                    </ul>                    <p></p>                    <p>some() 方法会依次执行数组的每个元素</p>                    <ul>                        <li>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测</li>                        <li>如果没有满足条件的元素，则返回false</li>                    </ul>                    <li>every() 方法用于检测数组所有元素是否都符合指定条件,与some一样都接收一个回调函数,不会改变原始数<br/>every() 方法使用指定函数检测数组中的所有元素</li>                    <ul>                        <li>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</li>                        <li>如果所有元素都满足条件，则返回 true。</li>                    </ul>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>var arr=[1,2,3,4];var result1=arr.some(function(value,index,array)&#123;    return value>2;&#125;)var result2=arr.every(function(value,index,array)&#123;    return value>2;&#125;)console.log(result1);//trueconsole.log(result2);//fasle</xmp></pre>                </div>                <h4 id="s7.3.18">7.3.18 copyWithin方法</h4>                <p></p>                <p>coptWithin()方法用于在当前数组内部将指定位置的元素复制到其他位置,并且会覆盖掉原来的元素,返回当前数组,此方法会改变原数组,该方法有三个参数</p>                <p></p>                <p>参数:</p>                <p></p>                <ul>                    <li>target,从该位置替换数据</li>                    <li>start,从该位置读取数据,默认值是0,可以接受负值,负值代表从右往左数</li>                    <li>end.从该位置前停止读取数据,默认是整个数组长度,可以接受负值,负值代表从右往左数</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>var arr=[1,2,3,4,5];var result=arr.copyWith(0,3);//从数组第一个位置开始替换数据,从第四个位置开始读取,读取后面所有值console.log(arr);//[4,5,3,4,5]console.log(result);//[4,5,3,4,5]</xmp></pre>                </div>                <p></p>                <h4 id="s7.3.19">7.3.19 keys,values与entries方法</h4>                <p></p>                <p>这三个方法都用作遍历数组,都返回一个遍历器对象,可以用for...of语句进行遍历</p>                <p></p>                <ul>                    <li>keys()方法,对数组的键名(索引)进行遍历,返回一个新的数组</li>                    <li>values()方法,对数组的键值(值)进行遍历,返回一个新的数组</li>                    <li>entries()方法,对数组的键值对进行遍历,该方法会返回一个二维数组,会将遍历到的键名和键值装到一个数组里作为二维数组的值</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>for(var index of [1,2].keys())&#123;    console.log(index);//0 1&#125;for(var value of [1,2].values())&#123;    console.log(value);//1 2&#125;    for(var arr of[1,2].entries())&#123;    console.log(arr);//[0,1] [1,2]&#125;for(var [index,value] of [1,2].entries())&#123;    console.log(index,value);//0,1 1,2&#125;</xmp></pre>                </div>                <p></p>                <p>Object的keys,values与entries方法</p>                <p></p>                <p>Object的上述方法需要传入一个对象作为参数,此时会直接分别将键名,键值,键值对装在一个数组中</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var obj=["a":0,"b":1];console.log(Object.keys(obj));//["a","b"]console.log(Object.values(obj));//[0,1]console.log(Object.entries(obj));//[["a",0],["b",1]]</xmp></pre>                </div>                <p></p>                <h3 id="s7.4">7.4 Array的方法</h3>                <p></p>                <h4 id="s7.4.1">7.4.1 Array.isArray方法</h4>                <p></p>                <p>Array.isArray()方法检验一个对象是否为真数组(不支持低版本IE),可以用instanceof功能符来做兼容</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var arr=[];if(arr instanceof Array)&#123;    console.log("1");&#125;if(Array.isArray(arr))&#123;console.log("2");&#125;</xmp></pre>                </div>                <p></p>                <h4 id="s7.4.2">7.4.2 Array.from方法</h4>                <p></p>                <p>Array.from()方法用于将两类对象转换为真数组,该方法有三个参数</p>                <p></p>                <p>参数:</p>                <p></p>                <ul>                    <li>一个用于转换为真数组的类数组对象</li>                    <li>一个回调函数,类似于数组的map()方法中的回调函数,用来对每个元素进行处理,将处理后的值放入返回的数组</li>                    <li>回调函数中this所指的对象,如果不写或者传入null和undefined,回调函数中的this为全局对象window(可选)</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>//Nodelist对象var div=document.getElementByTagName("div");Array.from(div).forEach(function(value)&#123;    console.log(value);&#125;)//arguments对象function fun()&#123;    var arr=Array.from(argumens);    console.log(arr);&#125;</xmp></pre>                </div>                <h4 id="s7.4.3">7.4.3 Array.of方法</h4>                <p></p>                <p>Array.of()方法用于将一组值转换为数组,这个方法的主要目的是弥补构造函数Arrray()的因为参数数量的不同而造成行为不同的不足</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>console.log(Array());//[]console.log(Array(3));//[,,,]console.log(Array(1,2,3));//[1,2,3]console.log(Array.of(3));//[3]console.log(Array.of(1,2,3));//[1,2,3]console.log(Array.of(3).length);//1</xmp></pre>                </div>                <h3 id="s7.5">7.5 真数组与伪数组(类数组)</h3>                <p></p>                <p>真数组与伪数组都是对象,都有length属性,而且真数组与一些伪数组的length属性都可以修改,所以不能用数组的length属性是否可变来判断一个数组是否是真数组</p>                <p></p>                <p>真数组与伪数组的区别:真数组能够使用数组的拓展方法,而伪数组没有这些方法</p>                <p></p>                <p>用Array.isArray()可以检查一个对象是否为真数组</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var arr=[1,2,3];var obj=[0:1,1:2,2:3,length:3];//与真数组一样通过索引取值,有length属性    console.log(Array.isArray(arr));//trueconsole.log(Array.isArray(obj));//false</xmp></pre>                </div>                <p></p>                <p>真数组与伪数组的相互转换</p>                <p></p>                <ul>                    <li>真数组转换为伪数组                        <div class="codeMirror">                            <pre><xmp>var arr=[1,2,3];var obj=&#123;&#125;;[].push.apply(obj,arr);console.log(obj);</xmp></pre>                        </div>                    </li>                    <li>伪数组转换为真数组                        <div class="codeMirror">                            <pre><xmp>//通过Array.from()函数var obj=[0:1,1:2,2:3,length:3];var arr=Array.from(obj);console.log(arr);//通过方法var arr1=[];var obj1=[0:1,1:2,2:3,length:3];[].push.apply(arr,obj)//IE8以上兼容console.log(arr);var arr2=[].slice.call(obj);//兼容IE8console.log(arr2);//通过循环var arr3=[];var obj2=[0:1,1:2,2:3,length:3];for(var i=0;i<obj.length;i++)&#123;    arr3[i]=obj2[i];&#125;console.log(arr3);//通过拓展运算符var obj3=[0:1,1:2,2:3,length:3];var arr4=[...obj3];console.log(arr4);</xmp></pre>                        </div>                    </li>                </ul>            </div>            <div class="list" id="s8">                <h2>8.字符串方法</h2>                <p></p>                <h3 id="s8.1">8.1 length</h3>                <p></p>                <p>在底层字符串是以字符数组的形式保存的,所以字符串其实是有length属性的,并且也可以使用索引(低版本IE不 支持直接用索引,所以用charAt()代替)                </p>                <p></p>                <p>注意:与数组的length不同,字符串的length是只读的,不能修改</p>                <p></p>                <h3 id="s8.2">8.2 charAt,charCodeAt与fromCharCode方法</h3>                <p></p>                <ul>                    <li>charAt()方法可以返回字符串中指定位置的字符,根据索引获取指定的字符                        <p></p>                        <div class="codeMirror">                            <pre><xmp>var str="Hello"var result=str.charAt(0)console.log(result)//会打印出H字符</xmp></pre>                        </div>                    </li>                    <li>charCodeAt()方法会返回指定字符串中指定字符的Unicode编码                        <p></p>                        <div class="codeMirror">                            <pre><xmp>var str="123"var result=str.charCodeAt(0);console.log(result)//打印出49(1的unicode编码)</xmp> </pre>                        </div>                    </li>                    <li>fromCharCode()方法可以根据字符编码去获取字符,这个方法由String来调用                        <p></p>                        <div class="codeMirror">                            <pre><xmp>var result=String.fromCharCode(72)//result的值为字符串Hconsole.log(result);</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <h3 id="s8.3">8.3 concat方法</h3>                <p></p>                <p></p>                <p>concat()方法用于连接两个或多个字符串(中间,隔开),作用和+一样,但是+更加简便,所以一般字符串拼接还是用+</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var str1="123";var str2="456";var str3=str1.concat(str2);//通str1+str2//新字符串中的顺序还是先是调用者,然后后面是参数传入的顺序</xmp></pre>                </div>                <h3 id="s8.4">8.4 indexOf与lastIndexOf方法</h3>                <p></p>                <ul>                    <li>indexOf()方法可以检索一个字符串中是否含有指定的字符,找到返回该字符在字符串中的索引位置,没有找到则 返回-1                        <p>该方法可以指定第二个参数,第二个参数是指定开始查找的位置(0是第一个位置)</p>                        <div class="codeMirror">                            <pre><xmp>var str="hello"var result=str.indexOf("h");console.log(result);result=str.indexOf("h",1);console.log(result);</xmp></pre>                        </div>                    </li>                    <li>lastIndexOf()方法用法和IndexOf()类似,不同的是检索字符时是从右到左检索,也可以指定开始查找的位置<br/>注意:虽然是从右往左检索,但是在设置第二个参数的时候指定开始查找的位置还是从左往右数的,只是查找的时候是从右往左</li>                </ul>                <p></p>                <h3 id="s8.5">8.5 strartsWith,endsWith与includes方法</h3>                <p></p>                <ul>                    <li>includes()：返回布尔值，表示是否找到了参数字符串，支持第二个参数，表示开始搜索的位置</li>                    <li>startsWith()：返回布尔值,表示参数字符串是否在查找字符串的头部,支持第二个参数，表示开始搜索的位置</li>                    <li>endsWith()：返回布尔值，表示参数字符串是否在查找字符串的尾部,一般用做后缀名判断,支持第二个参数，表示前n个字符,与前两个的表现形式不同</li>                    <div class="codeMirror">                        <pre><xmp>var str = 'Hello world!';str.startsWith('Hello') // truestr.endsWith('!') // truestr.includes('o') // truestr.startsWith('world', 6) // truestr.endsWith('Hello', 5) // truestr.includes('Hello', 6) // false</xmp></pre>                    </div>                </ul>                <p></p>                <h3>8.6 slice方法</h3>                <p></p>                <p>slice()方法可以从字符串中截取指定的内容,截取完成后会将截取到的字符串作为返回值返回</p>                <p></p>                <p>该方法有两个参数,第一个参数是开始位置,第二个参数是结束位置(但查找时不包括结束位置),可以不写第二个参数,这样会将从开始到后面所有的字符截取</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var str="hello";var result=str.slice(0,3);console.log(result);//返回hel(不包含索引为3的l)</xmp></pre>                </div>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>该方法只能从左往右边截取,如果第一个数比第二个数大,则会返回空串</li>                    <li>该方法接收负值,负值意味着从右往左数</li>                </ul>                <p></p>                <h3 id="s8.7">8.7 subString与substr方法</h3>                <p></p>                <ul>                    <li>subString()方法可以用来截取一个字符串，和slice()类似，也有两个参数,不同的是这个方法不能接收负值作 为参数，如果传递了一个负值，则默认变成0,而且它会自动调整参数的位置，如果第二个参数小于第二个，则 自动交换参数位置                    </li>                    <li>substr()方法也是用来截取字符串，该方法有两个参数,与slice()和subString()都不同,第一个参数是开始位置的索引，第二个参数是要截取的长度</li>                </ul>                <p></p>                <h3 id="s8.8">8.8 split方法</h3>                <p></p>                <p>split()方法可以将一个字符串拆分为一个数组,需要一个字符串作为参数，该方法将会根据字符串去拆分数组</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var str="abc,bcd,efg,hij"var result=str.split(",");//将str用,作为间隔去拆分字符串                                console.log(result);//result就变成了一个数组，第一个值是abc,第二个值是bcd</xmp></pre>                </div>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>如果传递一个空串作为参数，则会将每个字符都拆分为数组中的一个值</li>                    <li>如果不传入参数会返回一个只有一个整个字符串的值的数组</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>//split方法的妙用-->字符倒序 var str="abc";var result=str.spilt("").reserve().join("");console.log(result);//值为cbabcd</xmp></pre>                </div>                <p></p>                <h3 id="s8.9">8.9 toLowerCase与toUpperCase方法</h3>                <p></p>                <ul>                    <li>toLowerCase()方法将字符串转换为小写并返回</li>                    <li>toUpperCase()方法将字符串转换为大写并返回</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>var str="aBc";var result1=str.toLowerCase();console.lof(result1);//值为abcvar result2=str.toUpperCase();console.lof(result2);//值为ABC//这两种方法通常用做在进行无视大小写验证的时候使用</xmp></pre>                </div>                <p></p>                <h3 id="s8.10">8.10 valueOf方法</h3>                <p></p>                <div class="codeMirror">                    <pre><xmp>var str="abc";var result=str.valueOf();console.log(str===result);//true</xmp></pre>                </div>                <p></p>                <h3 id="s8.11">8.11 trim方法</h3>                <p></p>                <p>trim()方法用作删除字符串前后的空格(字符中间的空格不会删除),通常在用户输入验证的时候使用</p>                <p></p>                <ul>                    <li>直接使用,调用浏览器中的字符串自带的trim()方法(不兼容低版本IE)                        <div class="codeMirror">                            <pre><xmp>var str="12  3"var result=str.trim();console.log(result);//打印出12  3</xmp></pre>                        </div>                    </li>                    <li>间接使用,使用正则表达式                        <div class="codeMirror">                            <pre><xmp>function myTrim(x) &#123;    return x.replace(/^\s+|\s+$/gm,'');&#125;                                         var str = myTrim("Hello World!");alert(str);</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <h3 id="s8.12">8.12 repeat方法</h3>                <p></p>                <p>repeat()方法通过字符串调用,会返回一个新的字符串,该方法内传入的数值参数表示将该字符串复制几次,不会改变原字符串</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var str = "123";var str2 = str.repeat(2);var str3=str.repeat(0);console.log(str);//"123"console.log(str2);//"123123"console.log(str3);//""空字符串</xmp></pre>                </div>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>参数如果是浮点数,会向下取整</li>                    <li>参数是负值或是Infinity会报错</li>                    <li>参数为0到-1之间的小数等同于0，这是因为会先进行取整运算,0到-1之间的小数,取整以后等于-0,视同为0</li>                    <li>参数为NaN等同于0</li>                    <li>如果参数为字符串则会先转换为数值类型</li>                </ul>                <p></p>                <h3 id="s8.13">8.13 padStart与padEnd方法</h3>                <p></p>                <p>ES8(ES2017)中引入了字符串的补全功能,如果某个字符串不够指定长度,会在头部会尾部补全该字符串,不会改变原字符串</p>                <p></p>                <ul>                    <li>padStart()方法用于在头部补全</li>                    <li>padEnd()方法用于在尾部补全</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>var str="123";var str2=str.padStart(5,"ab");var str3=str.padEnd(5);console.log(str);//"123"console.log(str2);//"ab123"console.log(str3);//"123  "</xmp></pre>                </div>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>如果原字符串的长度等于或大于指定的最小长度,则返回原字符串</li>                    <li>如果用来补全的字符串与原字符串,两者的长度之和超过了指定的最小长度,则会截去超出位数的补全字符串</li>                    <li>如果省略第二个参数,默认使用空格补全长度</li>                </ul>            </div>            <div class="list" id="s9">                <h2>9.函数对象</h2>                <p></p>                <p>函数也是也是对象，函数中可以封装一些功能(代码)，在需要的时候执行,并且函数对象具有所有普通对象所具备的功能</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>//创建和使用函数function test()&#123;    console.log(1);&#125;//封装到函数中的代码不会立即执行，函数中的代码会在函数调用的时候执行//调用函数test();console.log(typeof test);//使用typeof检查一个函数对象时，会返回function,因为函数在js中占了很大的比重,所以把函数单独拿出来当做一个种类,实际上还是一个对象</xmp></pre>                </div>                <p></p>                <h3 id="s9.1">9.1 创建函数对象</h3>                <p></p>                <ul>                    <li>构造函数方法创建函数对象，将要封装的代码以字符串的形式传递给构造函数(不推荐使用这种方法)                        <div class="codeMirror">                            <pre><xmp>var fun=new Function("console.log('HELLO');");//这种构成函数的方法Function里面必须是用""括起来的字符串</xmp></pre>                        </div>                    </li>                    <li>函数声明方法创建函数对象                        <div class="codeMirror">                            <pre><xmp>/*语法:function 函数名([形参1，形参2])&#123;    功能片段&#125;形参的[]可以省略，在()里写上对应的变量，不用写var*/function fun()&#123;    console.log("HELLO");</xmp></pre>                        </div>                    </li>                    <li>函数表达式创建函数对象                        <div class="codeMirror">                            <pre><xmp>/*语法:var 函数名=function([形参])&#123;功能片段&#125;*/Var fun3=function()&#123;console.log("HELLO");&#125;;fun3();//上方相当于把一个函数赋值给了fun3</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>加括号是调用函数，相当于函数的返回值，不加括号是函数对象，相当于直接使用函数对象.把函数赋值给一 个变量时，只需要将函数名赋值过去,不要加后面的(),如果是没有返回值的函数就会把undefined赋值给变量,如 果有返回值就把返回值赋值给它,同时会运行函数                    </li>                    <li>调用函数时解析器不会检查实参的类型,注意是否有可能会接收到非法的参数，如果有可能则需要对参数类型 进行检查                    </li>                    <li>调用函数时也不会检查实参的数量，多余的实参不会被赋值，如果实参的数量少于形参的数量，则没有对应的 形参将会是undefined                    </li>                </ul>                <p></p>                <h3 id="s9.2">9.2 函数的返回值</h3>                <p></p>                <p>return返回一个返回值，在函数return后面的函数都不会执行,直接结束该函数</p>                <p></p>                <p>return后面可以跟任意数据类型,可以是一个对象,也可以是一个函数,如果return语句后不跟任何值就相当于返回 undefined，如果不写return也会返回undefined                </p>                <p></p>                <ul>                    <li>返回值为普通数据类型时</li>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>//如:定义一个函数，判断一个数字是否是偶数，如果是返回true，否则返回falsefunction isou(nume)&#123;    return num%2==0;&#125;console.log("result="+isou(15));</xmp></pre>                    </div>                    <li>返回值为函数时</li>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>//在一个函数内部可以无限次的嵌套函数，同时可以嵌套调用函数function fun1()&#123;    function fun2()&#123;console.log("123");&#125;    fun2();    &#125;fun1();//注意:因为fun2是在fun1里面创建的，所以只能在fun1里面用function fun3()&#123;function fun4()&#123;alert("hello");&#125;return fun4;&#125;a=fun3();console.log(a)//这时a是一个函数对象,可以通过a();fun4函数//同时还可以fun3()(); 这种写法和上面一样，只不过没有又创建一个对象</xmp></pre>                    </div>                </ul>                <p></p>                <h3 id="s9.3">9.3 函数的参数</h3>                <p></p>                <p>函数的参数分为实参和形参,形参是创建函数的时候写入,形参则是在调用函数的时候写入</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>//如果参数过多容易被弄混乱，可以将参数封装到一个对象中,在里面就可以用对象的值,只要属性名正确即可function fun(obj)&#123;alert(obj.name)&#125;var obj=&#123;name:"孙悟空",age:18&#125;fun(obj);//实参可以是一个对象，也可以是一个函数 function fun2(a)&#123;a(obj);&#125;fun2(fun);//在这个函数中a就是一整个fun函数,也就是函数赋值，把地址赋值给a//另一种写法:直接将函数传入fun2(function()&#123;alert("hello")&#125;); </xmp></pre>                </div>                <p></p>                <h4 id="s9.3.1">9.3.1 有初始值的形参</h4>                <p></p>                <p>在定义形参的时候为形参设置初始值(ES6新增语法)，在没有传入实参的情况下形参会默认地使用初始值</p>                <p></p>                <div class="codeMirror">                    <pre>                            <xmp>function fun(a=123)&#123;//因为是ES6的语法,所以这里的a是通过let方法声明的,与后边的作用域有很大联系    console.log(a);    &#125;fun();//打印出123</xmp></pre>                </div>                <p></p>                <h4 id="s9.3.2">9.3.2 封装实参的对象arguments</h4>                <p></p>                <p>在调用函数时,浏览器每次会传递两个隐含的参数(箭头函数没有这两个参数)</p>                <p></p>                <ul>                    <li>函数上下文对象this</li>                    <li>封装实参的对象arguments</li>                </ul>                <p></p>                <p>arguments是一个类数组对象，很数组很像但不是数组，它可以通过索引来操作数据，也可以用length获取长度，在调用函数时，我们所传递的实参都会在arguments中按照传入的顺序保存</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function fun()&#123;    console.log(arguments.length)        &#125;//可以用console.log(arguments.length)来查看函数的实参个数，如果没有实参长度就是0</xmp></pre>                </div>                <p></p>                <p>注意:即使不在创建函数的时候写形参，如果依然传入了实参,实参也会保留在arguments中，并且可以调用，</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>//argument中有一个属性callee，这个属性对应当前正在执行的函数对象    Function fun()&#123;        Console.log(arguments.callee===fun)//返回true    &#125;</xmp></pre>                </div>                <p></p>                <h4 id="s9.3.3">9.3.3 this</h4>                <p></p>                <p>this解析器在调用函数时传递给函数的一个参数,this指向的是一个对象,这个对象我们称为函数指向的上下文对象，根据函数的调用方式不同(跟创建方式无关)，this会指向不同的对象</p>                <p></p>                <p>this指向</p>                <p></p>                <ul>                    <li>以函数形式调用，this永远是window(非严格模式,严格模式是undefined,ES6中的class构造函数就是开启严格 模式)                        <div class="codeMirror">                            <pre><xmp>"use strict";//在最开头写上这段代码解析器自动开启严格模式解析function fun()&#123;    console.log(this);//undefined&#125;fun();</xmp></pre>                        </div>                    </li>                    <li>以方法的形式调用，this被调用的那个对象</li>                    <li>以构造函数的形式调用时，this就是创建的那个对象</li>                    <li>使用call和apply调用时，this就是指定的那个对象</li>                </ul>                <p></p>                <h4 id="s9.3.4">9.3.4 rest参数</h4>                <p></p>                <p>rest参数写在函数创建形参时的最后一位,用作收集剩余传入的实参,写法为...数组名</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function show(a, b, ...args)&#123;    console.log(a);    console.log(b);    console.log(args);&#125;show(1, 2, 3, 4, 5);//此时args为一个有着3,4,5值的数组</xmp></pre>                </div>                <p></p>                <div class="codeMirror">                    <pre><xmp>//rest参数还能用作展开数组,效果和将数组直接拆分开一样,这个用法很有用let arr1 = [1, 2, 3];let arr2 = [4, 5, 6];let arr3 = [...arr1, ...arr2];//相当于直接将arr1和arr2拆分开console.log(arr3);</xmp></pre>                </div>                <p></p>                <h4 id="s9.3.5">9.3.5 其他属性参数</h4>                <p></p>                <p>在函数创建时会默认传入很多的属性参数,这些参数通常情况下很少用</p>                <p></p>                <ul>                    <li>name属性,函数的名字,name属性是只读的,不能够修改</li>                    <li>arguments属性,这个属性同上面的arguments属性是一样的,只是用作了函数的属性来调用</li>                    <li>length属性,函数定义时形参的个数,但是不包括有默认值的形参和rest形参</li>                    <li>caller属性,说明调用者的属性(在下方实例进行说明)</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>fun1.name="fun3";//因为name属性时只读的,这行代码没有作用fun1(1,2,3,4);//fun1.name为"fun1",fun1.length为1,fun1.arguments.length为4console.dir(fun1);//console.dir可以显示一个对象的所有属性和方法                                fun2();//fun1.caller为"fun2"                                function fun1(x=0,y)&#123;    console.log(fun1.name);    console.log(fun1.arguments.length);//和arguments.length作用相同    console.log(fun1.length);    console.log(fun1.caller);&#125;function fun2()&#123;    fun1(1,2);//这里就是在fun2中调用fun1,fun1.caller就是"fun2"&#125;</xmp></pre>                </div>                <p></p>                <h3 id="s9.4">9.4 立即执行函数</h3>                <p></p>                <p>立即执行的函数都是通过函数表达式的方法声明的,所以叫作立即执行函数表达式(IIFE)</p>                <p></p>                <p>函数定义完成后，立即被调用，这种函数叫立即执行函数，立即执行函数往往只会执行一次</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>//第一种方式，函数用小括号包起来,然后后面加小括号(function(a,b)&#123;    console.log(a+b)&#125;)(10,1000);//必须要加一个()在前面将function()&#123;&#125;包起来.表示是一个整体，同时说明被括起来的部分是一个函数对象//后面跟()立即调用它，同时也可以带入参数进去//第二种方式，函数后面加用小括号,然后再用小括号包起来(function(a,b)&#123;    console.log(a+b)&#125;(10,1000));//第三种方式，函数后面加小括号,然后在函数前面加+ - ~ !其中一个符号+function(a,b)&#123;    console.log(a+b)&#125;(10,1000)-function(a,b)&#123;    console.log(a+b)&#125;(10,1000)~function(a,b)&#123;    console.log(a+b)&#125;(10,1000)!function(a,b)&#123;    console.log(a+b)&#125;(10,1000)</xmp></pre>                </div>                <p></p>                <p>立即执行函数的用处:将在一个script标签中写的代码通过一个立即执行函数包裹起来,可以避免污染全局环境</p>                <p></p>                <h3 id="s9.5">9.5 方法</h3>                <p></p>                <p>对象的属性值可以是任何数据类型，也可以是一个函数，如果一个函数作为一个对象的属性保存，那么我们称这个函数是这个对象的方法，调用用这个函数就是用这个对象的方法，但是这只是名称上的区别,并没有其他的区别</p>                <p></p>                <p>比如console.log()就是调用console对象的log方法</p>                <p></p>                <h3 id="s9.6">9.6 作用域</h3>                <p></p>                <p>作用域指一个变量的作用的范围,在JS中一共有三种作用域(ES5为两种,ES6有了块作用域,需要用let或const申明)</p>                <p></p>                <h4 id="s9.6.1">9.6.1 全局作用域</h4>                <p></p>                <p>直接编写在script标签的js代码，都在全局作用域中,全局作用域在页面打开时创建，在页面关闭时销毁</p>                <p></p>                <p>其他作用域可以访问到全局作用域中的变量.全局作用域不能访问其他作用域的变量</p>                <p></p>                <ul>                    <li>在全局作用域中有一个全局对象window,它代表一个浏览器的窗口，由浏览器创建，我们可以直接使用                        <p></p>                        <div class="codeMirror">                            <pre><xmp>//在全局作用域中，创建的变量都会作为window对象属性保存var a=10;console.log(window.a);//输出的结果依旧为10</xmp></pre>                        </div>                        <p></p>                    </li>                    <p>注意:window对象实际可以说是比全局作用域还要高一个层次,因为一个页面可以引入很多script标签,每个script标签中的全局环境是相互独立的,但是所有script标签都只有一个window</p>                    <p></p>                    <li>一个变量没有声明就使用会报错,但是如果通过作为window对象的属性来调用就不会报错,这个值会undefined                        <div class="codeMirror">                            <pre><xmp>console.log(a);//a没有被声明,会报错console.log(window.a)//返回undefined</xmp></pre>                        </div>                    </li>                    <li>无论什么作用域下,只要没有声明就使用的变量,会成为类似全局作用域的变量,因为没有声明就赋值的变量会泄 露出来,成为全局对象window的属性                        <div class="codeMirror">                            <pre><xmp><!--要特别注意全局变量泄露污染了全局变量window的环境--><script>a=10;//a泄露给window成为window的属性</script><script>console.log(a);//通过window访问到了另外一个全局作用域的a,这里不会报错</script></xmp></pre>                        </div>                    </li>                    <li>用var声明的全局变量也会成为window对象下的属性，而用ES6中的let和const则不会成为window的属性,但是这三者全都可以被其他script标签访问到</li>                    <li>使用函数声明方法创建的函数都会作为window的方法保存                        <div class="codeMirror">                            <pre><xmp> function fun()&#123;    alert(1);    &#125;window.fun();//用这种方法也能调用window.alert(123);/*alert()也是调用函数，所以alert也是一个函数对象，可以window.alert()，也可以alert()，这是浏览器自己创建的函数*/</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <h4 id="s9.6.2">9.6.2 函数作用域</h4>                <p></p>                <p>函数作用域是在function字样里的作用域,调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁</p>                <p></p>                <p>每调用一次函数就会创建一个新的函数作用域，它们之间互相独立的</p>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果没有，再在离得最近的一级作用域，直到 找到全局变量，如果全局作用域中没有找到，就会报错                    </li>                    <li>如果想直接在函数作用域中用全局的变量,使用window.a来调用(前提是用var或者直接写来声明的变量)</li>                    <li>在函数作用域中也有声明提前的特性，使用变量声明关键字声明的变量，会在函数中所有的代码执行之前被声 明，这个变量是在函数作用域中被声明的，同理在函数中声明的函数也是一样                    </li>                    <li>有参的函数在调用的时候不传入实参,形参的值是undefined,因为在定义形参的时候相当于在函数内部用var声 明了一个变量，没有赋值的变量一律为undefined,即使全局变量中有一样的变量也会用内部没有赋值的变量                    </li>                </ul>                <p></p>                <h4 id="s9.6.3">9.6.3 块作用域</h4>                <p></p>                <p>块作用域是在&#123;&#125;之内的作用域,块作用域的变量只能由ES6语法中的let和const创建</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>&#123;    let a=123;    &#125;console.log(a);//报错,只有var声明或者直接写的时候才能访问到</xmp></pre>                </div>                <p></p>                <p>注意:块级作用域中的变量使用条件和函数作用域基本相同,但是在使用时的情况会有所不同</p>                <p></p>                <p>块作用域的用处体现</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>for(let i=0;i<10;i++)&#123;    div.onclick=function()&#123;        console.log(i);    &#125;&#125;//打印出的是0到9for(var i=0;i<10;i++)&#123;    div.onclick=function()&#123;        console.log(i);    &#125;&#125;//打印出的是10个10</xmp></pre>                </div>                <p></p>                <h4 id="s9.6.4">9.6.4 声明提前</h4>                <p></p>                <h5 id="s9.6.4.1">9.6.4.1 变量的声明提前</h5>                <p></p>                <p>使用var关键词声明的变量,会在所有的代码执行之前被声明,而let和const不会</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>/*只写a变量不写var,则a相当于window.a，但是两者区别在于用var声明的变量能够声明提前*/console.log(a);//在这里会报错a=123;                                console.log(b);//这里不会报错而是会输出undefinedvar b=123;    //相当于var b;console.log(b);b=123;</xmp></pre>                </div>                <p></p>                <div class="codeMirror">                    <pre><xmp>console.log(c);let c=123;/*在c被用let声明赋值之前的一段区域叫作c的暂时性死区(TDZ)(这是ES6独有的),在这一个区域里面c是不允许被调用的,否则就会报错*///再如:let a=123;function(a=a)&#123;//报错    console.log(a);&#125;/*在设置形参的默认值时,会在()内临时形参一个作用域,由于找一个变量的时候会先在自身作用域中寻找,由于js的机制是先编译后执行的,所以先找到自身作用域中的a,但是a并没有被赋值就被使用,陷入了暂时性死区,所以会报错*/</xmp></pre>                </div>                <p></p>                <h5 id="s9.6.4.2">9.6.4.2 函数的声明提前</h5>                <p></p>                <p>使用函数声明形式创建的函数会在所有代码执行之前就被创建(在var声明的变量之后执行,所以在编译期用var声 明的变量与函数变量的变量名矛盾的时候函数的变量会将var声明的变量覆盖)，所以可以在函数声明前调用函数，                </p>                <p></p>                <p>这个形式声明的函数会默认放在当前作用域代码最上面</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>fun();//能正常打印123function fun()&#123;    console.log(123);&#125;</xmp></pre>                </div>                <p></p>                <p>使用函数的表达式创建的函数本身不会声明提前,只会先将用var创建的变量提前</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>fun2();//报错var fun2=function()&#123;    console.log(123);&#125;/*    使用函数表达式创建的函数只会先创建出变量,这个变量声明提前,但是此时的值是undefined,    而undefined不是一个函数,所以在调用的时候会报错*/ </xmp></pre>                </div>                <p></p>                <h3 id="s9.7">9.7 箭头函数</h3>                <p></p>                <p>箭头函数为ES6中函数的简写,省略了写function的形式,而改用=>来代替</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>// 普通函数function name() &#123;&#125;// 箭头函数,去掉 function,加上 =>() => &#123;&#125;</xmp></pre>                </div>                <p></p>                <div class="codeMirror">                    <pre><xmp>let show1 = function () &#123;    console.log('abc');&#125;let show2 = () => &#123;    console.log('abc');&#125;show1();show2();let show4 = function (a) &#123;    return a*2;&#125;/*1.如果只有一个参数,()可以省2.如果函数只有reutrn这一个句子,&#123;&#125;可以省*/let show5 = a => a * 2console.log(show4(10))console.log(show5(10))</xmp></pre>                </div>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象</li>                    <li>不可以当作构造函数，也就是说，不可以使用new命令，否则会报错</li>                    <li>不可以使用arguments对象，该对象在函数体内不存在,如果要用，用rest参数代替</li>                    <li>不可以使用yield命令，因此箭头函数不能用作Generator函数</li>                </ul>                <p></p>                <h3 id="s9.8">9.8 工厂方法创建对象</h3>                <p></p>                <p>使用工厂方法创建对象可以大批量的创建属性相同的对象</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function create(name,age,gender)&#123;Var obj=new Object();obj.name=name;obj.age=age;obj.gender=genderreturn obj;&#125;var obj1=create(name,age,gender);var obj2=create(name,age,gender);</xmp></pre>                </div>                <p></p>                <p>注意:使用工厂方法创建的对象，使用的构造函数都是Object，所以创建的对象都是Object这个类型，导致我们无 法区分出多种不同类型的对象，所以这个方法很少用,经常使用构造函数的方法                </p>                <p></p>                <h3 id="s9.9">9.9 构造函数</h3>                <p></p>                <p>使用构造函数创建函数,创建的函数和普通函数没有本质区别,只是构造函数习惯上首字母大写</p>                <p></p>                <p>构造函数和普通函数的本质区别是调用方式不同,普通函数是直接调用，而构造函数需要使用new关键字来使用,一般通过构造函数来实现面向对象编程</p>                <p></p>                <p>面向对象</p>                <p></p>                <p>JS通过原型链构成的模拟了类,通过这个模拟类我们可以实现面向对象编程(在ES6中被推出了class关键字,但是依然是通过原型链模拟出的类),但是并不是其它面对对象编程语言中的真正的类,所以一般我们说JS是一门基于对象的变成语言</p>                <p></p>                <p>面向对象的三大特征</p>                <p></p>                <ul>                    <li>封装，对象与对象之间相互独立,不会影响对方</li>                    <li>继承，能传递给子对象</li>                    <li>多态，传入不同的参数表现不同的效果</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>function Person(name)&#123;    this.name=name     &#125;            var per= new Person("孙悟空");console.log(per);//打印的是一个Person对象,如果不加new则per的值为undefined</xmp></pre>                </div>                <p></p>                <p>注意:new的构造函数后面加括号与不加括号的有区别,但无本质区别</p>                <p></p>                <p>构造函数的执行流程</p>                <p></p>                <ol>                    <li>立刻创建一个新的对象</li>                    <li>将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象</li>                    <li>执行函数中的代码</li>                    <li>将新建的对象作为返回值返回</li>                </ol>                <p></p>                <p>使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类，我们将通过一个构造函数的对象，称为是该类的实例</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>//可以使用instanceof可以检验一个对象是否是一个类的实例function Person(name)&#123;    this.name=name&#125;var per= new Person("孙悟空");console.log(per instanceof Person);//如果per是Person类的实例返回true，否则返回false  console.log(per instanceof Object);//所有的对象都是Object的后代，所有任何对象和Object与instanceof检验都会返回true</xmp></pre>                </div>                <p></p>                <p>在构造函数中定义方法</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function Person(name,age,gender)&#123;    this.name=name;    this.age=age;    this.gender=gender;    this.sayName=function()&#123;        alert("hello");    &#125;;&#125;    var per=new Person("孙悟空",18,"男");    //但是上面当调用方法的时候没调用一次就要重新创建一次方法，会影响性能        //使用下面的方法可以只用创建一次函数,节省了性能,但是将函数定义在全局作用域，污染了全局作用域的命名空间    this.sayNaem=fun;        funciton fun()&#123;    alert("hello");    &#125;;    //我们一般要为对象添加方法时都是通过给原型添加方法从而做到给这个对象添加方法</xmp></pre>                </div>                <p></p>                <h3 id="s9.10">9.10 函数原型对象prototype</h3>                <p></p>                <p>只有函数对象才有原型这个属性,每次创建函数时,解析器都会向函数中添加一个属性prototype,这个属性对应一个 对象，这个对象就是我们所谓的原型对象                </p>                <p></p>                <p>如果函数作为普通函数调用prototype没有任何作用,当函数以构造函数的形式调用时,它所创建的对象都会有一个隐含属性 proto ，指向改构造函数的原型对象prototype</p>                <p></p>                <p>注意:prototype只有函数才有，而一个对象是没有这个属性的,但是两者都有__ proto __,一个函数的prototype也 是通过构造函数创造的，用的是new Object()构造函数</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function Person(name,age,gender)&#123;    this.name=name;    this.age=age;    this.gender=gender;&#125;var per=new Person("孙悟空",18,"男");console.log(Person.prototype===per.__proto__);//返回true//证明构造函数的prototype属性和per的__proto__属性的指向是相同的</xmp></pre>                </div>                <p></p>                <p>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问这个原型对象，我们可以将对象中共有的内容，统一到原型对象中,但我们访问对象的一个属性或方法时，它会现在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function Person(name,age,gender)&#123;        this.name=name;        this.age=age;        this.gender=gender;    &#125;    //向Person的原型中添加属性a    Person.prototype.a=123;    //向Person的原型中添加方法sayName    Person.prototype.sayName=function()&#123;        alert("hello"+this.name);    &#125;    var per=new Person("孙悟空",18,"男");    console.log(per.a);    per.sayName();        /*    以后创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，    这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每一个对象都具有这些属性和方法    */</xmp></pre>                </div>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>通过原型对象添加的属性和方法函数本身是没有的,这就是静态方法和实例方法的区别</li>                    <li>在前面我们知道可以用 "属性名" in 对象 来检验对象中是否含有某个属性,但是如果对象自身没有该属性中但是原型对象中有该属性，也会返回true,所以为了区分是否是自己本身的属性,可以使用hasOwnProperty()方法来检查对象自身中是否含有该属性</li>                    <div class="codeMirror">                        <pre><xmp>function Person(name,age,gender)&#123;    this.name=name;    this.age=age;    this.gender=gender;&#125;Person.prototype.a=123;var per=new Person("孙悟空",18,"男");console.log("a" in per);//trueconsole.log(per.hasOwnProperty("a"));//false</xmp></pre>                    </div>                </ul>                <p></p>                <p>注意:</p>                <p></p>                <p>测试的对象自身并没有hasOwnProperty方法,并且该方法也不在它的原型中,而是在Object的原型中</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function Person(name,age,gender)&#123;    this.name=name;    this.age=age;    this.gender=gender;&#125;Person.prototype.a=123;var per=new Person("孙悟空",18,"男");console.log(per.hasOwnProperty("per.hasOwnPropert"));//false</xmp></pre>                </div>                <p></p>                <p>原因:</p>                <p>原型对象也是一个对象，说明也有一个原型 proto ，当我们使用一个对象的属性或者方法的时候，会先在自身中寻找，如果有则直接使用，如果没有则去原型对象中寻找，如果原型对象中有，则使用，如果没有则去原型的原型中寻找，直到找到Object对象的原型，Object对象的原型没有原型，如果在Object中依然没有找到，则返回undefined</p>                <p></p>                <p></p>                <h3 id="s9.11">9.11 继承</h3>                <p></p>                <h4 id="s9.11.1">9.11.1 组合继承</h4>                <p></p>                <p>原型可以只通过构造函数再次获得继承,能够继承父级别的方法,但是这样有缺陷，每一次在设置属性的时候都需要再次设置相同的属性,而且如果通过父类的原型设置属性容易造成值重复的情况(这种方式还会造成数据共享)</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function Person(name, age, gender) &#123;    this.name = name;    this.age = age;    this.gender = gender;&#125;Person.prototype.sayHello=function()&#123;    alert("hello");&#125;Person.prototype.name="孙悟空";/*下面这种写法更加简便Person.prototype=&#123;sayHello:function()&#123;alert("hello");&#125;,name="孙悟空"&#125;*/function Student(name,age,gender,grade)&#123;//在这里因为是设置了name属性,如果没有设置所有通过  this.name = name;//Student类创建的对象的name都是孙悟空    this.age = age;    this.gender = gender;    this.grade.grade&#125;Student.prototype=new Person();//虽然这样Student类能继承Person类的sayHello方法,但是需要再设置//属性</xmp></pre>                </div>                <p></p>                <p>解决方案:</p>                <p></p>                <ul>                    <li>继承属性使用父类.call(参数)</li>                    <li>通过函数的原型相同实现继承方法</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>function Person(name, age, gender) &#123;    this.name = name;    this.age = age;    this.gender = gender;&#125;Person.prototype.sayHello=function()&#123;    alert("hello");&#125;function Student(name,age,gender,grade)&#123;  Person.call(this,name,age,gender);//解决了属性继承，并且值不重复的问题    this.grade=grade;&#125;Student.prototype=Person.prototype;//虽然能继承到父类的方法,但是却将两者的内存统一了,如果修改子类的prototype父类的protptype也会变化</xmp></pre>                </div>                <p></p>                <p>解决方案:</p>                <p></p>                <ul>                    <li>继承属性使用父类.call(参数)</li>                    <li>对原型使用构造函数</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>function Person(name, age, gender) &#123;    this.name = name;    this.age = age;    this.gender = gender;&#125;Person.prototype.sayHello=function()&#123;    alert("hello");&#125;function Student(name,age,gender,grade)&#123;  Person.call(this,name,age,gender);    this.grade=grade;&#125;Student.prototype=new Person();/*虽然这样基本不会影响效果,但是在观察一个由子类创建的对象可以发现虽然子类上继承的属性有正确的属性值,但是其父类上依旧显示有该属性,并且该属性的属性值为undefined,会造成属性结构的杂乱*/</xmp></pre>                </div>                <p></p>                <p>最终解决方案:</p>                <p></p>                <ul>                    <li>继承属性使用父类.call(参数)</li>                    <li>借助一个无用的构造函数</li>                    <li>对原型使用无用的构造函数</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>function Person(name, age, gender) &#123;    this.name = name;    this.age = age;    this.gender = gender;&#125;Person.prototype.sayHello=function()&#123;    alert("hello");&#125;function Student(name,age,gender,grade)&#123;  Person.call(this,name,age,gender);    this.grade=grade;&#125;function Exchange()&#123;    &#125;Exchange.prototype=Person.prototype;//用无用的构造函数的prototype来指向Person的prototypeStudent.prototype=new Exchange();</xmp></pre>                </div>                <p></p>                <p>也可以用Object.create()方法来继承原型,同时也不会造成结构杂乱</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function Person(name, age, gender) &#123;    this.name = name;    this.age = age;    this.gender = gender;&#125;Person.prototype.sayHello=function()&#123;    alert("hello");&#125;function Student(name,age,gender,grade)&#123;  Person.call(this,name,age,gender);    this.grade=grade;&#125;Student.prototype = Object.create(Person.prototype);</xmp></pre>                </div>                <p></p>                <p>注意:在继承的时候需要重新设置一下constructor,使用A.prototype.constructor=A来设置</p>                <p></p>                <p>为什么需要做A.prototype.constructor=A这样的修正?</p>                <p></p>                <ul>                    <li>在构造函数时new 函数名() 本质上是通过函数原型中的constructor()构造函数方法(该方法是创建函数时就有的属性),所以new 函数名()和new 函数名.prototype.construstor()是一样的效果                        <div class="codeMirror">                            <pre><xmp>function Person(name, age, gender) &#123;    this.name = name;    this.age = age;    this.gender = gender;&#125;var per = new Person.prototype.constructor("孙悟空", 18, "男");console.log(per);</xmp></pre>                        </div>                    </li>                    <li>在原型继承的时候,我们将上级函数的实例赋值给了下级函数的原型,所以就会造成下级函数原有的原型发生彻底的改变。因为constructor属性是原型默认的两个属性之一。该属性在正常情况下是等于其对应的函数本身的。但是在实现原型继承之后,下级函数的constructor属性就会发生改变,变为了等于上级函数本身。但是如果我们不进行修正的话也可以正常使用,不会发生什么问题。那么我们修正这个constructor属性就只是为了防止一种情况下出错:在不知道某个对象是哪个函数实例化的时候想要克隆一个对象                        <div class="codeMirror">                            <pre><xmp>//例如,我不知道person对象是在哪个函数实例化出来的,但是我想克隆一个,这时候就可以这样function Person(name, age, gender) &#123;    this.name = name;    this.age = age;    this.gender = gender;&#125;function Student(name,age,gender,grade)&#123;Person.call(this,name,age,gender);this.grade=grade;&#125;function Exchange()&#123;&#125;Exchange.prototype=Person.prototype;Student.prototype=new Exchange();Student.prototype.constructor=Student;var stu= new Student("孙悟空", 18, "男",100);var stu1 = new stu.constructor();//而如果在继承时没有通过重新设置construct,那么克隆后的对象                             //就相当于是通过new Person()创建的,没有grade属性//可以写一个继承方法function extend(child,parent)&#123;child.prototype=new parent();child.prototype.constructor=child;&#125;</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <h4 id="s9.11.2">9.11.2 拷贝继承</h4>                <p></p>                <p>通过拷贝将函数原型中的属性和方法复制,达到继承的目的</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function Person(name, age, gender) &#123;    this.name = name;    this.age = age;    this.gender = gender;&#125;Person.prototype.sayHello=function()&#123;    alert("hello");&#125;Person.prototype.a=123;function Student(name,age,gender,grade)&#123;    Person.call(this,name,age,gender);    this.grade=grade;&#125;//子类拷贝父类原型继承父类原型方法for(var key in Person.prototype)&#123;    Student.prototype[key]=Person.prototype[key];&#125;var obj=&#123;&#125;; for(var key in Person.prototype)&#123;    obj[key]=Person.prototype[key];&#125;console.log(obj);console.log(obj.a);//123obj.sayHello();</xmp></pre>                </div>                <p></p>                <p>上面的方式是浅拷贝,虽然能够获得相同的值,该对象中对象或数组的值的地址并没有发生改变,还是被拷贝者的地址在ES6中Object.assign()的效果和浅拷贝的效果相同,但该函数可以继承多个类</p>                <p></p>                <p></p>                <p>Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象并返回目标对象,可以放入多个参数,第一个是要被放入的对象,可以直接一个空对象,后面的参数是要拷贝的对象，可以传入多个对象把所有对象的属性或者方法都传入到前面的空对象里，最后将结果返回出来</p>                <p></p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function MyClass() &#123;    SuperClass.call(this);    OtherSuperClass.call(this);   &#125;   // 继承一个类   MyClass.prototype = Object.create(SuperClass.prototype);   // 混合多个类的继承类   Object.assign(MyClass.prototype, OtherSuperClass.prototype);   // 重新指定constructor   MyClass.prototype.constructor = MyClass;   MyClass.prototype.myMethod = function() &#123;         &#125;;</xmp></pre>                </div>                <p></p>                <div class="codeMirror">                    <pre><xmp>const object1 = &#123;    a: 1,    b: 2,    c: 3&#125;;    const object2 = Object.assign(&#123;c: 4, d: 5&#125;, object1);//实际上这种叫做根元素深复制,其他元素浅    console.log(object2.c,object2.d);//3,5//复制</xmp></pre>                </div>                <p></p>                <p>注:</p>                <p></p>                <ul>                    <li>如果只有一个参数,该函数会直接返回该参数</li>                    <li>如果传入null和undefined作为参数会报错,因为null和undefined无法被转换为对象</li>                    <li>该函数可以用来处理数组,但是会把数组视为对象</li>                    <li>可以用扩展运算符(...)来对一个对象进行拷贝</li>                </ul>                <p></p>                <p>如果想要地址也不同就要进行深拷贝,深拷贝是将重新开辟空间进行复制</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>//这里是别人直接写的方法,拿过来引用    function deepClone(obj)&#123;        let objClone = Array.isArray(obj)?[]:&#123;&#125;;//Array.isArray()函数可以低版本IE不兼容,可以用        if(obj && typeof obj==="object")&#123;//obj instanceof Array来判断是否为数组            for(key in obj)&#123;                if(obj.hasOwnProperty(key))&#123;                    //判断ojb子元素是否为对象，如果是，递归复制                    if(obj[key]&&typeof obj[key] ==="object")&#123;                        objClone[key] = deepClone(obj[key]);                    &#125;else&#123;                        //如果不是，简单复制                        objClone[key] = obj[key];                    &#125;                &#125;            &#125;        &#125;        return objClone;    &#125;</xmp></pre>                </div>                <p></p>                <p>用JSON进行深拷贝(这种拷贝不支持函数)</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var obj=&#123;a:1,b:[0,1]&#125;;var json=JSON.parse(JSON.stringify(obj));json.b.push(2);console.log(obj);//&#123;a:1,b:[0,1]&#125;;console.log(json);//&#123;a:1,b:[0,1,2]&#125;;</xmp></pre>                </div>                <p></p>                <p>兼容深浅拷贝</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>//obj为拷贝对象,deep是一个布尔值,默认是flase代表浅拷贝,true代表深拷贝function extend(obj,deep)&#123;//因为不传是undefined转布尔值为false    var objClone=(obj instanceof Array)?[]:&#123;&#125;;    if(obj && typeof obj==="object")&#123;        for(key in obj)&#123;            if(obj.hasOwnProperty(key))&#123;             if(!!deep&&obj[key]&&typeof obj[key] ==="object")&#123;                objClone[key] = extend(obj[key]);              &#125;else&#123;                objClone[key] = obj[key];            &#125;               &#125;        &#125;    &#125;   return objClone;&#125;</xmp></pre>                </div>                <p></p>                <h3 id="s9.12">9.12 call,apply与bind方法</h3>                <p></p>                <p>这三个方法都是函数对象的方法，需要通过函数对象来使用</p>                <p></p>                <ul>                    <li>call()与apply()方法<br/>当对函数调用call()和apply()方法时都会调用函数执行，在调用call()和apply()可以将一个对象指定为第一个参数，此时函数执行时的this将会指向该对象                        <div class="codeMirror">                            <pre><xmp>function fun()&#123;    console.log(this);&#125;var obj=&#123;name:"孙悟空"&#125;; var obj2=&#123;name:"猪八戒"&#125;;            fun.call(obj);//this指向objfun.apply(obj2);//this指向obj2fun();//this永远指向window            /*    如果是在通过一个对象运用该对象的方法时在call()或者apply()中指定了其他的对象,    this就会变成其他的对象而不会是原来的对象了*/  </xmp></pre>                        </div>                    </li>                    <p></p>                    <p>call()与apply()方法的区别</p>                    <ul>                        <li>call()方法传递实参只需要在第一个参数后面依次用,(逗号)隔开                            <div class="codeMirror">                                <pre><xmp>var obj=&#123;num:1&#125;;function fun(number1,number2)&#123;    console.log(this,num+number1+number2);&#125;fun.call(obj,10,20);//31</xmp></pre>                            </div>                        </li>                        <li>apply()方法需要将实参封装到一个数组中统一传递                            <div class="codeMirror">                                <pre><xmp>var obj=&#123;num:1&#125;;function fun(number1,number2)&#123;    console.log(this,num+number1+number2);&#125;fun.apply(obj,[10,20]);//31</xmp></pre>                            </div>                        </li>                    </ul>                </ul>                <p></p>                <p>小应用:使用Object.prototype.toString.call(obj)能够判断一个对象是否为某一类型对象</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function getFunc(type)&#123;        return function(obj)&#123;            return Object.prototype.toString.call(obj)===type;        &#125;    &#125;        var fun=getFunc("[object Array]");    var result=fun([10,20,30]);    console.log(result);//true        var fun=getFunc("[object Objcet]");    var dt=new Date();    var result1=fun(dt);    console.log(result1);//false</xmp></pre>                </div>                <p></p>                <ul>                    <li>bind()方法<br/>bind()方法能够复制一个函数或方法,并将赋值后的函数或方法返回,在赋值时可用传入了对象作为复制的函数中的this指向(该方法不兼容IE8及以下浏览器)</li>                    <p>注意:</p>                    <ul>                        <li>传入实参可以在复制的时候传入.也可以在调用的时候传入</li>                        <li>与call()和apply()方法不同,使用了bind方法只会将复制后的函数作为返回值传递回来,并不会调用函数</li>                    </ul>                    <div class="codeMirror">                        <pre><xmp>function Person(age)&#123;            this.age=age;        &#125;        Person.prototype.play=function()&#123;            console.log(this);            console.log(this.age);        &#125;                function Student(age)&#123;            this.age=age;        &#125;        var per=new Person(10);        var stu=new Student(20)；                var fun=per.play.bind(stu);        fun();//this指向为stu,this.age的值为20</xmp></pre>                    </div>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>function f1(x,y)&#123;            console.log(x+y)；            &#125;            var ff=f1.bind(null,10,20)//在复制的时候传入实参            ff();            Var ff=f1.bind(null);            ff(10,20);//在调用的时候传入参数</xmp></pre>                    </div>                    <p></p>                    <p>bind()的应用</p>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>function showRandom()&#123;    //产生1-10的随机数    this.number=parseInt(Math.random()*10+1);&#125;    //添加原型方法    showRandom.prototype.show1=function()&#123;        //改变了定时器中的this执行,本来是window,现在为实例对象        window.setInterval(this,show2.bind(this),1000);    &#125;    //显示随机数    showRandom.prototype.show2=function()&#123;        console.log(this.number);    &#125;            var num=new showRandom();    num.show1();        //定时器只有在调用函数里面的时候才会把里面的this改为window，而传了一个关于this的函数其实是先用了这个属性再开的定时器</xmp></pre>                    </div>                    <p></p>                    <p>兼容代码</p>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>if(!Function.prototype.bind)&#123;            Function.prototype.bind=function()&#123;                var bindThis=arguments[0];                var arg=[].slice.call(arguments,1);                var that=this;                return function()&#123;                    that.apply(bindThis,arg);                &#125;            &#125;        &#125;</xmp></pre>                    </div>                    <p></p>                    <h3 id="s9.13">9.13 闭包</h3>                    <p></p>                    <ul>                        <li>闭包的概念:函数A中,有一个函数B,函数B中可以访问函数A中定义的变量或者数据,此时形成了闭包(这句话暂时不严谨)</li>                        <li>闭包的模式:分为函数模式的闭包和对象模式的闭包(函数中有一个对象)</li>                        <li>闭包的作用:缓存数据,延迟作用域链,闭包使用的父函数的变量或参数会被永久保存,直到页面关闭</li>                        <li>闭包的优点和缺点:缓存数据(优点也是缺点,没有及时的释放数据)<br/>局部变量在函数中被函数使用后会被自动的释放,而闭包后,里面的局部变量的使用作用域链就会被延长</li>                        <li>闭包的形成条件:<br/>如果满足以下两点,那么可以把内部函数称为闭包</li>                        <ul>                            <li>函数嵌套函数</li>                            <li>内部函数使用父函数的变量或参数</li>                        </ul>                    </ul>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>//函数模式的闭包//例一function f1(num)&#123;    function f2()&#123;        console.log(++num);//11,因为f2在f1的函数作用域里面,所以f2能用f1传入的参数    &#125;    f2()&#125;f1(10);//10//例二2document.onclick=(function()&#123;    var a=0;    return function()&#123;        console.log("第”+ ++a +“次点击页面");    &#125;&#125;)()//对象模式的闭包function f3()&#123;    var num=10;    var obj=&#123;     age:num;       &#125;    console.log(obj.age);&#125;f3();//10</xmp></pre>                    </div>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>//案例:输出三个相同的随机数function fun()&#123;    var num=parseInt(Math.random()*10+1)；    return function()&#123;        console.log(num);    &#125;&#125;var fun2=fun();//下面输出的结果全部相同fun2();fun2();fun2();</xmp></pre>                    </div>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>//案例:输出阶乘function fun()&#123;    var obj=&#123;&#125;;            return function f(n)&#123;                var num=n+"!";                if(obj[num])&#123;                    return obj[num];                &#125;else if(n=1)&#123;                    obj[num]=1;                    return 1;                &#125;else&#123;                    obj[num]=n*f(n-1)                    return obj[num];                &#125;            &#125;    &#125;        var fun1=fun();        console.log(fun1(10));        console.log(fun1(9));        console.log(fun1(11));/*在计算10的阶乘时会用一定时间,然后会在obj内部储存着1到10的所有阶乘,这时就相当于数据缓存,在计算9和11的阶乘的时候运行速度更快*/</xmp></pre>                    </div>                    <p></p>                    <p>总结:如果想要缓存数据,就把这个数据放在外层函数和里层函数的中间位置</p>                    <p></p>                    <h3 id="s9.14">9.14 垃圾回收(GC)</h3>                    <p></p>                    <p>垃圾积攒过多会导致程序运行的速度过慢，所以需要一个垃圾回收机制</p>                    <p></p>                    <p>当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，此时这种对象就像一个垃圾， 会占用大量内存空间，导致程序运行变慢，在JS中拥有自动的垃圾回收机制，会自动回收,但是如果有一个变量或 属性还占用着这个对象.这个对象就不会被自动回收,所有我们需要将不再使用的对象设置为null来解放该对象</p>                    <p></p>                    <p></p>                    <p>JS的内存回收机制</p>                    <p></p>                    <p>一个函数在执行开始的时候,会给其中定义的变量划分内存空间保存,以备后面的语句所用,等到函数执行完毕返回了,这些变量就被认为是无用的了，对应的空间也就被回收了。下次再执行此函数的时候，所有的变量又回到最初的状态，重新赋值使用。</p>                    <p></p>                    <p></p>                    <p>但是如果这个函数内部又嵌套了另一个函数(这就是闭包了)，而这个函数是有可能在外部被调用到的。并且这个内部函数又使用了外部函数的某些变量的话.这种内存回收机制就会出现问题。如果在外部函数返回后，又直接调用了内部函数，那么内部函数就无法读取到他所需要的外部函数中变量的值了。</p>                    <p></p>                    <p></p>                    <p>所以js解释器在遇到函数定义的时候会自动把函数和他可能使用的变量(包括本地变量和父级和祖先级函数的变量(自由变量))一起保存起来。也就是构建一个闭包，这些变量将不会被内存回收器所回收，只有当内部的函数不可能被调用以后(例如被删除了,或者没有了指针)，才会销毁这个闭包,而没有任何一个闭包引用的变量才会被下一次内存回收启动时所回收。</p>                    <p></p>                    <p></p>                </ul>            </div>            <div class="list" id="s10">                <h2>10.Date对象</h2>                <p></p>                <p>在js中使用Date对象来表示一个时间对象,Date可以作为构造函数,也可以作为一个普通对象使用</p>                <p></p>                <h2 id="s10.1">10.1 创建一个Date对象</h2>                <p></p>                <ul>                    <li>如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间                        <div class="codeMirror">                            <pre>                                    <xmp>var d=new Date();console,log(d)//打印出当前执行到该时刻时的时间(以地区时间为准)</xmp></pre>                        </div>                    </li>                    <li>创建一个指定的时间对象<br/>需要在构造函数中传递一个表示时间的字符串作为参数                        <div class="codeMirror">                            <pre><xmp>//格式：月/日/年 时间(比如12:31:30表示12点31分30秒)var dt=new Date("2/15/2019 12:31:30");//所有设置年月日前面都可以加0或者不加如02/15/2019console.log(dt);//Fri Feb 15 2019 12:31:30</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>new Date()获取的时间对象通过toString()方法可以完全转换为一个字符串</li>                    <li>通过Date.parse()函数可以将传入的字符串参数转换为一个日期对象</li>                </ul>                <p></p>                <h3 id="s10.2">10.2 Date对象的方法</h3>                <p></p>                <h4 id="s10.2.1">10.2.1 getDate方法</h4>                <p></p>                <p>getDate()方法获取当前日期对象是该月中的第几日</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var date=new Date("2/15/2019 12:31:30");var day=date.getDate();console.log(day);//15</xmp></pre>                </div>                <p></p>                <h4 id="s10.2.2">10.2.2 getDay,getMonth与getFullYear方法</h4>                <p></p>                <ul>                    <li>getDay()方法获取当前日期是周几,该方法的返回值为0-6(0为周日),1-6依次为周一到周六                        <div class="codeMirror">                            <pre><xmp>var date=new Date("2/15/2019 12:31:30");var week=date.getDay();console.log(week);//5</xmp></pre>                        </div>                    </li>                    <li>getMonth()方法获取当前日期月份,该方法的返回值为0-11(0为一月),依次向后排序                        <div class="codeMirror">                            <pre><xmp>var date=new Date("2/15/2019 12:31:30");var month=date.getMonth();console.log(month);//1</xmp></pre>                        </div>                    </li>                    <li>getFullYear()方法获取当前日期年份                        <div class="codeMirror">                            <pre><xmp>var date=new Date("2/15/2019 12:31:30");var year=date.getFullYear();console.log(year);//2019</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <h3 id="s10.2.3">10.2.3 getHours,getMinutes,getSeconds与getMilliseconds方法</h3>                <p></p>                <ul>                    <li>getHours()方法获取当前日期的小时数</li>                    <li>getMinutes()方法获取当前日期的分钟数</li>                    <li>getSeconds()方法获取当前日期的秒数</li>                    <li>getMilliseconds()获取当前日期的毫秒数</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>var date=new Date("2/15/2019 12:31:30");var hour=date.getHours();var minute=date.getMinutes();var second=date.getSeconds();var millscecond=date.getMilliseconds();console.log(hour);//12console.log(minute);//31console.log(second);//30console.log(millsecond);//0,因为没有设置,在这里默认是0</xmp></pre>                </div>                <p></p>                <h3 id="s10.2.4">10.2.4 getTime方法</h3>                <p></p>                <p>getTime()方法获取当前日期对象的时间差,就是自格林威治标准时间的1970年1月1日0时0分0秒到现在的是 所经历的毫秒数(因为计算机底层报错时间就是用的毫秒)                </p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var date=new Date("2/15/2019 12:31:30");var time=date.getTime();console.log(time);//1550205090123</xmp></pre>                </div>                <p></p>                <p>注:如果想要具体到秒,分或者时,只需要将返回的值除以各自相对于毫秒的倍数即可</p>                <p></p>                <p>注意:如果我们(在中国)用new Date()创建对象时传入的日期是1970年1月1日0时0分0秒,用getTime()方法也会返回 一个负数(-28800000),因为我们输入的时间默认是北京时间,相对于标准时间有8个小时的提前时差                </p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var date=new Date("1/1/1970 0:0:0");var time=date.getTime();console.log(time);//-28800000</xmp></pre>                </div>                <p></p>                <h4 id="s10.2.5">10.2.5 getTimezoneOffset方法</h4>                <p></p>                <p>getTimezoneOffset()方法获取当前地区相对于世界时的时间差,该方法会返回一个数字,单位为分钟</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var date=new Date();var time=date.getTimezoneOffset();//世界时-本地时间=-8*60 分钟console.log(time);//-480,因为本地时间比世界时快</xmp></pre>                </div>                <p></p>                <h3 id="s10.3">10.3 Date.now函数</h3>                <p></p>                <p>Date.now()函数能够获取当前时刻距离格林威治标准时间的1970年1月1日0时0分0秒的时间差,是一个静态方法, 通常用作测试代码的执行性能(在代码前后分别设置事件作差值)                </p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var time=Date.now();console.log(time);</xmp></pre>                </div>            </div>            <div class="list" id="s11">                <h2>11.Math对象</h2>                <p></p>                <p>Math不是一个构造函数,只是一个普通对象,Math对象中包含了许多数学方法</p>                <p></p>                <p>所有方法通过Math.方法名()来使用;</p>                <p></p>                <p>在这里只列举了一些常用数学方法</p>                <p></p>                <ul>                    <li>abs()取绝对值</li>                    <li>sqrt()计算开方,得到算术平方根</li>                    <li>ceil()可以对一个数进行向上整数，小数位是要有值就会自动进一位</li>                    <li>floor()可以对一个数进行向下取整，小数部分会被舍掉</li>                    <li>round()可以对一个数进行四舍五入</li>                    <li>max(x,y,z)可以获取多个数中的最大值</li>                    <li>min(x,y,z)可以获取多个数中的最小值</li>                    <li>pow(x,y)返回x的y次幂</li>                    <li>trunc()方法用于去除一个数的小数部分,返回整数部分<br/>注意:</li>                    <ul>                        <li>该方法对于大于0的数时向下取整,对于小于0的数是向上取整</li>                        <li>对于非数值会先进行强制类型转换,对于空值或无法取整的值会返回NaN</li>                    </ul>                    <li>sign()方法用来判断一个数是正数,负数,还是0,如果是非数值会先进行强制类型转换<br/>五种返回值</li>                    <ul>                        <li>参数为正数,返回+1</li>                        <li>参数为负数,返回-1</li>                        <li>参数为0,返回0</li>                        <li>参数为-0,返回-0</li>                        <li>参数为其他值,返回NaN</li>                    </ul>                    <li>cbrt()方法用于计算一个数的立方根,非数值会进行强制类型转换</li>                    <li>hypot()返回所有参数的平方和的平方根,用法相当于用勾股定理已知两直角边求斜边                        <div class="codeMirror">                            <pre><xmp>console.log(Math.hypot(3,4));//5console.log(Math.hypot(3,4,5));//7.0710678118654755console.log(Math.hypot());//0,不传参数返回值为0console.log(Math.hypot(NaN));//NaNconsole.log(Math.hypot(3,4,"num"));//NaNconsole.log(Math.hypot("3","4"));//5console.log(Math.hypot(-3,-4));//5</xmp></pre>                        </div>                    </li>                    <li>random()可以生成一个0-1之间[0,1)的随机数</li>                    <ul>                        <li>生成一个0-X之间的随机数Math.random()X</li>                        <li>生成一个X-Y之间的随机数Math.random()(Y-X)+X</li>                    </ul>                    <div class="codeMirror">                        <pre><xmp>//生成一个0-10的随机数var num1=Math.random()*10console.log(num1);//如果要取整可以四舍五入 console.log(Math.round(num1));</xmp></pre>                    </div>                    <li>保留几位小数用toFixed()方法,这个方法不是Math对象调用,而是原来的数值对象调用,参数为具体数值,并将会进行四舍五入<br/>注意:该方法内部是用的银行的四舍五入算法,和普通的四舍五入不同(具体的银行四舍五入算法请私下了解)</li>                    <div class="codeMirror">                        <pre><xmp>var num=0.95;var num2=1.35;console.log(num.toFixed(1));//0.9,代表保留一位小数console.log(num2.toFixed(1));//1.4</xmp></pre>                    </div>                </ul>            </div>            <div class="list" id="s12">                <h2>12.包装类</h2>                <p></p>                <p>js中为我们提供了三个包装类，通过这三个包装类可以将基本的数据类型转换为对象</p>                <p></p>                <p>这三个包装类分别为String(),Number()和Boolean()</p>                <p></p>                <p>对于包装类的举例</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var num=new Number(3)//这样就能把基本数据类型number转换为一个对象,3依然是num的值，这样做能为num添加属性/*注意:1.如果为一个基本数据类型添加属性虽然不会报错但是不会添加成功2.如果在创建number类型的时候用了包装类,那么两个相同的值比较也就不再相等,因为开辟了两片空间,地址不同*/</xmp></pre>                </div>                <p></p>                <p>注:在实际开发中我们不会使用包装类创建对象，如果使用这种基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果</p>                <p></p>                <p>包装类的用途</p>                <p></p>                <p>浏览器会自己调用包装类的方法，当我们对一些基本数据类型的值调用属性和方法时，浏览器会临时使用包装类将其转换为对象，然后调用对象的属性和方法，调用完以后又转换回来</p>                <p></p>                <p>对基本数据类型添加属性或方法的解释</p>                <p></p>                <p>给一个基本数据类型添加属性或方法就是将该类型的值转换为对象，其实属性添加进去了，但是因为临时转换，又转换为基本数据类型，然后销毁了属性或方法</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var num=1;num.say="hello";//这时确实进行了类型转换但是又马上转换回来销毁了say属性    console.log(num.say);//undefined/*第二次使用该属性时其实是又临时转换了类型,但是由于每次转换都是新建一个对象,所以第二次转换的对象和第一次的对象不同,这个对象没有添加say属性,所以返回的值为undefined*/</xmp></pre>                </div>            </div>            <div class="list" id="s13">                <h2>13. 正则表达式</h2>                <p></p>                <p>正则表达式用于定义一些字符串的规则,计算机可以根据正则表达式，来检查一个字符串是否符合规则,获取字符串中符合规则的内容</p>                <p></p>                <p>基本概念</p>                <p></p>                <ul>                    <li>正则表达式是由一个字符序列形成的搜索模式</li>                    <li>当在文本中搜索数据时，可以用搜索模式来描述要查询的内容</li>                    <li>正则表达式可以是一个简单的字符，或一个更复杂的模式</li>                    <li>正则表达式可用于所有文本搜索和文本替换的操作</li>                </ul>                <p></p>                <h3 id="s13.1">13.1 创建正则表达式对象</h3>                <p></p>                <p>正则表达式实质上也是一个对象</p>                <p></p>                <ul>                    <li>构造函数创建正则表达式对象<br/>语法:var 变量=new RegExp("正则表达式","匹配模式")                        <div class="codeMirror">                            <pre><xmp>var reg=new RegExp("a");//可以不传入匹配模式</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <p>正则表达式对象可以使用test()方法可以用来检查一个字符串是否符合正则表达式的规则,如果符合返回true，否则返回false</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var reg=new RegExp("a");var str="a";var str1="A"；var result=reg.test(str);var result=reg.test(str1);console.log(result);//trueconsole.log(result);//false//这种正则表达式可以检查一个字符串中是否含有a，严格区分大小写，如果不区分大小写可以传入第二个参数</xmp></pre>                </div>                <p></p>                <p>匹配模式</p>                <p>正则表达式中有三种匹配模式</p>                <ul>                    <ul>                        <li>i 忽略大小写匹配</li>                        <li>g 全局匹配(查找所有匹配而非在找到第一个匹配后停止)</li>                        <li>m 多行匹配,作用是修改和$在正则表达式中的作用,让它们分别表示行首和行尾,在默认情况下,一个字符串无论是否换行只有一个开始和结尾$,如果采用多行匹配,那么每一行都有一个^和$</li>                        <p>注:三种匹配模式可以同时使用,写法与顺序无关</p>                        <div class="codeMirror">                            <pre><xmp>var reg=new RegExp("a","i")//不区分大小写avar str="a";var str1="A"；var result=reg.test(str);var result=reg.test(str1);console.log(result);//trueconsole.log(result);//true</xmp></pre>                        </div>                    </ul>                    <li>使用字面量创建正则表达式<br/>语法:var 变量=/正则表达式/匹配模式</li>                    <div class="codeMirror">                        <pre><xmp>var reg=/a/i;//多个匹配模式var reg2=/a/ig;</xmp></pre>                    </div>                </ul>                <p></p>                <p>构造函数与创建字面量函数的区别</p>                <p></p>                <ul>                    <li>使用字面量的方式创建更加简单</li>                    <li>使用构造函数创建更加灵活</li>                </ul>                <p></p>                <h3 id="s13.2">13.2 正则符号</h3>                <p></p>                <p>以下参考自w3cschool</p>                <p></p>                <ul>                    <li>方括号,用于查找某个范围内的字符                        <p></p>                        <table>                            <tr>                                <td>表达式</td>                                <td>描述</td>                            </tr>                            <tr>                                <td>[abc]</td>                                <td>查找方括号之间的任何字符。</td>                            </tr>                            <tr>                                <td>[^abc]</td>                                <td>查找任何不在方括号之间的字符。,只要一个字符串中有除了abc以外的字母就会返回true</td>                            </tr>                            <tr>                                <td>[0-9]</td>                                <td>查找任何从 0 至 9 的数字。</td>                            </tr>                            <tr>                                <td>[a-z]</td>                                <td>查找任何从小写 a 到小写 z 的字符。</td>                            </tr>                            <tr>                                <td>[A-Z]</td>                                <td>查找任何从大写 A 到大写 Z 的字符。</td>                            </tr>                            <tr>                                <td>[A-z]</td>                                <td>查找任何从大写 A 到小写 z 的字符。</td>                            </tr>                            <tr>                                <td>[adgk]</td>                                <td>查找给定集合内的任何字符。</td>                            </tr>                            <tr>                                <td>[^adgk]</td>                                <td>查找给定集合外的任何字符。</td>                            </tr>                            <tr>                                <td>(red|blue|green)</td>                                <td>查找任何指定的选项。</td>                            </tr>                        </table>                        <p></p>                        <div class="codeMirror">                            <pre><xmp>var reg1=/ab/i; //检验一个字符串中是否有ab(整体)var reg2=/a|b/; //检查一个字符串中是否有a或bvar reg3=/a|b|c/; //检查一个字符串中是否有a或b或cvar reg4=/[ab]/;  //[]里面也是或的关系[ab]===a|bvar reg5=/a[bde]c/; //查一个字符串中是否还有abc或adc或aec(整体)</xmp></pre>                        </div>                    </li>                    <li>元字符，是拥有特殊含义的字符                        <p></p>                        <table>                            <tr>                                <td>元字符</td>                                <td>描述</td>                            </tr>                            <tr>                                <td>.</td>                                <td>查找单个字符，除了换行和行结束符。</td>                            </tr>                            <tr>                                <td>\w</td>                                <td>查找单词字符。</td>                            </tr>                            <tr>                                <td>\W</td>                                <td>查找非单词字符。</td>                            </tr>                            <tr>                                <td>\d</td>                                <td>查找数字。</td>                            </tr>                            <tr>                                <td>\D</td>                                <td>查找非数字字符。</td>                            </tr>                            <tr>                                <td>\s</td>                                <td>查找空白字符。</td>                            </tr>                            <tr>                                <td>\S</td>                                <td>查找非空白字符。</td>                            </tr>                            <tr>                                <td>\b</td>                                <td>匹配单词边界。一个单词旁边必须是有空白字符作为边界。比如判断是否含有child单词,用/\bchild\b/ 判断是否有一个独立的单词</td>                            </tr>                            <tr>                                <td>\B</td>                                <td>匹配非单词边界。单词左右两边没有空白字符</td>                            </tr>                            <tr>                                <td>\0</td>                                <td>查找 NULL 字符</td>                            </tr>                            <tr>                                <td>\n</td>                                <td>查找换行符</td>                            </tr>                            <tr>                                <td>\f</td>                                <td>查找换页符</td>                            </tr>                            <tr>                                <td>\r</td>                                <td>查找回车符</td>                            </tr>                            <tr>                                <td>\t</td>                                <td>查找制表符</td>                            </tr>                            <tr>                                <td>\v</td>                                <td>查找垂直制表符。</td>                            </tr>                            <tr>                                <td>\xxx</td>                                <td>查找以八进制数 xxx 规定的字符</td>                            </tr>                            <tr>                                <td>\xdd</td>                                <td>查找以十六进制数 dd 规定的字符</td>                            </tr>                            <tr>                                <td>\uxxxx</td>                                <td>查找以十六进制数 xxxx 规定的 Unicode 字符</td>                            </tr>                        </table>                    </li>                </ul>                <p></p>                <p>注意:</p>                <ul>                    <ul>                        <li>在正则表达式中\表示转义字符，但是js中任何地方\都是转义字符，所以要验证\也必须输入两个\(字面量中) 如:正则表达式.表示任意字符/./只会表示是否有任意字符，如果要判断有没有.(点这个符号),需要用/\ ./来表示</li>                        <li>如果用构造函数的方法，由于它的参数是一个字符串，而\是字符串中的转义字符，如果要使用\则需要使用\ \代替(相当于用了三个\ )，这样相当于把他们先化为字面量，再自变量转换，而因为\ .其实就是.，所以没有作用</li>                    </ul>                    <li>量词,通过量词可以设置一个内容出现的次数用&#123;&#125;里面写需要的数量,量词只对它前边的一个内容起作用</li>                    <table>                        <tr>                            <td>量词</td>                            <td>描述</td>                        </tr>                        <tr>                            <td>n+</td>                            <td>匹配任何包含至少一个 n 的字符串。例如，/a+/ 匹配 "candy" 中的 "a"，"caaaaaaandy" 中所有的 "a"。</td>                        </tr>                        <tr>                            <td>n*</td>                            <td>匹配任何包含零个或多个 n 的字符串。例如，/bo*/ 匹配 "A ghost booooed" 中的 "boooo"，"A bird warbled" 中的 "b"，但是不匹配 "A goat grunted"。</td>                        </tr>                        <tr>                            <td>n?</td>                            <td>匹配任何包含零个或一个 n 的字符串。例如，/e?le?/ 匹配 "angel" 中的 "el"，"angle" 中的 "le"。</td>                        </tr>                        <tr>                            <td>n&#123;X&#125;</td>                            <td>匹配包含 X 个 n 的序列的字符串。例如，/a&#123;2&#125;/ 不匹配 "candy," 中的 "a"，但是匹配 "caandy," 中的两个 "a"，且匹配 "caaandy." 中的前两个 "a"。</td>                        </tr>                        <tr>                            <td>n&#123;X,&#125;</td>                            <td>X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。例如，/a&#123;2,&#125;/ 不匹配 "candy" 中的 "a"，但是匹配 "caandy" 和 "caaaaaaandy." 中所有的 "a"。</td>                        </tr>                        <tr>                            <td>n&#123;X,Y&#125;</td>                            <td>X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。例如，/a&#123;1,3&#125;/ 不匹配 "cndy"，匹配 "candy," 中的 "a"，"caandy," 中的两个 "a"，匹配 "caaaaaaandy" 中的前面三个 "a"。注意，当匹配 "caaaaaaandy" 时，即使原始字符串拥有更多的 "a"，匹配项也是 "aaa"。</td>                        </tr>                        <tr>                            <td>n$</td>                            <td>匹配任何结尾为 n 的字符串。</td>                        </tr>                        <tr>                            <td>^n</td>                            <td>匹配任何开头为 n 的字符串。注意与[^]作对比</td>                        </tr>                        <tr>                            <td>?=n</td>                            <td>匹配任何其后紧接指定字符串 n 的字符串。</td>                        </tr>                        <tr>                            <td>?!n</td>                            <td>匹配任何其后没有紧接指定字符串 n 的字符串。</td>                        </tr>                    </table>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>var reg=/a&#123;3&#125;/; //表示aaa,但ab&#123;3&#125;只表示abbb,如果要ab一起出现3次，需要/(ab)&#123;3&#125;/    /*注意：这里面只要就会true正确执行，比如b&#123;3&#125;但是bbbb依然是正确的，因为包含了3个b*/</xmp></pre>                    </div>                    <p></p>                    <p>注:在正则表达式中同时使用^ $则要求字符串必须完全符合正则表达式</p>                    <div class="codeMirror">                        <pre><xmp>var reg1=/^a$/; //表示既要有a开头同时这个开头的a还必须是结尾    /*上式说明只能有一个a，aaa这种是不行的，因为结尾的a不是开头的a*/        var reg2=/^a|a$/; //表示以a开头或者以a结尾        var reg3=/^b([0-9A-z])&#123;0,&#125;b$/; //表示以b开头同时以b结尾同时中间可以跟任意数字或者字母</xmp></pre>                    </div>                    <p></p>                    <li>子集,用圆括号()包起来的属于一个整体,叫做一个子集</li>                    <div class="codeMirror">                        <pre><xmp>//通过子集可以很轻松的实现顺序互换var str="abcd";//要改成"cdab"var reg=/(ab)(cd)/g；var result=str.replace(reg,"$2$1")；//此时的$1和$2有特别的含有,$1代表第一个子集,$2代表第二个子集</xmp></pre>                    </div>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>var str="111223333";var reg=/(/d)\1+/g;//所有相同数字分为一组console.log(str.match(reg))//["111","22","3333"]</xmp></pre>                    </div>                </ul>                <p></p>                <h3 id="s13.3">13.3 正则断言</h3>                <p></p>                <p>所谓断言，就是指明某个字符串前边或者后边，将会出现满足某种规律的字符串</p>                <p></p>                <p>在将断言前.先将子集的捕获与捕获,一般的子集通过()括住都会被捕获,这时可以通过$1等来使用被捕获的子集,而如果不想要子集被捕获,只是用做一个匹配模式,就可以让子集不被捕获到,一般是通过(?:)来括住一个子集</p>                <p></p>                <table>                    <tr>                        <td>模式</td>                        <td>描述</td>                    </tr>                    <tr>                        <td>(?:X)</td>                        <td>不捕获匹配,不能通过$符号进行捕获到该子集,包括下面的所有都是捕获匹配。</td>                    </tr>                    <tr>                        <td>(?=X )</td>                        <td>零宽度正先行断言。仅当子表达式 X 在 此位置的右侧匹配时才继续匹配。例如，\w+(?=\d) 与后跟数字的单词匹配，而不与该数字匹配。此构造不会回溯。</td>                    </tr>                    <tr>                        <td>(?!X)</td>                        <td>零宽度负先行断言。仅当子表达式 X 不在 此位置的右侧匹配时才继续匹配。例如，例如，\w+(?!\d) 与后不跟数字的单词匹配，而不与该数字匹配 。</td>                    </tr>                    <tr>                        <td>(?&lt;=X)</td>                        <td>零宽度正后发断言。仅当子表达式 X 在 此位置的左侧匹配时才继续匹配。例如，(?&lt;=19)99 与跟在 19 后面的 99 的实例匹配。此构造不会回溯。</td>                    </tr>                    <tr>                        <td>(?&lt;!X)</td>                        <td>零宽度负后发断言。仅当子表达式 X 不在此位置的左侧匹配时才继续匹配。例如，(?&lt;!19)99 与不跟在 19 后面的 99 的实例匹配</td>                    </tr>                </table>                <p></p>                <p>例子:是否为浮点数</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function isFloat(number)&#123;    number=number+"";    var reg=/^-?\d+\.\d+$/;//\.连在一起表示就是一个(.),没有其他意思    return reg.test(number);&#125;console.log(isFloat(1));//falseconsole.log(isFloat(1.1));//trueconsole.log(isFloat(1.0));//false，false是由于JS内部的储存机制,当浮点数后全是0时就被看成一个整数console.log(isFloat("1.0"));//true,这时因为传入的就是一个1.0的字符串,所以为true</xmp></pre>                </div>                <p></p>                <p>例子:手机号规则</p>                <p></p>                <ul>                    <li>以1开头</li>                    <li>第二位3-9任意数字</li>                    <li>三位以后任意数字9位</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>var reg=/^1[3-9][0-9]&#123;9&#125;$/;</xmp></pre>                </div>                <p></p>                <p>例子:邮箱格式</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var reg=/^\w&#123;3,&#125;(.\w+)*@[A-z0-9]+(.[A-z]&#123;2,5&#125;&#123;1,2&#125;$/;</xmp></pre>                </div>                <p></p>                <h3 id="s13.4">13.4 正则表达式和字符串相关的方法</h3>                <p></p>                <p>正则表达式有两种用法，一种是调用自身的方法(如上面的test方法)，一种是作为参数进行传递</p>                <p></p>                <h4 id="s13.4.1">13.4.1 split方法</h4>                <p></p>                <p>split()方法中可以传递一个正则表达式作为参数来把一个字符串分割成字符串数组</p>                <p></p>                <p>注意:该方法即使不指定全局匹配的匹配模式，也会在全局进行拆分</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var arr="1a2b3c4d5e6f7g";var result=arr.split(/[A-z]/);//根据任意字母将字符串拆分console.log(result);//[1,2,3,4,5,6,7]</xmp></pre>                </div>                <p></p>                <h4 id="s13.4.2">13.4.2 search方法</h4>                <p></p>                <p>search()可以搜索字符串中是否含有指定的内容,这个方法和indexOf()方法类似，如果搜索到了指定内容则会返回第一次出现的索引，如果没有搜索到则会返回-1,不同的是indexOf()方法并不支持正则表达式</p>                <p></p>                <p>注意:该方法即使设置全局匹配模式也只会查找出现的第一个结果</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>//搜索字符串中是否有abc或aec或afcvar str="abcdef"var result=str.search(/a[bef]c/);console.log(result);//0</xmp></pre>                </div>                <p></p>                <h4 id="s13.4.3">13.4.3 match方法</h4>                <p></p>                <p>match()方法用做从一个字符串中将符合条件的内容提取出来，可以用正则表达作为参数，默认情况下match只会找到第一个符合要求的内容，找到以后就会停止检索，可以设置正则表达式为g(全局匹配模式)来匹配所有的内容</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var str="1a2b3c4d5e6f7A8B9C";var result=str.match(/[a-z]/gi);//这样就能把所有的字母都提取出来console.log(result);//[a,b,c,d,e,f,A,B,C]                                /*match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果，所以用result[0]等索引能查询到他们如果没有匹配到就会返回null，适合用作if等判断条件*/</xmp></pre>                </div>                <p></p>                <h4 id="s13.4.4">13.4.4 replace方法</h4>                <p></p>                <p>replace()方法可以将字符串中指定内容替换为新的内容</p>                <p></p>                <p>该方法有两个参数,第一个是被替换的内容,第二个参数是要替换的新的内容,默认只会替换查找到的第一个结果，所以可以加g进行全局匹配</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var str="1a2b3c4d5e";var result1=str.replace(/[a-z]/gi,"@-@");//把所有字母都替换为@-@var result2=str.replace(/[a-z]/gi,"");//去除所有字母(把所有字母都替换为空串)var result3=str.replace(/^\s*|\s*$/gm,"");//去除开头或结尾的空格</xmp></pre>                </div>                <p></p>                <p>不用replace方法实现替换字符串的内容</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>//运用数组的join方法和字符串的spilt方法var arr="1a2a3a4a5a";var result=arr.spilt("a").join("b");console.log(result);//"1b2b3b4b5b"</xmp></pre>                </div>            </div>            <div class="list" id="s14">                <h2>14.定时器</h2>                <p></p>                <h3 id="s14.1">14.1 定时调用</h3>                <p></p>                <ul>                    <li>当希望一段程序可以每隔一段时间执行一次时，可以使用定时调用函数setInterval(),该函数有多个参数<br/>参数                        <ul>                            <li>要做的事(通常是回调函数)，该函数会每隔一段时间被调用一次，如果不是函数就传入一个字符串,这个字符串中的东西代表要做的事如"alert(123)"(不推荐这样写,最好还是写函数)</li>                            <li>每次调用间隔的时间，单位是毫秒ms</li>                            <li>往后的参数参数是要传入到回调函数中的实参,没有就不填</li>                        </ul>                        <p></p>                        <p>该函数的返回值是一个Number类型的数据,这个数字用来作为定时器的唯一标识(相当于ID值),可以通过变量赋值来接收这个返回值</p>                        <p></p>                        <p></p>                        <div class="codeMirror">                            <pre><xmp>var timer=setInterval(function()&#123;    console.log(123);&#125;,1000);//每1S打印一次123</xmp></pre>                        </div>                    </li>                    <li>通过clearInerval()函数可以关闭一个通过setInterval()函数开启定时器,该函数中需要一个定时器的标识作为参数，这样将关闭对应标识对应的定时器                        <p>clearInterval()函数可以接收任意参数，如果参数是一个有效的定时器的标识，则停止对应的定时器，如果参数不是一个有效的标识，则什么也不发生，也可以直接传入定时器传入的数值ID值cleatInterval(1)代表关闭第一个开启的定时器(但是不推荐这样用),最好还是通过变量赋值的标识来关闭定时器</p>                        <p></p>                        <p></p>                        <div class="codeMirror">                            <pre><xmp>var timer=setInterval(function()&#123;    console.log(123);&#125;,1000);clearInterval(timer);//因为一运行就直接关闭了.所以不能打印出来 </xmp></pre>                        </div>                        <p></p>                        <div class="codeMirror">                            <pre><xmp>var num=1;var timer=setInterval(function()&#123;    console.log(123);    if(num==11)&#123;    clearInterval(timer)    &#125;&#125;,1000);//当num=11的时候关闭定时器不会再打印了</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <h3 id="s14.2">14.2 延时调用</h3>                <p></p>                <ul>                    <li>希望一段程序不立刻执行，而是隔一段时间以后再执行，可以通过延时调用函数setTimeout()，并且延时调用只执行一次,该函数的参数和用法和setInterval()一样                        <div class="codeMirror">                            <pre><xmp>var timer=setTimeout(function()&#123;    console.log(123);&#125;,1000);//1S后打印一次123,并且只会打印一次</xmp></pre>                        </div>                    </li>                    <li>通过clearTimeout()函数可以关闭一个通过setTimeout()函数开启定时器,该函数中需要一个定时器的标识作为参数，这样将关闭对应标识对应的定时器,关闭方法同clearInterval()                        <div class="codeMirror">                            <pre><xmp>var timer=setTimeout(function()&#123;     console.log(123);&#125;,1000);clearTimeout(timer);//直接关闭定时器</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <p>注意:所有定时器中函数的异步操作都是放在同步操作的最后进行执行</p>                <p></p>                <p>延时调用和定时调用的异同</p>                <p></p>                <ul>                    <li>定时调用会执行多次，而延时调用只会执行一次</li>                    <li>延时调用和定时调用的语法是相同的，并且在时间上是可以相互代替的，在开发中可根据自己需要去选择</li>                </ul>                <p></p>                <h3 id="s14.3">14.3 运动动画</h3>                <p></p>                <p>在JS中可以通过定时器的效果来实现动画效果,动画效果实质上时一帧一帧的图片效果拼接而来,当每秒钟的动画帧数超过60帧时,人眼就分辨不出来图片和动画,以此来实现动画效果</p>                <p></p>                <p>关于动画的函数</p>                <p></p>                <ul>                    <li>requestAnimationFrame()函数(该函数不支持低版本IE浏览器),该函数的内部可以接收一个回调函数,在每一帧的动画结束后该函数就是自动执行内部的回调函数,以此达到动画效果式的移动,该函数的返回值也是一个代表数值类型的ID值                        <p>注:可以说该方法也是递归调用函数,但是事实上该方法对调用函数的次数做了限制,每秒只会调用60 次,而且不会无限占据系统资源</p>                    </li>                    <p></p>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>//兼容代码window.requestAnimationFrame =window.requestAnimationFrame ||    function(cb) &#123;      return setTimeout(cb, 1000 / 60);    &#125;; </xmp></pre>                    </div>                    <li>cancelAnimationFrame()函数(该函数不支持低版本IE浏览器),该方法内部需要一个ID值作为参数,可以提前停止requestAnimationFrame()继续调用内部回调函数                        <div class="codeMirror">                            <pre><xmp>//兼容代码window.cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <p>动画效果函数</p>                <p></p>                <ul>                    <li>普通匀速动画效果(不通过数值的加减)                        <div class="codeMirror">                            <pre><xmp>/*参数:对象obj要改变的属性对象json(该对象内部是要改变的属性和要到达目标的属性值,不带单位,透明度100代表CSS的1)time--毫秒(ms)为单位,默认是1000mscallback回调函数(可选)*/function animation(obj, json, time = 1000, callback = function() &#123;&#125;) &#123;  //兼容代码  window.requestAnimationFrame =    window.requestAnimationFrame ||    function(cb) &#123;      return setTimeout(cb, 1000 / 60);    &#125;;  var startValue = &#123;&#125;, //开始属性值    changeValue = &#123;&#125;, //改变属性值    startTime = new Date(); //起始时间  for (var key in json) &#123;    var value;    if (key === "opacity") &#123;      value = Math.round(parseFloat(getStyle(obj, key)) * 100);    &#125; else &#123;      value = parseFloat(getStyle(obj, key));    &#125;    startValue[key] = isNaN(value) ? 0 : value;//如果原来没有写值原来的值默认是0    changeValue[key] = parseFloat(json[key]) - startValue[key]; //改变值  &#125;  run(); //执行动画的函数  function run() &#123;    var nowTime = new Date() - startTime;    var timescale = nowTime / time; //现在所用时间在总时间的比例    if (timescale >= 1) &#123;      timescale = 1;    &#125; else &#123;      requestAnimationFrame(run);    &#125;          for (key in changeValue) &#123;      var value = timescale * changeValue[key] + startValue[key]; //每个时刻的目标值      if (key === "opacity") &#123;        obj.style.filter = "alpha(opacity:" + value + ")";        obj.style.opacity = value / 100;      &#125; else &#123;        obj.style[key] = value + "px";      &#125;    &#125;    if (timescale === 1) &#123;      callback();    &#125;  &#125;&#125;//获取对象属性function getStyle(obj, name) &#123;  if (window.getComputedStyle) &#123;    return getComputedStyle(obj, null)[name];  &#125; else &#123;    return obj.currentStyle[name];  &#125;&#125;//例子var div=document.getElementById("box");//width:100px  height:100px  backgournd:redanimation(div,&#123;width:200,height:200&#125;,2000,function()&#123;    div.style.display="none";&#125;);</xmp></pre>                        </div>                    </li>                    <p></p>                    <li>通过Tween.js实现的变速动画效果                        <p></p>                        <div class="codeMirror">                            <pre><xmp>/*参数:对象obj                                       要改变的属性对象json,该属性装有两个对象,data对象和option对象,data对象装的是内部要改变的属性和要到达目标的属性值,不带单位,透明度100代表CSS的1),option对象装的是运动方式easing属性和运动状态speed属性time--毫秒(ms)为单位,默认是1000mscallback回调函数*/function animation(obj, json, time = 1000, callback = function() &#123;&#125;) &#123;  //兼容代码  window.requestAnimationFrame =    window.requestAnimationFrame ||    function(cb) &#123;      return setTimeout(cb, 1000 / 60);    &#125;;   //控制速度的Tween.js  var Tween = &#123;    Linear: &#123;      easeIn: function(t, b, c, d) &#123;        return (c * t) / d + b;      &#125;    &#125;,    Quad: &#123;      easeIn: function(t, b, c, d) &#123;        return c * (t /= d) * t + b;      &#125;,      easeOut: function(t, b, c, d) &#123;        return -c * (t /= d) * (t - 2) + b;      &#125;,      easeInOut: function(t, b, c, d) &#123;        if ((t /= d / 2) < 1) return (c / 2) * t * t + b;        return (-c / 2) * (--t * (t - 2) - 1) + b;      &#125;    &#125;,    Cubic: &#123;      easeIn: function(t, b, c, d) &#123;        return c * (t /= d) * t * t + b;      &#125;,      easeOut: function(t, b, c, d) &#123;        return c * ((t = t / d - 1) * t * t + 1) + b;      &#125;,      easeInOut: function(t, b, c, d) &#123;        if ((t /= d / 2) < 1) return (c / 2) * t * t * t + b;        return (c / 2) * ((t -= 2) * t * t + 2) + b;      &#125;    &#125;,    Quart: &#123;      easeIn: function(t, b, c, d) &#123;        return c * (t /= d) * t * t * t + b;      &#125;,      easeOut: function(t, b, c, d) &#123;        return -c * ((t = t / d - 1) * t * t * t - 1) + b;      &#125;,      easeInOut: function(t, b, c, d) &#123;        if ((t /= d / 2) < 1) return (c / 2) * t * t * t * t + b;        return (-c / 2) * ((t -= 2) * t * t * t - 2) + b;      &#125;    &#125;,    Quint: &#123;      easeIn: function(t, b, c, d) &#123;        return c * (t /= d) * t * t * t * t + b;      &#125;,      easeOut: function(t, b, c, d) &#123;        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;      &#125;,      easeInOut: function(t, b, c, d) &#123;        if ((t /= d / 2) < 1) return (c / 2) * t * t * t * t * t + b;        return (c / 2) * ((t -= 2) * t * t * t * t + 2) + b;      &#125;    &#125;,    Sine: &#123;      easeIn: function(t, b, c, d) &#123;        return -c * Math.cos((t / d) * (Math.PI / 2)) + c + b;      &#125;,      easeOut: function(t, b, c, d) &#123;        return c * Math.sin((t / d) * (Math.PI / 2)) + b;      &#125;,      easeInOut: function(t, b, c, d) &#123;        return (-c / 2) * (Math.cos((Math.PI * t) / d) - 1) + b;      &#125;    &#125;,    Expo: &#123;      easeIn: function(t, b, c, d) &#123;        return t == 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;      &#125;,      easeOut: function(t, b, c, d) &#123;        return t == d ? b + c : c * (-Math.pow(2, (-10 * t) / d) + 1) + b;      &#125;,      easeInOut: function(t, b, c, d) &#123;        if (t == 0) return b;        if (t == d) return b + c;        if ((t /= d / 2) < 1) return (c / 2) * Math.pow(2, 10 * (t - 1)) + b;        return (c / 2) * (-Math.pow(2, -10 * --t) + 2) + b;      &#125;    &#125;,    Circ: &#123;      easeIn: function(t, b, c, d) &#123;        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;      &#125;,      easeOut: function(t, b, c, d) &#123;        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;      &#125;,      easeInOut: function(t, b, c, d) &#123;        if ((t /= d / 2) < 1) return (-c / 2) * (Math.sqrt(1 - t * t) - 1) + b;        return (c / 2) * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;      &#125;    &#125;,    Elastic: &#123;      easeIn: function(t, b, c, d, a, p) &#123;        var s;        if (t == 0) return b;        if ((t /= d) == 1) return b + c;        if (typeof p == "undefined") p = d * 0.3;        if (!a || a < Math.abs(c)) &#123;          s = p / 4;          a = c;        &#125; else &#123;          s = (p / (2 * Math.PI)) * Math.asin(c / a);        &#125;        return (          -(            a *            Math.pow(2, 10 * (t -= 1)) *            Math.sin(((t * d - s) * (2 * Math.PI)) / p)          ) + b        );      &#125;,      easeOut: function(t, b, c, d, a, p) &#123;        var s;        if (t == 0) return b;        if ((t /= d) == 1) return b + c;        if (typeof p == "undefined") p = d * 0.3;        if (!a || a < Math.abs(c)) &#123;          a = c;          s = p / 4;        &#125; else &#123;          s = (p / (2 * Math.PI)) * Math.asin(c / a);        &#125;        return (          a *            Math.pow(2, -10 * t) *            Math.sin(((t * d - s) * (2 * Math.PI)) / p) +          c +          b        );      &#125;,      easeInOut: function(t, b, c, d, a, p) &#123;        var s;        if (t == 0) return b;        if ((t /= d / 2) == 2) return b + c;        if (typeof p == "undefined") p = d * (0.3 * 1.5);        if (!a || a < Math.abs(c)) &#123;          a = c;          s = p / 4;        &#125; else &#123;          s = (p / (2 * Math.PI)) * Math.asin(c / a);        &#125;        if (t < 1)          return (            -0.5 *              (a *                Math.pow(2, 10 * (t -= 1)) *                Math.sin(((t * d - s) * (2 * Math.PI)) / p)) +            b          );        return (          a *            Math.pow(2, -10 * (t -= 1)) *            Math.sin(((t * d - s) * (2 * Math.PI)) / p) *            0.5 +          c +          b        );      &#125;    &#125;,    Back: &#123;      easeIn: function(t, b, c, d, s) &#123;        if (typeof s == "undefined") s = 1.70158;        return c * (t /= d) * t * ((s + 1) * t - s) + b;      &#125;,      easeOut: function(t, b, c, d, s) &#123;        if (typeof s == "undefined") s = 1.70158;        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;      &#125;,      easeInOut: function(t, b, c, d, s) &#123;        if (typeof s == "undefined") s = 1.70158;        if ((t /= d / 2) < 1)          return (c / 2) * (t * t * (((s *= 1.525) + 1) * t - s)) + b;        return (c / 2) * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;      &#125;    &#125;,    Bounce: &#123;      easeIn: function(t, b, c, d) &#123;        return c - Tween.Bounce.easeOut(d - t, 0, c, d) + b;      &#125;,      easeOut: function(t, b, c, d) &#123;        if ((t /= d) < 1 / 2.75) &#123;          return c * (7.5625 * t * t) + b;        &#125; else if (t < 2 / 2.75) &#123;          return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;        &#125; else if (t < 2.5 / 2.75) &#123;          return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;        &#125; else &#123;          return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;        &#125;      &#125;,      easeInOut: function(t, b, c, d) &#123;        if (t < d / 2) &#123;          return Tween.Bounce.easeIn(t * 2, 0, c, d) * 0.5 + b;        &#125; else &#123;          return Tween.Bounce.easeOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;        &#125;      &#125;    &#125;  &#125;;          var startValue = &#123;&#125;, //开始属性值    changeValue = &#123;&#125;, //改变属性值    startTime = new Date(); //起始时间  var option = json.option;//获取option对象的值  var dataValue = json.data;//获取data对象的值  for (var key in dataValue) &#123;    var value;    if (key === "opacity") &#123;      value = Math.round(parseFloat(getStyle(obj, key)) * 100);    &#125; else &#123;      value = parseFloat(getStyle(obj, key));    &#125;    startValue[key] = isNaN(value) ? 0 : value;    changeValue[key] = parseFloat(dataValue[key]) - startValue[key]; //改变值  &#125;  var speed = option && option.speed; //控制的是速度的形式,不是具体快慢  var easing = option && option.easing;  var speedArray = ["easeIn", "easeOut", "easeInOut"];//装有运动状态的数组  if (typeof option === "object") &#123;//判断option是否有值    if ("easing" in option) &#123;//option有值时是否改写了easing属性      speed = speed || 0;//默认是第一种运动状态      //匀速是强制速度是第一种形式      if (easing.toLowerCase() === "linear") &#123;        speed = 0;        easing = "Linear";      &#125;    &#125; else &#123;      //写了option,但是是空对象      speed = 0;      easing = "Linear";    &#125;  &#125; else &#123;    //没有写option,默认情况    speed = 0;    easing = "Linear";  &#125;  run(); //执行动画的函数  function run() &#123;    var nowTime = new Date() - startTime; //当前时间     for (key in changeValue) &#123;        ///下方是Tween函数的自动用法      var value = Tween[easing][speedArray[speed]](        nowTime,        startValue[key],        changeValue[key],        time      );        //判断是否到达指定时间      if (time - nowTime <= 0) &#123;        value = Math.min(value, dataValue[key]);        value = Math.max(value, dataValue[key]);         //上方代码是为了让目标值一直都是指定值,减小误差      &#125;      if (key === "opacity") &#123;        obj.style.filter = "alpha(opacity:" + value + ")";        obj.style.opacity = value / 100;      &#125; else &#123;        obj.style[key] = value + "px";      &#125;    &#125;      //到达目标值执行回调函数    if (time - nowTime <= 0) &#123;      callback();    &#125; else &#123;      requestAnimationFrame(run);    &#125;  &#125;&#125;//获取对象属性function getStyle(obj, name) &#123;  if (window.getComputedStyle) &#123;    return getComputedStyle(obj, null)[name];  &#125; else &#123;    return obj.currentStyle[name];  &#125;&#125;//例子var div=document.getElementById("box");//width:100px  height:100px  backgournd:redanimation(div,&#123;data:&#123;width:200,height:200&#125;,option:&#123;easing:"Bounce",speed:1&#125;&#125;,2000,          function()&#123;                div.style.display="none";            &#125;);</xmp></pre>                        </div>                    </li>                </ul>            </div>            <div class="list" id="s15">                <h2>15.Class</h2>                <p></p>                <p>class用法跟let和const一样，不存在变量提升,也不能重复声明类名,JS中的类(class)是在ES6中被推出为关键字,实际上也是通过原型构成的模拟类</p>                <p></p>                <p>ES5面对对象写法和传统的面向对象语言(如C++和JAVA)差异很大,很容易让新学习这门语言的人感到困惑。所以在ES6中提供了更接近传统语言的写法,引入了class这个概念,作为对象的模板,通过class关键字,可以定义类。</p>                <p></p>                <p>ES6中的class可以看作只是一个语法糖,它的大部分功能ES5都可以做到,新的class写法只是让对象原型的写法更加清晰,更像面向对象编程的语法而已</p>                <p></p>                <h3 id="s15.1">15.1 用法</h3>                <p></p>                <div class="codeMirror">                    <pre><xmp>//ES5写法function Person(name,age,gender)&#123;    this.name=name;    this.age=age;    this.gender=gender;&#125;Person.prototype.sayName=function()&#123;    alert("hello"+this.name);&#125;//ES6写法class Person&#123;    constructor(name,age,gender)&#123;        this.name=name;        this.age=age;        this.gender=gender;    &#125;        sayName()&#123;        alert("hello"+this.name);    &#125;//其实就是ES6中函数的简写,但是必须用这种简写形式创建方法&#125;</xmp></pre>                </div>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>我们通常只会在原型中放方法,在ES5的语法中虽然在原型中可以放普通对象,但是其实不推荐这样做,所以在用class声明的类中只允许在constructor()函数中放入对象,而在constructor()函数外只能放方法</li>                    <li>构造函数的prototype属性在ES6的class中依然存在,事实上,class中定义的所有方法全部都作为prototype属性的方法保存</li>                    <div class="codeMirror">                        <pre><xmp>class Fun&#123;    construct()&#123;    &#125;                                            say()&#123;                    &#125;        add()&#123;            &#125;&#125;//等同于function Fun()&#123;    construct()&#123;                    &#125;,    say()&#123;                &#125;,    add()&#123;                    &#125;&#125;</xmp></pre>                    </div>                    <li>如果不传入参数,constructor()函数可以不用写,但是在解析的时候会自动为这个类加上该函数方法</li>                </ul>                <p></p>                <h3 id="s15.2">15.2 静态方法</h3>                <p></p>                <p>类相对于实例的原型,所有在类中定义的方法,都会被实例继承。如果在一个方法前,加上static关键字,就表示该方法不会被实例继承,只能通过类本身来调用,这就是静态方法</p>                <p></p>                <p>注意:ES6中规定class内部只有静态方法,并没有静态属性,也就是不能设置静态属性,如果要设置静态属性只能在外面手动设置</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>class Person&#123;    constructor(name,age,gender)&#123;        this.name=name;        this.age=age;        this.gender=gender;    &#125;        static say()&#123;        alert("hello");    &#125;&#125;Person.say();//"hello"Person.age=18;console.log(Person.age);//18</xmp></pre>                </div>                <p></p>                <h3 id="s15.3">15.3 继承</h3>                <p></p>                <p>在class中通过extends关键字进行类的继承</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>class Person&#123;    constructor(name,age,gender)&#123;    this.name=name;    this.age=age;    this.gender=gender;&#125;                                      sayName()&#123;    alert("hello"+this.name);   &#125;&#125;class Studnet extends Person&#123;constructor(name,age,gender,score)&#123;    super(name,age,gender)//必须调用super()方法,不然新建对象时会报错    this.score=score;  &#125;&#125;let student=new Student("孙悟空",18,"男",100);student.sayName();</xmp></pre>                </div>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>子类必须在constructor()方法中调用super()方法,否则新建实例时会报错。这是因为子类没有自己的this对象,而是继承父类的this对象,然后对其进行加工。如果不调用super()方法,子类就不能得到this对象</li>                    <li>子类会将父类的静态方法与静态属性也一起继承,通过子类同样也能用父类的静态方法</li>                </ul>                <p></p>                <h3 id="s15.4">15.4 super</h3>                <p></p>                <p>super关键字既可以当作函数使用,又可以直接当作对象调用,这两种情况下的super的用法完全不同</p>                <p></p>                <ul>                    <li>super作为函数使用时,代表调用父类的构造函数。并且在子类的构造函数中必须执行一次super()方法<br/>注意:</li>                    <ul>                        <li>super当作函数使用时只能用在子类构造函数中,如果用在其它地方就会报错</li>                        <li>父类可以不写constructor()方法,因为在调用的时候会自动加上该函数,但是子类必须写该方法,因为super()方法必须写在constructor()方法中,而super()方法在继承中又是必写的,不写子类就不具备this,从而无法返回对象出来</li>                    </ul>                    <div class="codeMirror">                        <pre><xmp>class A&#123;    constructor()&#123;                                              &#125;&#125;                                    class B extends A&#123;    constructor()&#123;        super();    &#125;&#125;/*子类B的构造函数之中的super()虽然代表的是父类A的构造函数,但是返回的确实子类B的实例,即super()内部的this是指向B,所以super()相当于A.prototype.constructor.call(this)*/</xmp></pre>                    </div>                    <li>super当作对象使用时,在普通实例方法中指向父类的原型对象,在静态方法中指向父类</li>                    <div class="codeMirror">                        <pre><xmp> class A&#123;    constructor()&#123;        say()&#123;            return "hello";        &#125;    &#125;&#125;class B extends A&#123;    constructor()&#123;        super();        console.log(super.say());//"hello"    &#125;&#125;/*在创建实例对象时就会在控制台打印"hello",子类B中的super.say()就是将super当作一个对象进行使用,此时的super在普通实例方法中指向的是A.prototype,super.say()就相当于A.prototype.say()*/</xmp></pre>                    </div>                </ul>                <p></p>                <p>由于this是指向子类的,所以如果通过super对某个属性进行赋值,这时的super就是this,赋值的属性就会变成子类实例的属性</p>                <div class="codeMirror">                    <pre><xmp>class A&#123;    constructor()&#123;        this.x=1;    &#125;&#125;class B extends A&#123;    constructor()&#123;        super();        console.log(this.x);//1        this.x=2;        console.log(this.x);//2        super.x=3;        console.log(super.x)//undefined，由于此时的super的指向是A.prototype        console.log(this.x)//3    &#125;&#125;/*super.x=3等同于this.x=3,而读取super.x的时候此时super的指向是A.prototype,也就是A.prototype.x,因为没有设置实例属性,所以此时的值为undefined*/</xmp></pre>                </div>            </div>            <div class="list" id="s16">                <h2>16.Set</h2>                <p></p>                <p>ES6中提供了数据结构Set,该对象类似于数组,但是所有的值都是唯一的,在其中不会有重复的值,Set本身就是一个构造函数,用来生成Set类的实例对象</p>                <p></p>                <p>注意:与数组和一般对象不同的是,Set实例没有属性名(键名),或者说属性名(键名)和属性值(键值)都是相同的值</p>                <p></p>                <h3 id="s16.1">16.1 用法</h3>                <p></p>                <div class="codeMirror">                    <pre><xmp>var s=new Set();[1,2,3,4,1,2].forEach(function(value)&#123;    s.add(value);//Set类的对象只能通过add方法添加值&#125;)console.log(s);//Set(4)&#123;1,2,3,4&#125;</xmp></pre>                </div>                <p></p>                <div class="codeMirror">                    <pre><xmp>//在Set()中可以传入一个数组作为参数来作为Set实例的初始化对象var s=new Set([1,2,3,4,1,2]);/*该写法类似于[1,2,3,4,1,2].forEach(function(value)&#123;    s.add(value);&#125;)*/console.log(s);////Set(4)&#123;1,2,3,4&#125;console.log(s.size);//Set类有一个实例属性size来计算Set实例对象的长度console.log([...s]);//[1,2,3,4]/*上面的写法可以用作数组的去重*/</xmp></pre>                </div>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>在向Set实例中添加值的时候不会进行类型转换,如:123与"123"不同</li>                    <li>两个对象总是不同</li>                    <li>Set内部的判断两个值是否相同的算法结果类似全等运算符(===),不同在于在Set内部认为NaN与自身相等,所以也会去重</li>                </ul>                <p></p>                <h3 id="s16.2">16.2 属性与方法</h3>                <p></p>                <h4 id="s16.2.1">16.2.1 size</h4>                <p></p>                <p>Set类的实例有一个size属性,专门用来记录Set实例中的值的数量,返回Set实例成员的数量</p>                <p></p>                <h4 id="s16.2.2">16.2.2 add,delete,has与clear方法</h4>                <p></p>                <ul>                    <li>add()方法为Set实例添加一个值,返回实例对象本身,可以用作链式操作</li>                    <li>delete()方法删除Set实例的某个值,删除成功返回true,删除失败返回false</li>                    <li>has()方法判断Set实例中是否有某个值.有就返回true,没有返回false</li>                    <li>clear()方法情况Set实例中的所有值,没有返回值</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>var s=new Set([1,2,3,4,5]);s.add(6);console.log(s);//Set(6)&#123;1,2,3,4,5,6&#125;                                s.delete(1);console.log(s);//Set(5)&#123;2,3,4,5,6&#125;console.log(s.has(2));//trues.clear();console.log(s);//Set(0) </xmp></pre>                </div>                <p></p>                <h4 id="s16.2.3">16.2.3 keys,values与entries方法</h4>                <p></p>                <p>keys()方法返回装有Set实例的键名的数组，values()方法返回装有Set实例的键名值的数组，entries()方法返回装有Set实例的键名和键值的数组,但是由于在Set实例中只有键值,所有三个方法返回的数组都是相同的,都只装有键值</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var s=new Set([1,2,3,4,5]);console.log(s.keys());//[1,2,3,4,5]console.log(s.values());//[1,2,3,4,5]console.log(s.entries());//[1,2,3,4,5]</xmp></pre>                </div>                <p></p>                <h4 id="s16.2.4">16.2.4 forEach方法</h4>                <p></p>                <p>Set实例的forEach()方法的用法与表现结果与数组的forEach()方法的表现结果一致,第一个参数是回调函数,第二个参数是回调函数中this的指向对象</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var s=new Set([1,2,3,4,5]);    s.forEach(function(value,index)&#123;        console.log(index,value);//1,1 2,2 3,3 4,4 5,5     &#125;)</xmp></pre>                </div>                <p></p>                <h3 id="s16.3">16.3 WeakSet</h3>                <p></p>                <p>WeakSet也是一个类,可以用new WeakSet()来创建一个WeakSet实例对象,该对象的结构和Set实例相似,但是还是有所区别</p>                <p></p>                <p>区别:</p>                <p></p>                <ul>                    <li>WeakSet的成员只能是对象,而不能是其他类型的值</li>                    <li>WeakSet实例中的成员对象都是弱引用,即垃圾回收机制不会考虐WeakSet实例中对该对象的引用,如果其它对象没有引用该对象,垃圾回收机制会自动回收该对象所占的内存,不会考虐WeakSet实例中是否还保留着对该对象的引用,由于WeakSet实例的弱引用这个特性,所以ES6中有规定WeakSet创建的实例不可被遍历,因为WeakSet中的成员对象的引用随时会消失</li>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>var w=new WeakSet([[1,2,3],&#123;a:1,b:2,c:3&#125;]);console.log(w);</xmp></pre>                    </div>                </ul>                <p></p>                <p>方法:</p>                <p></p>                <p>WeakSet实例有add(),delete()和has()方法,用法同Set,但是没有遍历WeakSet实例本身的方法,因为该类实例没有size属性</p>            </div>            <div class="list" id="s17">                <h2>17.Map</h2>                <p></p>                <p>ES6提供Map数据结构,该对象类似于普通对象,也是键值对的集合,但是该对象的键不像普通对象那样只能用字符串作为键,而是可以使用各种类型的值(包括对象)来作为键</p>                <p></p>                <p>JS中的对象本质上是键值对的集合(Hash结构),但是传统上只能用字符串当作键,这就使得在使用JS对象的时候有很大的限制。也就是说，Object结构提供的是字符串与值相对应的键值对模式.而Map结构提供的是值与值相对应的键值对模式,相对来说更加的完善</p>                <p></p>                <p></p>                <h3 id="s17.1">17.1 用法</h3>                <p></p>                <div class="codeMirror">                    <pre><xmp>var m=new Map();var o=&#123;a:1&#125;;m.set(o,1);/*只能通过set()方法来设置值，最好通过变量来储存键,以便于获取,因为如果不通过变量获取就不是对同一个对象的引用,会返回undefiend*/console.log(m.get(&#123;a:1&#125;));//undefinedconsole.log(m.get(o));//1console.log(m.o);//undefinedconsole.log(m[o]);//undefined/*只能通过get()方法来获取到对应键的内容,不能通过点或[]来获取,因为该结构不是普通对象的结构,通过这两种方式只能拿到普通对象键对应的值*/</xmp></pre>                </div>                <p></p>                <div class="codeMirror">                    <pre><xmp>//也可以传入普通的数据类型var m=new Map([["name","孙悟空"],[&#123;age:18&#125;,18]])console.log(m.get("name"));//"孙悟空" </xmp></pre>                </div>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>在直接通过结构赋值创建对象时,传入的参数需要是一个数组,同时数组中的每一个成员需要用一个二维数组括起来作为键值对</li>                    <li>如果Map实例的键是一个简单类型的值,则只要两个值严格相等,Map内部就会将其视为一个值,比如0和-0依然是一个值,而1与"1"就不是一个值。NaN虽然不等于自身,但是Map内部将其视为同一个值</li>                </ul>                <p></p>                <h3 id="s17.2">17.2 属性与方法</h3>                <p></p>                <h4 id="s17.2.1">17.2.1 size</h4>                <p></p>                <p>Map类的实例有一个size属性,专门用来记录Set实例中的值的数量,返会Map实例成员的数量</p>                <p></p>                <h4 id="s17.2.2">17.2.2 get,delete,has与clear方法</h4>                <p></p>                <ul>                    <li>get()方法为Map实例添加一个值,传入两个参数,分别代表键和值,返回实例对象本身,可以用作链式操作</li>                    <li>delete()方法删除Map实例的某个值,删除成功返回true,删除失败返回false</li>                    <li>has()方法判断Map实例中是否有某个值.有就返回true,没有返回false</li>                    <li>clear()方法情况Map实例中的所有值,没有返回值</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>var m=new Map();m.set("a",1);m.set("b",2);                                console.log(m);//Map(2) &#123;"a" => 1, "b" => 2&#125;console.log(m.get("a"));//1m.delete("a");console.log(m.get("a"));//undefinedconsole.log(m.has("b"));//truem.clear();console.log(m);//Map(0)&#123;&#125; </xmp></pre>                </div>                <p></p>                <h4 id="s17.2.3">17.2.3 keys,values与entries方法</h4>                <p></p>                <p>keys()方法返回装有Map实例的键名的数组，values()方法返回装有Map实例的键名值的数组，entries()方法返回装有Map实例的键名和键值的数组,这些方法与Set实例不同,都能得到不同的数组</p>                <p></p>                <h4 id="s17.2.4">17.2.4 forEach方法</h4>                <p></p>                <p>Map实例的forEach()方法的用法与表现结果与数组的forEach()方法的表现结果一致,第一个参数是回调函数,第二个参数是回调函数中this的指向对象</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var m=new Map([["a",1],["b",2],["c",3]]);m.forEach(function(value,key)&#123;    console.log(key,value)//a 1 b 2 c 3&#125;)</xmp></pre>                </div>                <p></p>                <p>注意:Map遍历的顺序就是插入顺序,遍历行为基本与Set一致</p>                <p></p>                <h3 id="s17.3">17.3 类型转换</h3>                <p></p>                <h4 id="s17.3.1">17.3.1 与数组转换</h4>                <p></p>                <ul>                    <li>Map转数组                        <div class="codeMirror">                            <pre><xmp> var m = new Map([["a", 1], ["b", 2], ["c", 3]]);console.log([...m]);//[Array(2), Array(2), Array(2)]/*结果为数组中包含三个二维数组,每个二维数组分别存有一个Map对象的成员*/ </xmp></pre>                        </div>                    </li>                    <li>数组转Map                        <div class="codeMirror">                            <pre><xmp> var m=new Map([["a",1],["b",2],["c",3]]);console.log(m);//Map(3) &#123;"a" => 1, "b" => 2, "c" => 3&#125;</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <h4 id="s17.3.2">17.3.2 与对象转换</h4>                <p></p>                <ul>                    <li>Map转对象<br/>注:只有Map实例中所有的键都是字符串才能转为对象</li>                    <div class="codeMirror">                        <pre><xmp>var m=new Map([["a",1],["b",2],["c",3]]);var obj=&#123;&#125;;for(var [key,value] of m)&#123;    obj[key]=value;&#125;console.log(obj);//&#123;a: 1, b: 2, c: 3&#125;</xmp></pre>                    </div>                    <li>对象转Map</li>                    <div class="codeMirror">                        <pre><xmp>var m=new Map();var obj=&#123;a:1,b:2,c:3&#125;;/*for(var key in obj)&#123;    m.set(key,obj[k]);&#125;由于for...in的性能原因,改用for...of*/for(var key of Object.keys(obj))&#123;    m.set(key,obj[key]);&#125;console.log(m);//Map(3) &#123;"a" => 1, "b" => 2, "c" => 3&#125;</xmp></pre>                    </div>                </ul>                <p></p>                <h4 id="s17.3.3">17.3.3 与JSON转换</h4>                <p></p>                <ul>                    <li>Map转JSON<br/>Map转为JSON时分两种情况,如果Map的简明全是字符串就转换为JSON对象,如果键名有非字符串,就转换为JSON数组</li>                    <ul>                        <li>Map=>JSON对象                            <div class="codeMirror">                                <pre><xmp>var m=new Map([["a",1],["b",2],["c",3]]);var obj=&#123;&#125;;for(var [key,value] of m)&#123;    obj[key]=value;&#125;var json=JSON.stringify(obj);//实质上时先转为对象再转为JSONconsole.log(json);</xmp></pre>                            </div>                        </li>                        <li>Map=>JSON数组                            <div class="codeMirror">                                <pre><xmp>var m=new Map([["a",1],["b",2],[&#123;c:3&#125;,3]]);var json=JSON.stringify([...m]);//还是先转换为数组在转换为JSONconsole.log(json);</xmp></pre>                            </div>                        </li>                    </ul>                    <li>JSON转Map<br/>JSON转换为Map时,正常情况下所有的键名都会转为字符串，无论是不是对象,但是如果JSON整个是一个数组,且每一个数组成员本身都是一个二维数组,每个二维数组里面有两个成员,这样就能一一对应转换为Map。这往往是数组转为JSON的逆操作</li>                    <ul>                        <li>一般情况                            <div class="codeMirror">                                <pre><xmp>var json = '&#123;"a":1,"b":2,"c":3&#125;';var obj = JSON.parse(json);var m = new Map();for (var key of Object.keys(obj)) &#123;   m.set(key, obj[key]);&#125;console.log(m);//Map(3) &#123;"a" => 1, "b" => 2, "c" => 3&#125;</xmp></pre>                            </div>                        </li>                        <li>特殊情况                            <div class="codeMirror">                                <pre><xmp>var json='[[&#123;"a":1&#125;,1],["b",2],["c",3]]';var m=new Map(JSON.parse(json));console.log(m);//Map(3) &#123;&#123;…&#125; => 1, "b" => 2, "c" => 3&#125;</xmp></pre>                            </div>                        </li>                    </ul>                </ul>                <p></p>                <h3 id="s17.4">17.4 WeakMap</h3>                <p></p>                <p>WeakMap和Map的结果类似,也是一个类,也是用于生成键值对的集合,但是与Map依然有一些区别</p>                <p></p>                <p>区别:</p>                <p></p>                <ul>                    <li>WeakMap实例只接收对象作为键名(null除外),不能使用其它类型的值作为键名使用</li>                    <li>WeakMap的键名指向的对象是弱引用,不会计入垃圾回收机制,同WeakSet一致</li>                </ul>                <p></p>                <p>注:当我们想在某个对象上存储一些数据时,会形成对该对象的引用,从而让这个对象无法被回收,WeakMap就是为了解决这个问题而诞生的,它的键名都是弱引用,即垃圾回收机制不会将该对象的引用保留在内</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var div = document.getElementsByTagName("div");var w = new WeakMap();w.set(div, "这是div");console.log(w.get(div)); //"这是div"div = null;//清除引用对象console.log(w.get(div)); //undefined</xmp></pre>                </div>                <p></p>                <p>方法:</p>                <p></p>                <p>WeakMap实例有get(),set(),has()和delete()方法,用法同Map,也无法被遍历,也无法被清空,所以没有size属性与clear()方法</p>                <p></p>                <p>应用场景</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var element=document.getElementById("element");var w=new WeakMap();w.set(element,&#123;num:1&#125;);element.onclick=function()&#123;    var data=w.get(element);    data.num++;&#125;;/*element为一个DOM节点,每当发生点击事件的时候,就更新内部属性的值,但是确是将新值作为键值放在了WeakMap中,键名为element,当element这个DOM节点被删除后WeakMap中的值会自动消失,没有了内存泄露的风险*/</xmp></pre>                </div>            </div>            <div class="list" id="s18">                <h2>18.Proxy</h2>                <p></p>                <p>Proxy用于修改某些操作的默认行为,等同于在语言层面作出修改,所以属于一种"元编程",即对编程语言进行编程。</p>                <p>Proxy可以理解为在目标对象之前设置一层拦截,外界对该对象的访问,都必须先通过这层拦截,因此提供了一种机制.可以对外界的访问进行过滤和改写。proxy这个词的愿意是代理,用在这里表示它来代理某些操作,可以看作是代理器</p>                <p></p>                <p>Proxy实际上是重载了点运算符,用自己的定义覆盖了原始定义,而Proxy实际上也是一个类,通过构造函数的方式创建一个Proxy实例,该构造函数中有两个参数.一个是要拦截的目标对象,另一个参数也是一个对象,用来定制拦截的行为</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var p=new Proxy(target,handle);</xmp></pre>                </div>                <p></p>                <div class="codeMirror">                    <pre><xmp>var obj = &#123; a: 1, b: 2, c: 3 &#125;;var p = new Proxy(obj, &#123;    get:function(target, key, receiver) &#123;        console.log(target);        console.log(key);        console.log(receiver);        return Reflect.get(target, key, receiver);        //return target[key];下面的代码同上方    &#125;,    set:function(target,key,value,receiver)&#123;        Reflect.set(target, key, value, receiver);        //target[key]=value;下面的代码同上方&#125;&#125;);console.log(p.a);//1/*&#123;a: 1, b: 2, c: 3&#125;aProxy &#123;a: 1, b: 2, c: 3&#125;*/p.a=4;console.log(p.a);//4/*&#123;a: 4, b: 2, c: 3&#125;aProxy &#123;a: 4, b: 2, c: 3&#125;*/</xmp></pre>                </div>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>改变Proxy实例内对象的值的时候会自动执行内部的set()方法,也能够改变传入参数对象的值,但是如果通过原对象访问的属性只会返回对应对象的值,如果通过Proxy实例访问对象属性,则会执行内部的get()方法                        <div class="codeMirror">                            <pre><xmp>var obj = &#123; a: 1, b: 2, c: 3 &#125;;var p = new Proxy(obj, &#123;    get:function(target, key, receiver) &#123;        return “hello"    &#125;,    set:function(target,key,value,receiver)&#123;Reflect.set(target, key, value, receiver);&#125;&#125;);p.a=4;console.log(obj.a);//4console.log(p.a);//"hello"console.log(p.b);//"hello"console.log(p.c);//"hello"</xmp></pre>                        </div>                    </li>                    <li>如果Proxy构造函数的第二个参数是一个空对象,那么就没有任何拦截效果,访问proxy实例就等同于访问target                        <div class="codeMirror">                            <pre><xmp>var obj = &#123; a: 1, b: 2, c: 3 &#125;;    var p = new Proxy(obj, &#123;&#125;);    p.a=4;    console.log(obj.a);//4    conosole.log(p.a);//4</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <p>注:Proxy实例还可以设置很多方法,在这里值将set()与get()的用法</p>            </div>            <div class="list" id="s19">                <h2>19.Reflect</h2>                <p></p>                <p>Reflect不是一个构造函数,而是一个直接调用的对象,内部装有一些ES6中操作对象的API,里面的方法与Proxy一一对应</p>                <p></p>                <p>Reflect的用处</p>                <p></p>                <ul>                    <li>将Object对象的一些明显语言内部的方法,如Object.defineProperty等放在Reflect对象上,现在虽然在Object对象与Reflect对象中调用这些方法都可以实现,但是在以后会慢慢全部转移到Reflect对象上</li>                    <li>修改某些Object对象中的方法的返回结果,让其变得更加合理,如:                        <div class="codeMirror">                            <pre><xmp>/*比如同时定义属性的方法,在无法定义属性时,两者的表现结果完全不同*/Object.defineProperty(obj,name,value);//报错Reflect.defineProperty(obj,name,value);//返回false</xmp></pre>                        </div>                    </li>                    <li>使得对象的操作都变成函数的形式,一些对对象的操作都是命令式的,比如in与delete操作符来对对象操作                        <div class="codeMirror">                            <pre><xmp>var obj=&#123;a:1,b:2,c:3&#125;;console.log("a" in obj);console.log(Reflect.has(obj,"a"));//代替上式delete obj.a;Reflect.deleteProperty(obj,"a");//代替上式</xmp></pre>                        </div>                    </li>                    <li>Reflect对象的方法与Proxy一一对应,只要是Proxy对象的方法,就能在Reflect对象中找到对应的方法这就让Proxy对象可以方便的调用Reflect方法,完成默认行为,作为修改行为的基础</li>                </ul>            </div>            <div class="list" id="s20">                <h2>20.Promise</h2>                <p></p>                <p>Promise对象是对于JS中的异步操作的结果方案,可以说Promise是一个容器,在这里面保存了某个未来才会结束的事件(通常为一个异步操作)的结果</p>                <p></p>                <p>Promise对象代表一个异步操作,有着三种状态:</p>                <p></p>                <ul>                    <li>pending,正在进行状态</li>                    <li>fulfilled,已成功状态</li>                    <li>rejected,已失败状态</li>                </ul>                <p></p>                <p>注意:只有异步操作的结果可以决定当前是哪一种状态,任何其它的操作都无法改变该状态</p>                <p></p>                <h3 id="s20.1">20.1 优缺点</h3>                <p></p>                <ul>                    <li>优点</li>                    <ul>                        <li>Promise的状态不会受到外界的影响,并且一旦Promise的状态发生改变时,就不会再进行状态变化,任何时刻都可以得到这个状态结果</li>                    </ul>                    <li>缺点</li>                    <ul>                        <li>无法取消Promise,一旦新建就会立即执行,无法在中途取消</li>                        <li>如果不设置回调函数,Promise的内部机制会报错,不会反应到外部</li>                        <li>当处于pending正在执行的状态时,不能知道当前在哪一个阶段,不知道是否是开始还是结束</li>                    </ul>                </ul>                <p></p>                <h3 id="s20.2">20.2 用法</h3>                <p></p>                <p>Promise可以作为一个构造函数对象,传入的两个参数都是函数,第一个函数是代表成功,第二个代表失败,每个函数调用后都会在then()中找到自己对于的函数来执行</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var p=new Promise(function(success,rejected)&#123;    setTimeout(function()&#123;        try&#123;            console.log(123);            success(456);        &#125;catch&#123;            rejected("error");//在一次操作中之后进行success()函数和rejected()函数中的一个,执行        &#125;//完毕后直接到下一个步骤    &#125;,1000)&#125;).then(function(data)&#123;//执行success()后进入该函数    console.log(data);//456&#125;,function(err)&#123;//执行rejected()后进入该函数    console.log(err);//error&#125;)/*then()函数中的第一个回调函数中的参数就是在前一个异步操作中通过success()传的值,而第二个回调函数中的参数是在前一个异步操作中rejected()传的值*/</xmp></pre>                </div>                <p></p>                <div class="codeMirror">                    <pre><xmp>//Promise正确的用法是实现链式操作来实现异步var p=new Promise(function(success,rejected)&#123;    console.log(123);    success(456);&#125;).then(function(data)&#123;//假设现在只有成功才执行函数    console.log(data);//456    return 789;/*如果这里不写返回值,默认会返回undefined给下面then()中成功时的函数,注意的是这样写无论写什么普通的数据类型都是成功的,都是为下面的then()函数传递了成功时的Promise*/&#125;).then(function(data)&#123;    console.log(data);//789&#125;)</xmp></pre>                </div>                <p></p>                <div class="codeMirror">                    <pre><xmp>//链式操作中失败的时候可以执行的异步操作var p=new Promise(function(success,rejected)&#123;    try&#123;    console.log(123);    success(456);        &#125;catch&#123;        rejected("error");    &#125;&#125;).then(    function(data)&#123;        console.log(data);//456    return new Promise(function(success,rejected)&#123;        try&#123;            success(789)        &#125;catch&#123;            rejected("error");        &#125;    &#125;);&#125;,    function(err)&#123;    console.log(err);//error//失败就不会执行后面的then()了&#125;).then(    function(data)&#123;    console.log(data);//789    return new Promise(function(success,rejected)&#123;          rejected("error");//直接显示失败      &#125;);&#125;,    function(err)&#123;    console.log(err);//error&#125;).catch(    function(err)&#123;    console.log(err);//error&#125;)/*可以在最后加上catch()代表着只有在失败时才会进行的方法,该方法可以看作是then()失败时的简写,因为then()要写失败时的情况必须要传入两个参数，第二个才是失败时的参数函数,用catch()可以值捕获失败时的结果*/</xmp></pre>                </div>                <p></p>                <h3 id="s20.3">20.3 静态方法</h3>                <p></p>                <h4 id="s20.3.1">20.3.1 Promise.all()</h4>                <p></p>                <p>Promise.all()方法用于将多个Promise实例包装成一个新的Promise实例</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var p1=new Promise(function()&#123;&#125;);var p2=new Promise(function()&#123;&#125;);var p3=new Promise(function()&#123;&#125;);var p=Promise.all([p1,p2,p3]).then(function(data)&#123;console.log(data);&#125;,function(err)&#123;    console.log(err);&#125;);/*p内部的状态由p1,p2,p3决定,有两种情况:1.只有p1,p2,p3全部成功时p的状态才能使成功,p才能够执行后面成功的回调函数,此时data的值是由p1,p2,p3共同传入的值组成的数组2.只要p1,p2,p3中有一个失败,p的状态就会变成失败,p执行失败后的回调函数,此时err的值为首先完成异步并返回失败的Promise的返回值*/</xmp></pre>                </div>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>Promise,all()中包含多个Promise实例的数组,只有这多个实例全部成功,或者至少有一个失败时才会调用后面then()中的回调函数</li>                    <li>如果作为参数的Promise实例自己定义了catch()方法,那么该实例一旦失败不会触发Promise.all()后面定义的catch()方法,如果没有实例定义catch()方法,那么触发失败后会执行Promise.all()后面的catch()方法</li>                </ul>                <p></p>                <h4 id="s20.3.2">20.3.2 Promise.race()</h4>                <p></p>                <p>Promise.race()方法也用于将多个Promise实例包装成一个新的Promise实例</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var p1=new Promise(function()&#123;&#125;);    var p2=new Promise(function()&#123;&#125;);    var p3=new Promise(function()&#123;&#125;);    var p=Promise.all([p1,p2,p3]).then(function(data)&#123;        console.log(data);    &#125;,function(err)&#123;        console.log(err);    &#125;);/*p内部的状态由p1,p2,p3其中一个决定,只有其中有一个先完成异步操作,p的状态就会跟着发生改变,如果先发生成功则执行第一个回调函数,如果先发生失败则执行第二个回调函数*/</xmp></pre>                </div>                <p></p>                <h4 id="s20.3.3">20.3.3 Promise.resolve()</h4>                <p></p>                <p>Promise.resolve()方法用于将现有的对象转换为Promise对象,并且该对象中的值就是成功时的函数传入的参数</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var p=Promise.resolve(123);//等价于var p=new Promise(success,rejected)&#123;    success(123);&#125;</xmp></pre>                </div>                <p></p>                <p>该方法的参数有多种情况</p>                <p></p>                <ul>                    <li>参数为一个Promise实例<br/>不作任何改变,直接返回这个Promise实例</li>                    <li>参数为一个具有then()方法的thenable对象<br/>Prommise.resolve()方法会将这个对象转换为Promise对象,然后立即执行里面的then()方法                        <div class="codeMirror">                            <pre><xmp>var thenable=&#123;    then:function(success,rejected)&#123;        console.log(123);//123        success(456)    &#125;&#125;;var p = Promise.resolve(thenable).then(function(data) &#123;        console.log(data);//456&#125;);/*    上面的代码会在控制台上打印出来*/</xmp></pre>                        </div>                    </li>                    <li>参数为一个普通值类型的或者不是thenable对象时<br/>会直接将传入的参数作为成功时的参数传入到then()的成功函数的参数中</li>                    <li>没有参数<br/>直接得到一个成功时不传入参数的Promise对象</li>                </ul>                <p></p>                <h4 id="20.3.4">20.3.4 Promise.reject()</h4>                <p></p>                <p>Promise.reject()方法也用于将现有的对象转换为Promise对象,并且该对象中的值就是失败时的函数传入的参数</p>                <p></p>                <p>注意:Promise.reject()方法中传入的参数会原封不动的作为失败时的错误理由,不会发生参数的改变,和Promise.resolve()方法有区别</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>var p=Promise.reject("error");//等同于var p=new Promise(function(success,rejected)&#123;    rejected("error");&#125;)</xmp></pre>                </div>            </div>            <div class="list" id="s21">                <h2>21.Iterator</h2>                <p></p>                <p>Iterator(迭代器)是一种接口,或者说是一种机制。它能为各种不同的数据结构提供统一的访问机制,任何数据结构只要部署Iterator接口,就可以完成遍历操作(即依次处理该数据结构的所有成员)</p>                <p></p>                <p>作用:</p>                <p></p>                <ul>                    <li>为各种数据结构，提供一个统一的、简便的访问接口</li>                    <li>使得数据结构的成员能够按某种次序排列</li>                    <li>供for...of语句使用</li>                </ul>                <p>Iterator本质上是一个指针对象</p>                <p></p>                <p>指针实现过程</p>                <p></p>                <ol>                    <li>创建一个指针对象，指向当前数据结构的起始位置</li>                    <li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员</li>                    <li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员</li>                    <li>不断调用指针对象的next方法，直到它指向数据结构的结束位置</li>                </ol>                <p></p>                <p>一些数据结构原生就具有Iterator接口,如果没有就必须设置Iterator接口才能使用</p>                <p></p>                <ul>                    <li>普通函数实现Iterator                        <div class="codeMirror">                            <pre><xmp>function myIter(obj)&#123;    var i = 0;    return &#123;        next()&#123;          var done = (i>=obj.length);          var value = !done ? obj[i++] : undefined;          return &#123;            value,            done,          &#125;        &#125;      &#125;    &#125;</xmp></pre>                        </div>                    </li>                    <li>具有Iterator接口的原生数据结构                        <ul>                            <li>Array </li>                            <li>Map</li>                            <li>Set</li>                            <li>String</li>                            <li> 函数的 arguments 对象</li>                            <li>NodeList 对象</li>                        </ul>                    </li>                    <div class="codeMirror">                        <pre><xmp>//数组的Symbol.iterator方法var arr = ['a', 'b', 'c'];var iter = arr[Symbol.iterator]();//通过next()方法实现每一次的迭代器的遍历iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125;/*    value是每次遍历到的值,done代表是否将该数组遍历完全*/</xmp></pre>                    </div>                    <li>类数组调用数组的Symbol.iterator方法                        <div class="codeMirror">                            <pre><xmp> var iterable = &#123;    0: 'a',    1: 'b',    2: 'c',    length: 3,    [Symbol.iterator]: Array.prototype[Symbol.iterator]  &#125;;  //for...of语句实际上就是对数组使用next()方法直到将数组遍历完全  for (let item of iterable) &#123;    console.log(item); // 'a', 'b', 'c'  &#125;</xmp></pre>                        </div>                        <p></p>                        <p> 注意:</p>                        <ul>                            <li>普通对象部署数组的Symbol.iterator方法没有任何效果,必须是要属性值为数值,迭代器内部实际上是通过属性名的自增来实现迭代的                                <div class="codeMirror">                                    <pre><xmp>var iterable = &#123;    a: 'a',    b: 'b',    c: 'c',    length: 3,    [Symbol.iterator]: Array.prototype[Symbol.iterator]  &#125;;  for (let item of iterable) &#123;    console.log(item); // undefined, undefined, undefined  &#125;</xmp> </pre>                                </div>                            </li>                            <li>字符串虽然是一个类数组的对象，也具有Iterator原生接口                                <div class="codeMirror">                                    <pre><xmp>var someString = "hi";typeof someString[Symbol.iterator]// "function"var iterator = someString[Symbol.iterator]();iterator.next()  // &#123; value: "h", done: false &#125;iterator.next()  // &#123; value: "i", done: false &#125;iterator.next()  // &#123; value: undefined, done: true &#125;</xmp></pre>                                </div>                            </li>                        </ul>                    </li>                </ul>            </div>            <div class="list" id="s22">                <h2>22.Generator</h2>                <p></p>                <p>Generator函数是ES6提供的一种异步编程解决方案.,语法行为与传统的普通函数完全不同。执行Generator函数会返回一个遍历器对象。也就是说,Generator函数还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态</p>                <p></p>                <p></p>                <p>Generator函数跟普通函数的区别</p>                <p></p>                <ul>                    <li>function关键字与函数名之间有一个星号</li>                    <li>函数体内部使用yield表达式，定义不同的内部状态</li>                    <li>Generator函数不能使用new关键字,否则会报错</li>                </ul>                <p></p>                <h3 id="s22.1">22.1 用法</h3>                <p></p>                <div class="codeMirror">                    <pre><xmp>function* helloWorldGenerator() &#123;    yield 'hello';     yield 'world';     return 'ending';   &#125;      var hw = helloWorldGenerator();   console.log(hw);/*上面是一个Generator函数调用后该函数并不会运行,也不会返回函数的运行结果,而是返回的是一个遍历器对象,内部的yield表达式为一个个阶段,所以该函数一共有三个阶段状态:hello,world,与retrun语句结束执行状态*/   console.log(hw.next());//&#123;value: "hello", done: false&#125;   console.log(hw.next());//&#123;value: "world", done: false&#125;   console.log(hw.next());//&#123;value: "ending", done: true&#125;   console.log(hw.next());//&#123;value: undefined, done: true&#125;/*如果想要运行函数内部的每一个函数,就必须要调用next()方法,使得指向函数的指针移向下一个状态,每次调用next()方法时,内部指针就会从函数头部或上一层停下来的地方开始执行,直到运到下一个yiedl表达式或遇到return语句(注意遇到return语句函数会直接停止),在停止后依然能调用next()方法,但是此时的返回值为undefined   */</xmp></pre>                </div>                <p></p>                <p>总之,Generator函数是分段执行的,yield表达式是暂停执行的标记,而next()方法可以恢复执行</p>                <p></p>                <p>Genterator函数的写法</p>                <p></p>                <p>ES6并没有规定function关键字与函数名之间的星号应该写在哪个位置,所以可以用多种方法书写</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function * gen(x, y)&#123;&#125;function *gen(x, y)&#123;&#125;function* gen(x, y)&#123;&#125;///推荐使用这种形式声明Genterator函数function*gen(x, y)&#123;&#125;</xmp></pre>                </div>                <p></p>                <p>作为对象方法的Generator函数写法</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>let obj = &#123; * gen() &#123;    &#125;&#125;;</xmp></pre>                </div>                <p></p>                <p>与 Iterator 接口的关系</p>                <p></p>                <p>由于Generator函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>Object.prototype[Symbol.iterator] = function* ()&#123;    for(let i in this)&#123;        yield this[i];    &#125;  &#125;    function* iterEntries(obj) &#123;    let keys = Object.keys(obj);    for (let i=0; i < keys.length; i++) &#123;      let key = keys[i];      yield [key, obj[key]];    &#125;  &#125;    let myObj = &#123; gen: 3, bar: 7 &#125;;    for (let [key, value] of iterEntries(myObj)) &#123;    console.log(key, value);                        &#125;</xmp></pre>                </div>                <p></p>                <h3 id="s22.2">22.2 yield</h3>                <p></p>                <p>由于Generator函数返回的遍历器对象,只有调用next()方法才会遍历下一个内部状态,所以提供了一种可以暂停执行的函数,yield表达式就是暂停标志</p>                <p></p>                <p>注意：</p>                <p></p>                <ul>                    <li>yield表达式只能用在Generator函数里面，用在其他地方都会报错。</li>                    <li>将yield表达式用在另一个表达式之中，必须放在圆括号里面。</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>console.log('Hello' + (yield 123));//通过此种形式调用yield表达式,但是此时作为值的并不是123,而是下一次next()中传入的参数</xmp></pre>                </div>                <p></p>                <p>调用next()方法的运用逻辑</p>                <p></p>                <ol>                    <li>遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值</li>                    <li>下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式</li>                    <li>如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值</li>                    <li>如果该函数没有return语句，则返回的对象的value属性值为undefined</li>                </ol>                <p></p>                <p>yield与renturn的异同</p>                <p></p>                <ul>                    <li>相同点<br/>都能返回紧跟在语句后面的那个表达式的value属性值</li>                    <li>不同点<br/>每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次return语句，但是可以执行多次yield表达式。正常函数只能返回一个值，因为只能执行一次return,而Generator 函数可以返回一系列的值，因为可以有任意多个yield</li>                </ul>                <p></p>                <h3 id="s22.3">22.3 Generator的方法</h3>                <p></p>                <h4 id="s22.3.1">22.3.1 next方法的参数</h4>                <p></p>                <p>yield表达式本身没有返回值，或者说总是返回undefined。next()方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值(注意这里的返回值是在外部返回给函数内部的)</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function* f() &#123;    for(var i = 0; true; i++) &#123;        var reset = yield i;        if(reset) &#123;             i = -1;         &#125;      &#125;    &#125;        var g = f();        g.next() // &#123; value: 0, done: false &#125;    g.next() // &#123; value: 1, done: false &#125;    g.next(true) // &#123; value: 0, done: false &#125;</xmp></pre>                </div>                <p></p>                <p>Generator函数从暂停状态到恢复运行，它的上下文状态是不变的。通过next方法的参数，就可以在Generator函数开始运行之后，继续向函数体内部注入值</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function* gen(x) &#123;    var y = 2 * (yield (x + 1));    var z = yield (y / 3);    return (x + y + z);  &#125;    var a = gen(5);  console.log(a.next()); // Object&#123;value:6, done:false&#125;  console.log(a.next()); // Object&#123;value:NaN, done:false&#125;  console.log(a.next()); // Object&#123;value:NaN, done:true&#125;    var b = geno(5);  console.log(b.next()); // &#123; value:6, done:false &#125;  console.log(b.next(12));  // &#123; value:8, done:false &#125;  console.log(b.next(13));  // &#123; value:42, done:true &#125; </xmp></pre>                </div>                <p></p>                <h4 id="s22.3.2">22.3.2 return方法</h4>                <p></p>                <p>Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且立刻结束遍历Generator函数</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function* gen() &#123;    yield 1;    yield 2;    yield 3;  &#125;    var g = gen();    console.log(g.next());// &#123; value: 1, done: false &#125;  console.log(g.return('foo'))// &#123; value: "foo", done: true &#125;  console.log(g.next());// &#123; value: undefined, done: true &#125; </xmp></pre>                </div>                <h3 id="s22.4">22.4 for...of循环</h3>                <p></p>                <p>for...of循环可以自动遍历Generator函数时生成的Iterator对象，且此时不再需要调用next方法</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function *gen() &#123;    yield 1;    yield 2;    yield 3;    yield 4;    yield 5;    return 6;  &#125;    for (let v of gen()) &#123;    console.log(v);  &#125;  // 1 2 3 4 5 </xmp></pre>                </div>                <p></p>                <div class="codeMirror">                    <pre><xmp>function* gen() &#123;    let [prev, curr] = [1, 1];    while(true)&#123;        [prev, curr] = [curr, prev + curr];        yield curr;      &#125;    &#125;        for (let n of gen()) &#123;      if (n > 10000000) break;      console.log(n);    &#125; </xmp></pre>                </div>                <p></p>                <h3 id="s22.5">22.5 yield*</h3>                <p></p>                <p>*如果在Generator函数内部，调用另一个Generator函数，默认情况下是没有效果的。这个时候需要用到yield表达式来在一个Generator函数内部执行另外一个Generator函数</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>function* gen() &#123;    yield 'a';     yield 'b';    &#125;        function* bar() &#123;      yield 'x';      gen();      yield 'y';    &#125;        for (let v of bar())&#123;      console.log(v);    &#125;    // "x"    // "y"    //中间的gen()函数并没有被执行</xmp> </pre>                </div>                <p></p>                <div class="codeMirror">                    <pre><xmp>function* gen() &#123;    yield 'a';    yield 'b';&#125;function* bar() &#123;  yield 'x';  yield* gen();  yield 'y';&#125;//等同于function* bar() &#123;  yield 'x';  yield 'a';  yield 'b';  yield 'y';&#125;//等同于function* bar() &#123;  yield 'x';  for (let v of gen()) &#123;    yield v;  &#125;  yield 'y';&#125;for (let v of bar())&#123;  console.log(v);&#125;// "x"// "a"// "b"// "y" </xmp></pre>                </div>            </div>            <div class="list" id="s23">                <h2>23.async</h2>                <p></p>                <p>为了使得异步操作更加的简便,ES8标准引入了async函数,async函数是Generator函数的语法糖,基本是模仿Generator函数并作出了一些改变</p>                <p></p>                <p>async与Generator的区别</p>                <p></p>                <ul>                    <li>有了内置执行器,Generator函数的执行必须靠执行器,而async函数自带执行器。也就是说,async函数的执行，与普通函数一样,只要一行就能执行所以过程</li>                    <li>async的语义比Generator的语义更加的清楚,命名与使用async函数需要用到asyuc和await关键字,相对于Generator函数的*和yield更加让人理解,async表示函数内部有异步操作,而await表示在await后面的表达式需要等待结果</li>                    <li>yeild后面可以是任何数据类型,而正常情况下,await后面是一个Promise对象,如果并没有手动设置一个Promise对象,而后面的表达式会被转成一个立即成功(await后面上面都不写也会传undefined)的Promise对象</li>                    <li>async后的所有能返回值的结果都是Promise</li>                </ul>                <p>所以,async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await就是内部then()方法的语法糖</p>                <p></p>                <ul>                    <li>async与Generator函数的应用对比</li>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>var fn = function (time) &#123;    console.log("开始处理异步");    setTimeout(function () &#123;        console.log(time);        console.log("异步处理完成");        iter.next();      &#125;, time);        &#125;;        function* g()&#123;      console.log("start");      yield fn(3000)      yield fn(500)      yield fn(1000)      console.log("end");    &#125;        let iter = g();    iter.next();</xmp></pre>                    </div>                    <p></p>                    <li>async</li>                    <div class="codeMirror">                        <pre><xmp>var fn = function (time) &#123;    return new Promise(function (resolve, reject) &#123;        console.log("开始处理异步");        setTimeout(function () &#123;          resolve();          console.log(time);          console.log("异步处理完成");        &#125;, time);      &#125;)    &#125;;        var start = async function () &#123;      // 在这里使用起来就像同步代码那样直观      console.log('start');      await fn(3000);      await fn(500);      await fn(1000);      console.log('end');    &#125;;        start();</xmp> </pre>                    </div>                </ul>                <p></p>                <p>注意:</p>                <p></p>                <p>如果await后面的异步操作出错，那么等同于async函数返回的Promise对象直接失败,并且会将错误对象作为参数传递给then()方法的第二个函数或者catch()方法回调函数中</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>async function f() &#123;    await new Promise(function (success, rejected) &#123;        throw new Error('error');    &#125;);  &#125;    f().then(function(value)&#123;      console.log(value)  &#125;).catch(function(err)&#123;      console.log(err)//Error:error  &#125;);</xmp></pre>                </div>                <p></p>                <div class="codeMirror">                    <pre><xmp>//用try...catch来捕捉  async function f() &#123;      try &#123;          await new Promise(function(success, rejected) &#123;              throw new Error("error");          &#125;);      &#125; catch (err) &#123;          console.log(err);      &#125;      return await "hello world";  &#125;f().then(function(data) &#123;    console.log(data);&#125;);</xmp></pre>                </div>                <p></p>                <div class="codeMirror">                    <pre><xmp>//如果有多个await命令，可以统一放在try...catch结构中。    async function main() &#123;        try &#123;            var val1 = await firstStep();            var val2 = await secondStep(val1);            var val3 = await thirdStep(val1, val2);                    console.log('Final: ', val3);        &#125;          catch (err) &#123;            console.error(err);    &#125;&#125;</xmp></pre>                </div>            </div>            <div class="list" id="s24">                <h2>24.Module</h2>                <p></p>                <p>模块功能主要由两个命令构成</p>                <p></p>                <ul>                    <li>export命令用于规定模块的对外接口</li>                    <li>import命令用于输入其他模块提供的功能</li>                </ul>                <p></p>                <p>注意:</p>                <p></p>                <ul>                    <li>ES6的模块自动采用严格模式,不管有没有在模块头部加上"use strict"</li>                    <li>export与import命令可以出现在模块的任何位置,只要处于模块顶层作用域就可以,如果处于块级作用域内等就会报错</li>                </ul>                <p></p>                <h3 id="s24.1">24.1 export</h3>                <p></p>                <p>一个模块就是一个独立的文件,该文件内部的所有变量外部都无法获取。如果希望外部能够读取模块内部的某个变量,就必须使用export命令输出该变量</p>                <p></p>                <p>具体操作:</p>                <p></p>                <ul>                    <li>export实际上时导出一个接口,让外界能通过该接口访问内部的数据,所以export会将要导出的变量装在一个对象中,通过传递出这个对象来使用导出文件内部的变量,所以在导出的时候有格式要求                        <ul>                            <li>导出变量</li>                        </ul>                        <div class="codeMirror">                            <pre><xmp>//profile.js//第一种写法export var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958;//第二种写法(推荐)var firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;;//因为实际上时导出对象,所以用&#123;&#125;包裹/*    以下是错误方法*/// 报错export 1;// 报错var m = 1;export m;/*export不能直接导出一个数据或者一个变量,必须要用对象包装起来*/</xmp></pre>                        </div>                        <ul>                            <li>导出函数</li>                        </ul>                        <div class="codeMirror">                            <pre><xmp>export function multiply(x, y) &#123;    return x * y;&#125;;//当然也可以通过传入对象一起传递function multiply(x,y)&#123;    return x * y;&#125;export &#123;multiply&#125;</xmp></pre>                        </div>                    </li>                    <li>通常情况下,export导出的变量就是本来的名字,如果想要修改导出后变量的名字,可以使用as关键字重命名                        <div class="codeMirror">                            <pre><xmp>function v1() &#123; ... &#125;function v2() &#123; ... &#125;                                        export &#123;    v1 as streamV1,    v2 as streamV2,    v2 as streamLatestVersion  &#125;;   //这样在外界使用时就使用as后面被重新修改后的名字</xmp></pre>                        </div>                    </li>                    <li>export语句输出的接口,与其对应的值是动态绑定关系,即通过该接口,可以取到模块内部实时的值                        <div class="codeMirror">                            <pre><xmp>export var gender = 'boy';setTimeout(function()&#123;    gender = 'girl';&#125;, 1000);//1s后内部的值发生改变,外界引用的也会发生改变</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <h3 id="s24.2">24.2 import</h3>                <p></p>                <p>使用export命令定义了模块的对外接口以后，其他 JS文件就可以通过import命令加载并使用这个模块</p>                <p></p>                <p>具体操作:</p>                <p></p>                <ul>                    <li>使用import命令导入文件中需要的变量时也需要通过一个对象导入,并且必须与被导入摸版的对外接口(变量名)的名称一致                        <div class="codeMirror">                            <pre><xmp>// main.jsimport &#123; firstName &#125; from 'my_module';import &#123; lastName &#125; from 'my_module';import &#123; year &#125; from 'my_module';//等同于import &#123;firstName, lastName, year&#125; from './profile';console.log(firstName,lastName,year); </xmp></pre>                        </div>                        <p></p>                        <p>注:如果导入的是JS文件,后缀名可省略</p>                    </li>                    <li>如果想为输入的变量重新取一个名字,也是用as关键字将输入的变量重命名                        <div class="codeMirror">                            <pre><xmp>import &#123; lastName as surname &#125; from './profile';</xmp></pre>                        </div>                    </li>                    <li>import命令具有提升效果,会让导入的变量提升到整个模块的头部首先执行(但是不推荐这样做)                        <div class="codeMirror">                            <pre><xmp>multiply(10,20);import &#123; multiply &#125; from 'my_module';</xmp></pre>                        </div>                    </li>                    <li>由于import是静态执行,所以不能使用表达式和变量这些只有在运行时才能得到结果的语法结构                        <p></p>                        <div class="codeMirror">                            <pre><xmp>// 报错import &#123; 'mult' + 'iply' &#125; from 'my_module';// 报错let module = 'my_module';import &#123; multiply &#125; from module;// 报错if (x === 1) &#123;  import &#123; multiply &#125; from 'module1';&#125; else &#123;  import &#123; multiply &#125; from 'module2';&#125;</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <p>import引入的模块可以进行整体加载</p>                <p></p>                <p>用星号可以指定一个对象,所有输出值都加载在这个对象上面,使用整体加载时一般都是与as关键词一起用来方便操作</p>                <p></p>                <p>注意:模块整体加载所在的那个对象,不允许在运行时发生改变,如修改属性值等</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>import * as person from './profile';// 不允许以下操作person.firstName = "import";pero.son.lastName = "export";</xmp></pre>                </div>                <p></p>                <h3 id="s24.3">24.3 export default</h3>                <p></p>                <p>使用import命令的时候,需要知道所要加载的变量名或函数名,否则无法加载。为了不用阅读文档就能加载模块,需要用export default命令,为模块指定默认输出</p>                <p></p>                <ul>                    <li>导出                        <div class="codeMirror">                            <pre><xmp>// export-default.js//可以直接用于导出一个匿名函数export default function () &#123;    console.log('foo');  &#125;    //也可以导出一个非匿名函数  export default function foo() &#123;    console.log('foo');  &#125;  //或  function foo() &#123;    console.log('foo');  &#125;    export default foo;  /*  有名函数的函数名在模块外部是无效的,加载的时候,视同匿名函数加载  */ </xmp></pre>                        </div>                    </li>                    <li>导入                        <div class="codeMirror">                            <pre><xmp>// import-default.jsimport customName from './export-default';customName(); // 'foo'</xmp></pre>                        </div>                    </li>                </ul>                <p></p>                <p>注:这时import命令后面不用通过对象的包装,而是可以直接写入</p>                <p></p>                <p>原理解释</p>                <p></p>                <ul>                    <li>因为一个模块只能有一个默认输出,所以export default命令只能使用一次。这正对应了import命令后面才不用加大括号被对象包装,因为只可能唯一对应export default命令</li>                    <li>本质上,export default就是输出一个叫做default的变量或函数,然后系统外界为它取任意名字,所以:</li>                    <div class="codeMirror">                        <pre><xmp>// add.jsfunction add(x, y) &#123;    return x * y;&#125;export &#123;add as default&#125;;// 等同于export default add;</xmp></pre>                    </div>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>//main.jsimport &#123; default as add &#125; from 'add';// 等同于import foo from 'add';</xmp></pre>                    </div>                    <li>正是因为export default命令其实只是输出一个叫做default的变量,所以它后面不能跟变量声明语句                        <div class="codeMirror">                            <pre><xmp>// 正确    export var a = 1;        // 正确    var a = 1;    export default a;//实际是变量的二次赋值        // 正确    export default 1;        // 错误    export default var a = 1;</xmp></pre>                        </div>                    </li>                </ul>                <h3 id="s24.4">24.4 复合写法</h3>                <p></p>                <p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>export &#123; foo, bar &#125; from 'my_module';// 等同于import &#123; foo, bar &#125; from 'my_module';export &#123; foo, bar &#125;;</xmp></pre>                </div>                <p></p>                <p>模块的接口改名和整体输出</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>// 接口改名export &#123; foo as myFoo &#125; from 'my_module';        // 整体输出export * from 'my_module';</xmp></pre>                </div>            </div>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/HTML%E6%A0%87%E7%AD%BE/"/>
    <url>/CodeNote/2020/10/23/zone/html/HTML%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title" id="s1">            <h1>HTML</h1>        </div>        <p></p>        <div class="list">            <h2>1.meta的用法和结构</h2>            <p></p>            <div class="codeMirror">                <pre><xmp><!--<meta>标记在<head>部分--><meta charset="" http-equiv="" name="" content=""/><!-- 这样是一些字符写在一起 --><meta charser="UTF-8"/><!--定义字符编码集--><meta name="keywords" content=""/><!--为搜索引擎关键字--><meta name="description" content="  "/> <!--定义对于网页的基本描述 --><meta name="revised" content="  "/><!--定义网页的最新版本--><meta http-equiv="refresh" content="5（注释，秒）"[url="资源路径"]/><!--不写url表示每隔5秒钟刷新一次页面否者跳到资源网址--></xmp></pre>            </div>        </div>        <p></p>        <div class="list" id="s2">            <h2>2.HTML5标记</h2>            <p></p>            <p>注意：</p>            <p></p>            <ul>                <li>除了a标签以外的所有内联都不能嵌套块级标签</li>                <li>块级标签可以嵌套任意标签,但是p不能嵌套块级标签,因为嵌套关系如果P标签里面是块级就会把P标签分割成 两个独立的P标签,那个块级元素就在中间                </li>            </ul>            <p></p>            <h3 id="s2.1">2.1文本标签</h3>            <p></p>            <p>&lt;pre>&lt;/pre>标记保留了文本的所有换行与空</p>            <p>&lt;hr>&lt;/hr>用法与&lt;br>相同，只是在中间加了一条水平线</p>            <p>&lt;cite>&lt;/cite>标记用来定义作品的标题，从视觉效果上表现为斜体形式</p>            <p>&lt;ins>&lt;/ins>表示插入的文本</p>            <p>&lt;dle>&lt;/dle>表示删除的文本</p>            <p>&lt;sub>&lt;/sub>定义下标文本 <sup></sup>定义上标文本</p>            <p>例子：如上标文本可用来表示方程的平方等，下标用做方程的下标</p>            <p>&lt;ruby>&lt;/ruby >标记需要定义被旁注的文本</p>            <p>1.&lt;rt>&lt;/rt> 定义文本的注音或解释 （用做直接出现在文字上方</p>            <p>2.&lt;rp>&lt;/rp>出现在文字右方（用做不被浏览器支持的时候</p>            <p>文本可编辑属性contenteditable</p>            <p>该属性可以让在页面不能够被编辑的内容变成像表单一样的可编辑状态</p>            <p>需要在对应的标签上加上contenteditable=true的属性</p>            <p></p>            <h3 id="s2.2">2.2列表</h3>            <p></p>            <p>&lt;ul>&lt;/ul>表示无序列表</p>            <p>&lt;ol>&lt;/ol>表示有序列表</p>            <p></p>            <p>1.&lt;ol reversed="reversed">能够使序号倒序</p>            <p>2.ol标签有一个type属性,默认是让序号为阿拉伯数字,如果要是其他的样子需要用其他的字母作为值type="a"就是让序号为abcd这种,也可以写罗马数字这种t</p>            <p></p>            <p>&lt;dl>&lt;/dl>表示描述列表</p>            <p></p>            <p>1.&lt;dt>&lt;/dt>标记定义列表项（相当于标题)</p>            <p>2.&lt;dd>&lt;/dd>标记用于描述列表中的项目</p>            <div class="codeMirror">                <pre><xmp><dl><dt>  </dt><dd>  </dd><dd> </dd><!--可以自动换行--><dt>  </dt><dd>  </dd><dt>  </dt><dd>  </dd></dl></xmp></pre>            </div>        </div>        <p></p>        <div class="list" id="s3">            <h2>3.媒体</h2>            <p></p>            <h3 id="s3.1">3.1图片标签</h3>            <p></p>            <div class="codeMirror">                <pre><xmp><img src="" alt="" height="" width=""><!--如果只设置了宽和高的一个,另外一个会等比例自动变化--></xmp></pre>                <p></p>                <p>注意：如果只填了高或者宽，则另一个会按照比例变化</p>            </div>            <p></p>            <h3 id="s3.2">3.2 视频标签</h3>            <p></p>            <div class="codeMirror">                <pre><xmp><video src=" " controls="controls" autoplay="autoplay" width=" " height="" preload=" " loop="loop">您的浏览器不支持video(当浏览器不支持video时显示)</video><!--这是视频的标准语法,标签中的文字是当视频加载不成功的时候才会显示出来的--><!--controls="controls"添加浏览器为视频设置的默认控件 autoplay="autoplay"设置网页中视频加载就绪后自动播放 loop="loop"设置媒介文件循坏播放preload="auto/none/meta" 值:1.none表示不加载任何视频 2.meta表示只加载元数据（长度，尺寸等 3.auto表示让浏览器自己决定怎么做（如果引用了autoplay属性，则忽略该属性）poster='' ‘’指定加载视频时要显示的图像，接受所需图像的URL(如果引用了autoplay属性，则忽略该属性)使用方法：<video poster="网址"></video>muted="muted" 设置是否静音--></xmp></pre>            </div>            <p></p>            <h3 id="s3.3">3.3音频标签</h3>            <p></p>            <div class="codeMirror">                <pre><xmp><audio src="url" controls="controls"autoplay="autoplay"preload=" " loop="loop">浏览器不支持audio</audio></xmp></pre>            </div>            <p></p>            <h3 id="s3.4">3.4兼容写法</h3>            <p></p>            <h4 id="s3.4.1">3.4.1 source兼容</h4>            <p></p>            <p>&lt;source> &lt;source>可以连接不同的媒体文件</p>            <p></p>            <div class="codeMirror">                <pre><xmp><video width="" height="" controls="controls"><source src=" " type=""><source src=" " type=""><source src=""  type="">           浏览器不支持video元素</video><!--    type用于指定视频类型 一般有三种格式所以type一般为video/webm video/mp4 video/ogg    兼容原因：由于全球五大浏览器只支持各自的视频，source能在其中挑选出一个符合该浏览器格式的视频播放--></xmp></pre>            </div>            <p></p>            <h4 id="s3.4.2">3.4.2 插入flash文件</h4>            <p></p>            <p>用embed标签实现对flash文件的插入</p>            <p></p>            <div class="codeMirror">                <pre><xmp><embed src="url" width="" height="" type=""></xmp></pre>            </div>            <p></p>            <h4 id="s3.4.3">3.4.3 figure标签</h4>            <p></p>            <div class="codeMirror">                <pre><xmp><figure></figure><!--规定独立的流内容，将其从网页中移除不会对其他内容产生影响--><figcaption></figcaption><!--代表<figure>中的一个标题或相关解释--></xmp></pre>            </div>            <p></p>            <h4 id="s3.4.4">3.4.4 详情和概要标签</h4>            <p></p>            <div class="codeMirror">                <pre><xmp><details><summary>概要信息</summary>详情信息</details><!--当写入信息时只会在网页上显示概要信息，并且在之后又下拉式箭头，能把详情信息下拉展开出来，默认是折叠显示--></xmp></pre>            </div>        </div>        <p></p>        <div class="list" id="s4">            <h2>4.超链接</h2>            <p></p>            <h3 id="s4.1">4.1 a标签</h3>            <p></p>            <div class="codeMirror">                <pre><xmp><a href="" target="" hreflang="" title=""></a><!--href是要跳转页面的链接地址注意:<a href="">会刷新当前网页<a hred="#">不会刷新当前网页但会到网页最顶端,可以通过设置锚点的形式跳转到指定页面的指定位置(锚点由ID写入)target设置打开目标窗口的方式 如：_blank:打开一个新的窗口加载hreflang规定目标URL的基准语言title用做提示信息(可以作为简写后的补充说明)--></xmp></pre>            </div>            <p></p>            <h3 id="s4.2">4.2 map标签</h3>            <p></p>            <div class="codeMirror">                <pre><xmp><!--<map>用来创建图像映射，与<img>元素相关联 图像映射是指一个图像建立多个链接，在图像上定义多个区域，每个区域链接不同的地址--><img src="" usemap="#图像映射名称"><map name="图像映射名称">    <area shape="形状（circle rect poly四边形等)" coords="坐标" href="" title="">    <area shape="形状（circle rect poly四边形等)" coords="坐标" href="" title=""></map></xmp></pre>            </div>            <p></p>            <h3 id="s4.3">4.3 base标签</h3>            <p></p>            <div class="codeMirror">                <pre><xmp><base hred="url" target=""><!--位于<head>部分，用于浏览器不使用当前文档的url而使用<base>定义的，这样会影响到后面的元素--></xmp></pre>            </div>            <p></p>            <h3 id="s4.4">4.4 iframe标签</h3>            <p></p>            <div class="codeMirror">                <pre><xmp><iframe src="" frameborder="0" scrollinig="no">    你的浏览器不支持,请使用高版本浏览器</iframe><!--iframe标签能在原本页面中再内嵌入一个页面,这个标签的显示模式是inline-block,可以横排显示src中写要嵌入页面的域名frameborder属性就是这个标签的边框,有两个值，分别为0和1,0就是没有边框,而1是有边框,基本上都是设置为0,同时这个边框和边框线border是不冲突的,可以同时设置scrolling是控制这个标签周围是否出现滚动条,有三个值yes,no和auto,默认是yes,一般都是设置no来和页面契合注意:这个标签因为是在一个页面中再次嵌入多个页面,所以加载速度会很慢,还有很多安全性问题,尽量减少使用--></xmp></pre>                <p></p>                <pre><xmp><!--iframe标签可以和a标签搭配使用--><a href="http:\\www.tmall.com" target="tmall">跳转到天猫</a><iframe src="http:\\www.baidu.com" frameborder="0" scrollinig="no" name="tmall">    你的浏览器不支持,请使用高版本浏览器</iframe><!--    通过a标签的target绑定iframe标签的name值让点击a标签的时候不是自己网页发生跳转    而是iframe中的页面发生跳转,从百度跳转到天猫--></xmp></pre>            </div>        </div>        <p></p>        <div class="list" id="s5">            <h2>5.表格</h2>            <p></p>            <p>表格是网页制作的元老级别标签,这个标签以前用做制作网页主体,所以有许多独属于表格的属性和用法</p>            <p></p>            <div class="codeMirror">                <pre><xmp><!--<table></table>设置表格<caption></caption>为表格题目，每个表格只能设置一个题目<tr></tr>表示一行开始 <td></td>表示每一个单元格<th></th>为将内容居中并以粗体显示，常用于表头的单元格--><table border="1"><caption></caption><thead>    <tr>    <th></th>    </tr>      </thead>    <tbody>    <tr>    <td></td>    <td></td>    </tr>    <tr>    <td></td>    <td></td>    </tr>    </tbody>    <thead>    <tr>    <td></td>    </tr>        </thead></table>                                                <!--        <table border="1">说明这个表格为带表格边框的表格,但这个属性尽量不要用,能用样式解决就不要用属性        <td colspan="数字"></td>跨列,表示列合并中间的数字表示要合并的单元格列合并        <td rowspan="数字">跨行,表示行合并，行和列的合并可以一起用        如果在合并的时候出现了合并列有数据的情况可以直接把那一列删除,因为已经合并了列那一列也不需要了        表格可以嵌套表格        <thead></thead>表示表格的头        <tbody></tbody>表示表格的身体        <tfoot></tfoot>表示表格的结尾        上面三个属性是对表格结构上的解析,在写代码的时候可以不写上面三个,正常情况下不会影响表格格局，        但是可以用CSS改变表格样式,浏览器解析的时候会自动为表格加上上面的tbody属性,        所以在控制js进行选择的时候要注意,建议都加上    -->        <!--        对于table中内容的解释:        1.tbody里面的单元格默认根据内容百分比平方table的宽度和高度        2.行和列的宽度高度取决于当前行列中最宽最高的单元格        3.th内容上下左右居中对齐        4.td内容上下居中左对齐        5.给所有td固定宽高时会将表格完全等分,也可以单独给某一个td设置        6.td不支持margin,并且padding会很奇怪        7.table到td之间不能嵌套任何元素,td和th中可以有任何元素    --></xmp></pre>            </div>            <p></p>            <p>table样式</p>            <p></p>            <div class="codeMirror">                <pre><xmp>table{    border:1px solid #000；    border-spacing:0;    border-collapse:collapse;}/*    在不设置属性border="1"的时候通过上面设置css样式来让表格有边框    border-spacing属性时边框直接的距离,浏览器默认会为table旁加上这个属性并且有值,    这个时候就会看见每个表格的边框都时分离并且有一段距离的,而把这个属性设置为0时就会让距离为0,    但是会出现边框合并变粗的问题    border-collapse属性决定是否将表格边框合并默认的值时spareate分开,    当使用上面的collapse属性时则会合并表格边框,而且用了这个属性之后    border-spacing属性的距离会失效,因为边框已经合并了就没有边框距离可言了*/</xmp></pre>            </div>            <p></p>            <p>表格的特性</p>            <p></p>            <ul>                <li>表格有一个属于自己的表现形式就是display:table</li>                <li>表格的子标签td,th等的表现形式为display:table-cell意味表格细胞</li>                <li>独占一行</li>                <li>不给宽高的时候,高度和宽度由内容撑开,不向块级标签一样宽度默认是百分之百</li>                <li>支持margin属性并且支持margin:0 auto这样的形式,但是对padding属性的支持效果特别奇怪,<br/>只有当不写其余和高度宽度等相关属性的时候才生 效,所以可以说是不支持padding属性的</li>            </ul>        </div>        <p></p>        <div class="list" id="s6">            <h2>6.表单</h2>            <p></p>            <h3 id="s6.1">6.1 form标签</h3>            <p></p>            <div class="codeMirror">                <pre><xmp><form name="" method="" action="url"></form><!--name表示表单的名称method表示提交信息的方式,取值为post和get，默认为get，区别是get提交快但有限制，post提交慢无限制,get是通过网址传递，name信息写在网址后面，有缓存post不通过网址，要在控制台中查看,没有缓存action用来指定处理表单数据的程序文件所在的位置 --></xmp></pre>            </div>            <p></p>            <h3 id="s6.2">6.2 input标签</h3>            <p></p>            <div class="codeMirror">                <pre><xmp><input autpfocus="autofocus name="名称" type="类型" readonly="readonly" （只读）size="文本长度" maxlength="最大可输入字符" value="默认值"><!--inputautpfocus="autofocus"属性表示文本输入字段被设置为当页面加载时获得焦点type属性一般不可省，如果省略则默认为text类型type="password"为密码框type="submit"为提交按钮type="reset"为重置按钮，重置文本信息type="button"为普通按钮(点击按钮没有任何操作，需要用js)type="radio"为单选框，用于创建单选选项，两个单选框的name属性值必须是一样的 同时可设计checked="checked"设置默认选择type="checkbox"为多选框，同上type="url"为输入路径值，自动进行验证，不合法会有提示语句type="email"与url相同type="color" 可以在选择颜色框里任意选择颜色type="file"用于可以点击传入文件type="hidden"定义一个用户看不见的input框type="date/month/week/time/datetime/datatime-local"date为选择日，月，年 month为选择月，年 week为选择周，年 time选择时间 datetime输入时间后，会验证是否符合格式(只有这个是输入) datetime-local选择时间.日期.月,年(本地时间）<input type="image" src="" width="" height="">形成一个图像域也是图像按钮<input type="range或number" name="名称" min="" max="" step="步长" value="初始值">step为数字间的间隔，上方依旧为选择数字，调整数字时只能调整以step为间隔的数字,range与number只是在数字的选择形式上有差别                                                                                                     size表示input表单的宽度vaule表示文本框里的值，如果赋值，打开网页就直接出现相关的值，如果没有则默认打开文本框为空readonly为只读属性，将使得文本框既不能输入也不能编辑placeholder="提示文本"可以在文本区域显示一段提示语句，光标地位时语句就会消失required="required"检测输入的数据是否为空，如果为空不能提交并显示错误pattern="正则表达式"用于验证input的输入是否符合规则，不符合规则就提交不了，具体的正则表达式查表formacti在sumbit按钮里定义提交地址,这样就不用在form的action中获取提交地址了--></xmp></pre>                <p></p>                <pre><xmp> /*像input标签这样能够输入内容的独有的css属性*/    input:focus{        outline:red dashed 2px;/*这个是input的外边框,和border的属性值色设置刚好相反*/        outline-offset:5px/*边框偏移量,设置边框在偏移input外边框多远的距离显示*/    }    /*        focus表示只有当聚焦在input        一般这个ouline属属性需要用时都是设置为none    */    input::-webkit-input-placeholder{        color:red;/*选中palceholder */    }</xmp></pre>            </div>            <p></p>            <h3 id="s6.3">6.3 textarea标签</h3>            <p></p>            <div class="codeMirror">                <pre><xmp><textarea rows="行数" cols="列数"></textarea><!--    <textarea>为多行文本区域,用于需要大量文字的地方--></xmp></pre>            </div>            <p></p>            <h3 id="s6.4">6.4 select标签</h3>            <p></p>            <div class="codeMirror">                <pre><xmp><!--    <select></select>为选择菜单，能够下拉进行选择--><select multiple="multiple">    <option value="列表中的值">说明</option>    <option value="列表中的值">说明</option>    <option value="列表中的值">说明</option>    </select> <!--里面不要加label--><!--    可以加上optgroup进行分组<optgroup lable="分组名"></outgroup>    selected="selected"属性，则该选项就被默认选中    multiple="multiple" multiple属性可以多选，多选是按住ctrl--></xmp></pre>            </div>            <p></p>            <p>拓展标签datalist(不推荐使用)</p>            <p></p>            <div class="codeMirror">                <pre><xmp><!--<datalist></datalist>这个标签也可以建立列表，效果和select类似,但不能单独使用，必须和一个可输入文本框类型一起配合使用,并且可以用label属性    用法如下：--><input type="" list="要绑定的datalist的id" name="名称"><datalist id="datalist的id">                            <option label="列表项的说明" value="列表项的值"></option>        <option label="列表项的说明" value="列表项的值"></option>        <option label="列表项的说明" value="列表项的值"></option>        </datalist><!--    datalist标记只能用于标记区域范围    label属性设置列表项的标记    在设置option时必须设置value --></xmp></pre>            </div>            <p></p>            <h3 id="s6.5">6.5 label标签</h3>            <p></p>            <div class="codeMirror">                <pre><xmp><label for="控件id名称"><!--    如果你在label标签内点击文本，就会触发此控件，这个标签也可以用做包裹input框--></xmp></pre>            </div>            <p></p>            <h3 id="s6.6">6.6 fieldset标签</h3>            <p></p>            <div class="codeMirror">                <pre><xmp><fieldset><legend>控件组的标题</legend>。。。。                        。。。。</fieldset><!--将表单周围围起来--><!--    <fieldset></fieldset>对表单内部控件进行分组，还会在周围生成边框线    <legend></legend>用做标记标题使用--></xmp></pre>            </div>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/HTML5/"/>
    <url>/CodeNote/2020/10/23/zone/html/HTML5/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main" id="mianlist">        <div class="title">            <h1>HTML5</h1>        </div>        <p></p>        <div class="list" id="s1">            <h2>1.拖拽</h2>            <p></p>            <p><strong>拖拽事件需要在需要拖拽的元素上设置<code>draggable=true</code>来让该元素可以被拖拽</strong></p>            <p></p>            <h3 id="s1.1">1.1 主要事件</h3>            <p></p>            <div>                <ul>                    <li>dragstart:当用户开始拖动元素或者拖动选中文本时触发，应用在被拖拽元素上</li>                    <li>drag:当元素或者选中的文本被拖动时触发（每几百毫秒触发一次），应用在被拖拽元素上</li>                    <li>dragend:当拖动操作结束时触发（通过释放鼠标按钮或者点击转义键），应用在被拖拽元素上</li>                    <li>dragenter:当一个被拖动的元素或者选中的文本进入一个有效的放置目标时触发，应用在目标元素上</li>                    <li>dragover:当元素或者选中的文本被拖动到有效放置区域上方时触发（每几百毫秒触发一次），应用在目标元素上</li>                    <li>dragleave：当拖动元素或者选中的文本离开有效的放置区域时触发，应用在目标元素上</li>                    <li>drop:当元素或选中的文本在有效区域放置时触发，应用在目标元素上</li>                    <li>dragexit:当元素不再是拖动操作的直接选择元素时触发(很少使用</li>                </ul>            </div>            <p></p>            <h3 id="s1.2">1.2 注意事项及兼容问题</h3>            <p></p>            <div>                <ul>                    <li>ondrop事件不能调用,因为HTML元素默认是阻止放的操作的,想让这个事件被调用,必须要在正在拖拽的时候ondragover时阻止默认事件</li>                    <li>注意火狐浏览器在拖拽时需要携带数据,在其它浏览器你只需要在HTML元素上加上draggable=true即可 ,但因为火狐要求被拖动元素必须包含数据</li>                </ul>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>box.ondragstart=function(e){ e.dataTransfer.setData("index",1); /*在进行拖放操作时,e.dataTransfer对象用来保存被拖动的数据。它可以保存一项或多项数据、一种或者多种数据类型,这个对象在所有的拖动事件属性dataTransfer 都是可用的，但是不能单独创建*/} //但是火狐会默认将携带的页面,所以需要阻止事件冒泡事件和默认事件document.ondragover = function (e) {e.preventDefault();//阻止默认事件e.stopPropagation();//阻止冒泡//上面两者一起用就可以了return false;}document.ondrop = function (e) {e.preventDefault();e.stopPropagation();return false;                                                  }</xmp></pre>            </div>            <p></p>            <h3 id="s1.3">1.3 案例-将外部文件拖入盒子中</h3>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>      <meta charset="UTF-8" />      <meta name="viewport" content="width=device-width, initial-scale=1.0" />      <meta http-equiv="X-UA-Compatible" content="ie=edge" />      <title>Document</title>      <style>        * {          margin: 0;          padding: 0;        }        html,        body {          overflow: hidden;          width: 100%;          height: 100%;          background-color: pink;        }        #box {          overflow: hidden;          margin: 300px auto;          width: 1066px;          height: 150px;          background: #fff;        }      </style>    </head>    <body>      <div id="box"></div>      <script>        let box = document.getElementById("box");        box.ondrop = function(e) {          let fileReader = new FileReader();//创建一个可读文档对象          fileReader.readAsDataURL(e.dataTransfer.files[0]);//读取拖拽的文件          fileReader.onload = function(e) {//可读文档对象创建后可以进行一系列操作            let img = new Image();//创建一个img文档对象            //let img = document.createElement("img");也可以使用该方法            img.src = fileReader.result;//该数据是base64位的,特别长,所以可以使用Blob进行              /*                  const blob=new Blob([e.dataTransfer.files[0]]);                  img.src=window.URL.createObjectURL(blob);                  window.URL.createObjectURL()能将一个blob对象转换为可以使用的URL对象              */            img.style.cssText = "height:100%;width:auto";            box.appendChild(img);          };          e.preventDefault();//必须要阻止默认事件才能在盒子中展示,否则会在浏览器中打开该图片          e.stopPropagation();        };        box.ondragover = function(e) {          e.preventDefault();//必须要阻止默认事件才能在盒子中展示,否则会在浏览器中打开该图片          e.stopPropagation();        };      </script>    </body>  </html></xmp></pre>            </div>            <p></p>            <div>                <p><strong>类型文件</strong></p>                <p></p>                <p>MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。MIME消息能包含文本、图像、音频、视频以及其他应用程序专用的数据,类型大约有191种类型,不同的应用程序支持不同的 MIME 类型</p>                <p></p>                <p></p>                <p><strong>base64类型文件</strong></p>                <p></p>                <p>base64是网络上最常见的用于传输8Bit字节码的编码方式之一,base64就是一种基于64个可打印字符来表示二进制数据的方法,base64编码是从二进制到字符的过程中,可用于在HTTP环境下传递较长的标识信息</p>                <p></p>                <p></p>                <p><strong>FileReader文件对象</strong></p>                <p></p>                <p>FileReader API 用于读取文件，即把文件内容读入内存，是一种异步文件读取机制，它的参数是 File 对象或 Blob 对象。对于不同类型的文件，FileReader 提供不同的方法读取文件</p>            </div>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp>//创建读取文件的对象var reader = new FileReader();readAsDataURL(Blob|File);//读取文件并将文件以数据URI的形式保存在result属性中，返回一个基于 Base64 编码的 data-uri 对象reader.readAsDataURL(files[0]);readAsText(Blob|File, opt_encoding);/*返回文本字符串。默认情况下，文本编码格式是 UTF-8，可以通过可选的格式参数，指定其他编码格式的文本以纯文本形式读取文件，将读取到的文本保存在result属性中，第二个参数用于指定编码类型，可选的*/reader.readAsText( files[0],encoding );readAsBinaryString(Blob|File)//IE可能不支持/*返回二进制字符串，该字符串每个字节包含一个 0 到 255 之间的整数。（已废弃）读取文件并将一个字符保存在result属性中，字符串的每个字符表示一字节*/reader.readAsBinaryString(files);readAsArrayBuffer(Blob|File);//IE可能不支持/*返回一个 ArrayBuffer 对象读取文件并将一个包含文件内容的ArrayBuffer保存在result属性中*/reader.readAsArrayBuffer(files)</xmp></pre>            </div>            <p></p>            <h3 id="s1.4">1.4 dataTransfer</h3>            <p></p>            <ul>                <li>setData(format,data):设置拖拽元素的信息</li>                <ul>                    <li>format:系统默认格式为text/plain(也可以直接写text)、text/html、text/xml、text/uri-list(也可以自定义format，把format-data当key-value键值对使用)                        <div class="codeMirror">                            <pre><xmp>//兼容写法//获取URLvar url = dataTransfer.getData('url') || dataTransfer.getData('text/uri-list')//获取文本var url = dataTransfer.getData('Text') || dataTransfer.getData('text/plain')</xmp></pre>                        </div>                    </li>                    <p></p>                    <li>data:保存在拖拽元素中的数据</li>                </ul>                <li>getData(format):获取拖拽元素的信息,可以通过该方式获取选中拖入的文字,然后将文字拖到投放区</li>                <ul>                    <li>format:和setData里的format遥相呼应，才能取到相应的值</li>                </ul>                <li>clearData():清除拖拽信息</li>                <p></p>                <p><strong>dataTransfer的常用属性</strong></p>                <p></p>                <li>effectAllowed:设置拖拽时应带有的样式类型注:<br/>应该在dragstart事件中设置此属性，以便为拖动源设置所需的拖动效果,在dragenter 和dragover 事件处理程序中,该属性将设置为在dragstart 事件期间分配的任何值,因此,可以使用effectAllowed来确定允许哪个效果 值:                </li>                <ul>                    <li>none,此项表示不允许放下</li>                    <li>copy,源项目的复制项可能会出现在新位置。</li>                    <li>copyLink,允许 copy 或者 link 操作</li>                    <li>copyMove,允许 copy 或者 move 操作</li>                    <li>link,可以在新地方建立与源的链接</li>                    <li>linkMove,允许 link 或者 move 操作</li>                    <li>move,一个项目可能被移动到新位置</li>                    <li>all,允许所有的操作</li>                    <li>uninitialized,效果没有设置时的默认值，则等同于all</li>                </ul>                <li>dropEffect:设置拖拽元素被放下时的样式</li>                <li>files:内含一系列文件信息，常用于将文件从桌面拖向浏览器</li>            </ul>        </div>        <p></p>        <div class="list" id="s2">            <h2>2.Blob</h2>            <p></p>            <p><strong>file对象的父类型是Blob对象,Blob对象代表了一段二进制数据,提供了一系列操作接口</strong></p>            <p></p>            <p><strong>生成 Blob 对象有两种方法</strong></p>            <p></p>            <div>                <ul>                    <li>使用 Blob 构造函数</li>                    <li>另一种是对现有的 Blob 对象使用 slice 方法切出一部分</li>                </ul>            </div>            <p></p>            <p><strong>Blob对象有两个只读属性</strong></p>            <p></p>            <div>                <ul>                    <li>size:二进制数据的大小,单位为字节(文件上传时,可以在前端判断文件大小是否合适)</li>                    <li>type:二进制数据的 MIME 类型,全部为小写,如果类型未知,则该值为空字符串(文件上传时可以在前端判断文件类型是否合适)</li>                    <ul>                        <li> gbk编码:数字字母 一字节 1KB= 1024字节 一个中文汉字是2字节</li>                        <li>UTF-8编码:数字字母 一字节 1KB= 1024字节 一个中文汉字是3字节</li>                    </ul>                </ul>            </div>            <p></p>            <h3 id="s2.1">2.1 Bolb构造函数</h3>            <p></p>            <p><strong>Blob 构造函数接受两个参数,但是这两个参数都不是必需的</strong></p>            <p></p>            <ul>                <li>一个包含实际数据的数组</li>                <li>数据的类型</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp>var arr = ["hello", "world"]var Blob = new Blob(arr, { "type" : "text/xml" })console.log(Blob)</xmp></pre>            </div>            <p></p>            <h3 id="s2.2">2.2 Bolb对象的slice方法</h3>            <p></p>            <p><strong>Blob对象的slice方法,将二进制数据按照字节分块,并且返回一个新的Blob对象,只读取文件的一部分可以节省时间,非常适合只关注数据中某个特定部分(如文件文件)的情况</strong></p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp>var arr = ["hello", "world"]var Blob = new Blob(arr, { "type" : "text/xml" })var newBlob = Blob.slice(0, 5);//用在分片文件,后台接收把这些片段检验并组合一个文件console.log(newBlob);</xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>var reader = new FileReader()var blob = blogSlice( e.dataTransfer.files[0] , 0 , 20 )reader.readAsText( blob )if( blob ){   reader.onload = function(){box.innerHTML = this.result}}else{  alert('no data')}function blogSlice( blob,start,end ){    if( blog.slice ){return blob.slice(start,end)    }else if( blob.webkitSlice ){      return blob.webkitSlice(start,end)    }else if( blob.mozSlice ){    return blob.mozSlice(start,end)             }else{      return null    }}</xmp></pre>            </div>            <p></p>            <h3 id="s2.3">2.3 对象URL</h3>            <p></p>            <p>对象URL也被称为blob URL,指的是引用保存在File或Blob中数据的URL,使用对象URL的好处是没必要把内容读取到JS中,而直接使用文件内容,能生成一个链接,例如img.src = URL&lt;/</p>            <p></p>            <p></p>            <p><strong>创建对象URL</strong></p>            <p></p>            <p><strong>用window.URL.createObjectURL( blob )方法,并传入flle或Blob对象,对二进制数据生成一个 临时的URL,这个URL 可以放置于任何通常可以放置 URL 的地方,比如img标签的src属性</strong></p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp>function createObject(blob){if( window.URL ){    return window.URL.createObjectURL(blob)}else if( window.webkitURL ){    return window.webkitURL.createObjectURL(blob)}else{    return null}}//createObject函数的返回值是一个字符串，指向一块内存地址。因为这个字符串是URL，所以在DOM中也能使用var reader = new FileReader()var url = createObject( files[0] )if( url ){if( /image/.test(files[0].type) ){   box.innerHTML = '<img src="'+url+'" />'}else{    alert( 'no img' )}}else{alert( 'no data' )}/*直接把对象URL放在img标签中，就省去了把数据先读取js中，另一方面img标签则会找到相应的内存地址，直接读取数据并将图像显示到页面中*/</xmp></pre>            </div>            <p><strong>删除对象URL</strong></p>            <p><strong>出于一些特殊的需要,也可以使URL失效,调用window.URL.revokeObjectURL(url) 方法,使 URL失效</strong></p>            <p></p>            <h3 id="s2.4">2.4 案例-使用Bolb和对象URL下载文件</h3>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en"><head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title></head><body>        <script>          let txt = "Hello World";          create("Coloring.txt", txt);          function create(fileName, content) {            let blob = new Blob([content]);//一个bolb对象            let link = document.createElement("a");//创建一个a连接            link.download = fileName;//从浏览器下载文件的事件            link.innerHTML = content;//写入文件的内容            link.href = window.URL.createObjectURL(blob);//将blob转换为对象URL            link.click();//执行这段代码不用点击也能自动打开a标签          }        </script></body></html>                                                        </xmp></pre>            </div>            <p></p>            <h3 id="s2.5">2.5 加密</h3>            <p></p>            <h4 id="s2.5.1">2.5.1 encodeURI和decodeURI</h4>            <p></p>            <ul>                <li>encodeURI()用做将字符串转变为URL格式的编码</li>                <li>decodeURI()用做将URL格式变化转变为普通的字符串</li>            </ul>            <p></p>            <h4 id="s2.5.2">2.5.2 btoa和atob</h4>            <p></p>            <ul>                <li>btoa()用做将传入的字符串进行加密<br/><strong>注意:</strong>被转化为base64位的编码格式,不能对普通的中文编码进行加密,最好先转换为encodeURI编码</li>                <li>atob()用做将btoa()加密的字符串解密</li>            </ul>        </div>        <p></p>        <div class="list" id="s3">            <h2>3.attribute和property</h2>            <p></p>            <ul>                <li><strong>HTML标签的预定义和自定义属性统称为attribute</strong></li>                <li><strong>JS原生对象的直接属性统称property</strong></li>            </ul>            <p></p>            <h3 id="s3.1">3.1 布尔值属性与非布尔值属性</h3>            <p></p>            <p><strong>property的属性值为布尔类型的统称为布尔值属性,属性值为非布尔值类型的统称为非布尔值属性</strong></p>            <p><strong>attribute与property的同步关系</strong></p>            <ul>                <li><strong>非布尔值属性:</strong>实时同步</li>                <li><strong>布尔值属性:</strong></li>                <ul>                    <li>property永远不会同步attribute</li>                    <li>在没有动过property的情况下,attribute会同步property,在动过property的情况下,attribute不会同步property</li>                </ul>                <p></p>                <p><strong>注意:</strong></p>                <p></p>                <ul>                    <li>用户操作的是property</li>                    <li>浏览器认的是property</li>                </ul>            </ul>        </div>        <p></p>        <div class="list" id="s4">            <h2>4.Canvas</h2>            <p></p>            <h3 id="s4.1">4.1 什么是Canvas?</h3>            <p></p>            <p><strong>canvas是HTML5新增元素,可用于通过使用JS绘制图形,可以使用canvas标签定义一个canvas元素</strong></p>            <p></p>            <p><strong>注意:</strong></p>            <p></p>            <ul>                <li>使用canvas标签时建议成对出现,不要使用闭合形式</li>                <li>canvas元素具有默认宽高,width:300px;height:150px</li>            </ul>            <p></p>            <p><strong>替换内容</strong></p>            <p></p>            <p><strong>有些浏览器不支持使用canvas,可以在canvas标签中提供需要替换的内容,支持canvas的浏览器会正常显示canvas,不会显示其中的内容,而不支持canvas的浏览器会显示替代内容</strong></p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>Document</title></head><body>    <canvas><span>您当前的浏览器版本太低,请更新到最新版本</span></canvas>    <script>            let canvas=document.querySeletor("canvas");          if(canvas){//如果能正常获取                 let ctx=canvas.getContext("2d");//2d方式获取上下文内容             }    </script></body></html>                                 </xmp></pre>            </div>            <p></p>            <h3 id="s4.2">4.2 画布API</h3>            <p></p>            <ul>                <li>canvas标签只有width和height两个属性,并且这两个属性都是可选的,如果没有设置height和width,canvas会初始化宽度为300px和高度150px</li>                <li>canvas标签有一个方法<strong>getContext()</strong>用于获取上下文</li>            </ul>            <p></p>            <p><strong>画布中的width与height</strong></p>            <p></p>            <ul>                <li>HTML属性中设置的高宽只会影响画布本身的宽高而不会影响其中内容的宽高</li>                <li>CSS属性中设置的高宽不但会影响画布本身的高宽,还会使得画布中的内容等比例缩放(缩放参照于画布默认的尺寸)</li>            </ul>            <p></p>            <h3 id="s4.3">4.3 绘制矩形</h3>            <p></p>            <p><strong>canvas提供了三种方法绘制矩形</strong></p>            <p></p>            <ul>                <li>fillRect(x,y,width,height),绘制一个填充的矩形(填充色默认为黑色)</li>                <li>strokeRect(x,y,width,height),绘制一个矩形的边框(默认的边框颜色为1px实心黑色)</li>                <li>clearRect(x,y,width,height),清除指定的矩形区域,让清除部分完全透明</li>            </ul>            <p></p>            <p><strong>注：</strong></p>            <p></p>            <ul>                <li>x与y指定了在canvas画布上所绘制的矩形的左上角(相对于原点)的坐标,width与height设置矩形的尺寸,如果存在边框,边框会在width与height上占据一个边框的宽度</li>                <li>里面所有的参数都不带任何单位</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp>let canvas=document.querySeletor("canvas");let ctx=canvas.getContext("2d");ctx.fillRect(0,0,100,100);ctx.strokeRect(100,100,100,100);ctx.clearRect(100,100,100,100);</xmp></pre>            </div>            <p></p>            <p><strong>使用strokeRect时边框出现的像素渲染问题</strong></p>            <p></p>            <p><strong>按理说如果是使用的默认的边框边框的宽度应该是1px,但是canvas在渲染边框时,边框的宽度是平均在偏移位置的两侧进行渲染的</strong></p>            <p></p>            <div class="codeMirror">                <pre><xmp>let canvas=document.querySeletor("canvas");let context=canvas.getContext("2d");context.strokeRect(10,10,50,50);//边框会渲染在10.5与9.5之间,但是浏览器不会让一个像素只占一半,所以边框会被渲染在11与9之间,边框宽度为2context.strokeRect(10.5,10.5,50,50);//如果这样写的话边框就会渲染在10与11之间,向上取整</xmp></pre>            </div>            <p></p>            <h4 id="s4.3.1">4.3.1 添加样式颜色</h4>            <p></p>            <ul>                <li><strong>fillStyle</strong>,设置矩形的填充颜色</li>                <li><strong>strokeStyle</strong>,设置图形轮廓的颜色,默认情况下填充的颜色都是黑色</li>                <li><strong>lineWidth</strong>,设置当前绘制线条的颜色,值必须为正数,默认是1,如果值是0,负数,infinity和NaN时会被忽略</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp>let canvas=document.querySeletor("canvas");let ctx=canvas.getContext("2d");ctx.fillStyle="pink";ctx.stokeStyle="red";ctx.lineWidth=50;ctx.fillRect(0,0,100,100);ctx.strokeRect(100,100,100,100);ctx.clearRect(100,100,100,100);</xmp></pre>            </div>            <p></p>            <p><strong>注意:</strong></p>            <p></p>            <ul>                <li>canvas内部的样式是同步布置的,所以绘制的调用先后会对最后的结果产生很大的影响,如果想最开始就有样式的话就需要先在前面定义了样式后再进行绘制,同时后面绘制的图形的层级比前面的高,所以会覆盖住前面的图形</li>                <li>填充图形的样式不会作用给线条图形,线条图形也不会影响到填充图形,并且lineWidth属性也只会作用给线条图形</li>            </ul>            <p></p>            <h4 id="s4.3.2">4.3.2 设置线条接合样式</h4>            <p></p>            <p><strong>lineJoin能设置线条与线条之间接合处的样式,默认是miter直角</strong></p>            <p></p>            <p><strong>值:</strong></p>            <p></p>            <ul>                <li>round:圆角</li>                <li>bevel:斜角</li>                <li>miter:直角</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp>let canvas=document.querySeletor("canvas");let ctx=canvas.getContext("2d");ctx.lineJoin="round";ctx.strokeRect(100,100,100,100);</xmp></pre>            </div>            <p></p>            <h3 id="s4.4">4.4 绘制路径</h3>            <p></p>            <p>图形的基本元素是路径,路径是通过不同颜色和宽度的线段或曲线相连而成的不同形状的集合</p>            <p></p>            <p><strong>绘制路径的步骤</strong></p>            <p></p>            <ul>                <li>先创建路径起始点</li>                <li>再使用画图命令绘画路径</li>                <li>把路径封闭</li>                <li>一旦路径生成,就能通过描边或填充路径区域来渲染图形</li>            </ul>            <p></p>            <h4 id="s4.4.1">4.4.1 路径方法</h4>            <p></p>            <ul>                <li>beginPath(),新建一条路径,生成之后图形绘制命令被指向到路径上准备生成路径,生成路径的第一步就是先使用beginPath()。本质上,路径是由很多子路径构成,这些子路径都是在一个列表里,所有的子路径(线、弧形等)构成图形。而每次调用该方法后列表都会被清空重置,我们就可以重新绘制新的图形</li>                <li>moveTo(x,y),将触笔移动到指定的坐标x以及y上,当canvas初始化或者beginPath()调用后,通常会使用moveTo()设置起点</li>                <li>lineTo(x,y),绘制一条从当前位置到指定x以及y位置的直线</li>                <li>closePath(),闭合路径之后图形绘制命令又重新指向到上下文,该方法并不是必须要调用,该方法会通过绘制一条从当前点到开始点的直线来闭合图形,如果图形已经闭合了,该方法不会有任何作用 注:当调用fill()函数后所有没有闭合的形状都会自动闭合,不需要该函数,而如果调用stroke()函数就不会自动闭合路径                </li>                <li>stroke(),通过线条来绘制图形轮廓,该函数不会自动调用closePath()</li>                <li>fill(),通过填充路径的内容区域生成实心的图形,该函数会自动调用closePath()</li>                <li>rect(x,y,width,height),绘制一个左上角(x,y),宽高为width和height的矩形,当该方法执行的时候,moveTo()会自动设置坐标参数为(0,0),也就是说当前笔触会自动充值坐标</li>                <li>lineCap,lineCap是Canvas 2D API指定如何绘制每一条线代末端的属性,该属性默认值是butt,线段末端以方形结束</li>                <li>值:</li>                <p></p>                <ul>                    <li>butt:线段末端以方形结束</li>                    <li>round:线段末端以圆形结束</li>                    <li>square:线段末端以方形结束,但是增加了一个宽度和线段相同,高度是线段厚度一半的矩形区域</li>                </ul>                <p></p>                <li> save(),save()是Canvas 2D API通过将当前样式状态放入样式栈中,保存canvas全部状态的方法 保存到样式栈中额绘制状态由下面几个部分组成:</li>                <p></p>                <ul>                    <li>当前的变换矩阵</li>                    <li>当前的剪切区域</li>                    <li>当前的虚线列表</li>                    <li>strokeStyle,fillStyle,lineWidth,lineCap,lineJoin等当前的值</li>                </ul>                <p></p>                <li>restore(),restore()是Canvas 2D API通过在绘图状态栈中弹出顶端的状态,可以将canvas恢复到最近的保存状态的中,如果没有保存该方法不做任何改变</li>            </ul>            <p></p>            <li><strong>注意:</strong></li>            <p></p>            <ul>                <li>save()和restore()方法需要成对出现使用</li>                <li>save()和restore()是控制样式的设置,而beiginPath()是关于路径的设置</li>            </ul>            <p></p>            <h4 id="s4.4.2">4.4.2 路径容器与样式容器</h4>            <p></p>            <ul>                <li><strong>路径容器:</strong>每次调用关于路径的API时,都会往路径容器中添加路径做登记,调用beginPath()时,情况整个路径容器</li>                <li><strong>样式容器:</strong>每次调用样式API时,都会往样式容器里做登记,调用save()的时候,将样式容器里的状态记入样式栈,调用restore()的时候,将样式栈的栈顶状态弹出到样式容器里进行覆盖</li>                <li><strong>样式栈:</strong>调用save()的时候,将样式容器里的状态记入样式栈,调用restore()的时候,将样式栈的栈顶状态弹出到样式容器里进行覆盖</li>            </ul>            <p></p>            <h4 id="s4.4.3">4.4.3 绘制圆形</h4>            <p></p>            <p><strong>角度与弧度的转化表达式:radians=(Math.PI/180)*degrees</strong></p>            <p></p>            <ul>                <li>arc(x,y,radius,startAngle,endAngle,anticlokwise),该方法用于画一个以(x,y)为圆心的以radius为半径的圆弧(圆),从startAngle开始到endAngle结束,按照anticlockwise给定的方向(该值为一个布尔值,默认为false顺时针方向)来生成</li>                <li>                    <ul>                        <li>x,y为绘制圆弧所在圆上的圆心坐标,相对于原点</li>                        <li>radius为半径</li>                        <li>startAngle和endAngle参数用弧度定义了开始以及结束位置的弧度,都是以x轴为基准参数</li>                        <li>anticlockwise为一个布尔值,当值为true时代表逆时针方向,为false时代表顺时针方向</li>                    </ul>                </li>                <li>arcTo(x1,y1,x2,y2,radius),根据给定的控制点和半径画一段圆弧 注意:使用该方法其实需要三个控制点,第一个控制点是第一次使用moveTo()时给定的地方,从哪个地方其向(x1,y1)方向进行画圆弧,也就是说该圆弧必定经过moveTo()设定的第一个点和(x2,y2),但不一定经过(x1,y1),这个坐标只是为了控制圆弧的方向,而圆弧的半径设置就是用一个半径为radius的圆往两个控制点夹角进行移动,直到刚好能够卡住两条夹线                </li>                <li>quadraticCurveTo(cp1x,cp1y,x,y),该方法用于绘制二次贝塞尔曲线,(cp1x,cp1y)为一个控制点,(x,y)为结束点,起始点为moveTo()刚抬起指定的点</li>                <li>bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y),该方法用于绘制三次贝塞尔曲线,(cp1x,cp1y)为一个控制点,(cp2x,cp2y)为第二个控制点,(x,y)为结束点,起始点为moveTo()刚抬起指定的点</li>            </ul>            <p></p>            <h3 id="s4.5">4.5 变换</h3>            <p></p>            <ul>                <li>translate(x,y),该方法用于移动canvas的坐标原点(默认是左上角),该方法接收两个参数,x为水平偏移量,y为垂直偏移量 注意:在canvas中translate()方法造成的结果是累加的                </li>                <li>rotate(angle),该方法只接收一个参数旋转的角度(angle),该旋转方向为顺时针方向,以弧度为单位的值,用于旋转整个canvas画布</li>                <li>scale(x,y),该方法接收两个参数,x和y分别代表横轴和纵轴的缩放因子,这两个值都必须为正值,当值小于1.0代表缩小,大于1.0代表放大<strong>注意:</strong> scale()方法中的缩小和放大是相对于整个canvas画布的像素数目,放大总个数会减少,单个像素的实际物理尺寸变大,而缩小总个数会增多,单个像素的实际物理尺寸减小,对图像、位图进行缩小或放大,并且在canvas中scale()方法是累乘的                </li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp>let canvas=document.querySeletor("canvas");let ctx=canvas.getContext("2d");ctx.translate(50,50);ctx.rotate(Math.PI*90/180);ctx.scale(.5,.5);</xmp></pre>            </div>            <p></p>            <h3 id="s4.3">4.6 图片操作</h3>            <p></p>            <h4 id="s4.6.1">4.6.1 插入图片</h4>            <p></p>            <p><strong>drawImage(image,x,y,width,height)方法用于在canvas中插入图片</p>                    <p><strong>参数:</strong></p>            <p></p>            <ul>                <li>image为image对象或者canvas对象</li>                <li>x,y是插入的图片在目标canvas里的起始坐标</li>                <li>width和height是用来控制插入的图片在canvas中应该显示的大小</li>            </ul>            <p></p>            <p><strong>注意:</strong>在canvas中插入图片需要使用image对象,并且必须要等图片加载完成后才能进行操作,所以需要在image对象执行onload事件后再执行canvas插入图片的函数</strong>            </p>            <p></p>            <div class="codeMirror">                <pre><xmp>let canvas=document.querySeletor("canvas");let ctx=canvas.getContext("2d");let img=new Image();img.src="1.jpg";img.onload=function(){ctx.drawImage(this,100,100,img.width,img.height);}</xmp></pre>            </div>            <p></p>            <h4 id="s4.6.2">4.6.2 设置背景</h4>            <p></p>            <p><strong>createPattern(image,repetition)方法用于在canvas中设置背景</strong></p>            <p><strong>参数:</strong></p>            <p></p>            <ul>                <li>image为image对象等图像源</li>                <li>repetition为背景在canvas中平铺方式,值为"repeat","repeat-x","repeat-y"和"no-repeat"</li>                <p><strong>注意:该方法会返回一个对象,一般情况下我们都会将该方法返回的对象作为fillStyle的值进行填充</strong></p>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp>let canvas=document.querySeletor("canvas");let ctx=canvas.getContext("2d");let img=new Image();img.src="1.jpg";img.onload=function(){    let pattern=ctx.createPattern(img,"no-repeat");    ctx.fillStyle=pattern;    ctx.fillRect(0,0,300,300);//在绘制的矩形中进行背景的填充    }</xmp></pre>            </div>            <p></p>            <h3 id="s4.7">4.7 设置渐变</h3>            <p></p>            <ul>                <li>线性渐变</li>                <ul>                    <li>createLinearGradient(x1,y1,x2,y2)方法设置线性渐变的终点与起点,(x1,y1)表示起点,(x2,y2)表示终点 注意:该方法会返回一个对象gradient,通过该对象能对线性渐变的颜色等进行具体的设置,同时该对象一般赋值给fillStyle属性                    </li>                    <li>gradient.addColorStop(position,color)</li>                    <p></p>                    <ul>                        <p><strong>参数:</strong></p>                        <p></p>                        <li>positon,该参数的值为一个0.0到1.0之间的数值,表示渐变中颜色所在的相对位置,表示从哪个比例开始进行颜色的渐变</li>                        <li>color,该参数必须是一个有效的CSS颜色值,如十六进制数或rgb等</li>                    </ul>                </ul>            </ul>            <p></p>            <p><strong>注意:该方法该可以调用多次,加入的颜色会存入栈中,根据所在位置的不同在调用时会显示不用的渐变颜色</strong></p>            <p></p>            <div class="codeMirror">                <pre><xmp>let canvas=document.querySeletor("canvas");let ctx=canvas.getContext("2d");let gradient=ctx.createLinearGradient(0,0,300,300);gradient.addColorStop(0,"red");gradient.addColorStop(0.5,"red");gradient.addColorStop(1,"green");ctx.fillStyle=gradient;ctx.fillRect(0,0,300,300);</xmp></pre>            </div>            <ul>                <li>径向渐变</li>                <ul>                    <li>createRadialGradient(x1,y1,r2,x2,y2,r2)方式设置径向渐变的终点圆和起点圆,前三个参数表示以(x1,y1)为圆点,r1为半径的圆。后三个参数表示以(x2,y2)为圆点,r2为半径的圆</li>                    <li>gradient.addColorStop(position,color)</li>                    <p></p>                    <ul>                        <p><strong>参数:</strong></p>                        <p></p>                        <li>positon,该参数的值为一个0.0到1.0之间的数值,表示渐变中颜色所在的相对位置,表示从哪个比例开始进行颜色的渐变</li>                        <li>color,该参数必须是一个有效的CSS颜色值,如十六进制数或rgb等</li>                    </ul>                </ul>                <p></p>                <p><strong>注意:</strong>该方法该可以调用多次,加入的颜色会存入栈中,根据所在位置的不同在调用时会显示不用的渐变颜色</p>                <p></p>                <div class="codeMirror">                    <pre><xmp>let canvas=document.querySeletor("canvas");let ctx=canvas.getContext("2d");let gradient=ctx.createRadialGradient(150,150,50,150,150,100);//在两个圆之间的区域会形成渐变gradient.addColorStop(0,"red");gradient.addColorStop(0.5,"red");gradient.addColorStop(1,"green");ctx.fillStyle=gradient;ctx.fillRect(0,0,300,300);</xmp></pre>                </div>            </ul>            <p></p>            <h3 id="s4.8">4.8 绘制文本</h3>            <p></p>            <p><strong>在canvas中可以使用两种方法来绘制文本</strong></p>            <p></p>            <ul>                <li>fillText(text,x,y),text为要写入的文本,(x,y)位置表示填充指定的文本</li>                <li>strokeText(text,x,y),text为要写入的文本,(x,y)位置表示填充指定的文本</li>            </ul>            <p></p>            <h4 id="s4.8.1">4.8.1 文本样式</h4>            <p></p>            <ul>                <li>font = "font-size font-family" ,当前我们用来绘制文本的样式,该属性和CSS中的font属性的语法相同,默认的字体为font="10px sans-serif" 注意:当要使用font属性时,必须要大小和字体同时存在,缺一不可                    <p></p>                    <div class="codeMirror">                        <pre><xmp>let canvas = document.querySelector("canvas");let ctx = canvas.getContext("2d");ctx.strokeText("canvas", 100, 100);ctx.fillText("canvas", 100, 100);</xmp></pre>                    </div>                    <p></p>                </li>                <li>textAlign="value",文本对齐属性,可选的值为right,left,center,start,end,其中start和end分别对应left和right,默认值是left 注意:这里的文本对齐和CSS中的文本对齐不一样,这里的left和right都是相对于fillText()和strokeText()指定的位置时的偏差,默认是最坐标的文字靠近指定点的x,而center与right这些指定就是将写在一起的文字的中部和最右边靠近指定点                </li>                <p></p>                <li>textBaseline="value",该属性用于描述文本时文本基线的属性 值:</li>                <p></p>                <ul>                    <li>alphabetic,默认值,文本基线是普通的字母基线</li>                    <li>top文本基线是 em 方框的顶端,em方框是包裹整个默认文字基线的方框 </li>                    <li>hanging,文本基线是悬挂基线</li>                    <li>middle,文本基线是 em 方框的正中</li>                    <li>ideographic,文本基线是表意基线</li>                    <li>bottom,文本基线是 em 方框的底端</li>                </ul>                <p></p>                <li>measureText(text),该方法返回一个TextMetrics对象,包含了关于文本尺寸的信息(例如文本的宽度),参数是需要测试文本信息的字符串</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp>let canvas = document.querySelector("canvas");let ctx = canvas.getContext("2d");                               ctx.fillStyle="red";//文字的颜色也是通过该样式来改变的ctx.strokeStyle="blue";ctx.font="50px sans-serif";ctx.textAlign="center";ctx.textBaseline="middle";//注意在绘制之前要先设置样式ctx.strokeText("canvas", 100, 100);ctx.fillText("canvas", 100, 100);console.log(ctx.measureText("canvas").width);</xmp></pre>            </div>            <p></p>            <h4 id="s4.8.2">4.8.2 文本水平垂直居中</h4>            <p></p>            <div class="codeMirror">                <pre><xmp>let canvas = document.querySelector("canvas");let ctx = canvas.getContext("2d");ctx.font="50px sans-serif";ctx.textBaseline="middle";let width=ctx.measureText("canvas").width;ctx.fillText("canvas",(canvas.width-width)/2,(canvas.height-50)/2);</xmp></pre>            </div>            <p></p>            <h4 id="s4.8.3">4.8.3 文本阴影</h4>            <p></p>            <ul>                <li>shadowOffsetX="value",该属性用来设置阴影在X轴的延伸距离,默认是0</li>                <li>shadowOffsetY="value",该属性用来设置阴影在Y轴的延伸距离,默认是0</li>                <li>shadowBlur="value",该属性用于设置阴影的模糊度,其数值并不跟像素挂钩,也不受变换矩阵的影响,默认为0</li>                <li>shadowColor="color",用于设置阴影颜色,该颜色的值为标准的CSS颜色值 默认是全透明的黑色:rgba(0,0,0,0)                    <li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp>let canvas = document.querySelector("canvas");let ctx = canvas.getContext("2d");ctx.shadowOffsetX = "10";ctx.shadowOffsetXY = "-10";ctx.shadowColor = "red";ctx.shadowBlur = "5";ctx.fillText("canvas",100,100);</xmp></pre>            </div>            <p></p>            <p><strong>注意:</strong>因为默认的颜色是透明的黑色,所以如果想要有阴影必须要设置阴影的颜色</p>            <p></p>            <h3 id="s4.9">4.9 像素操作</h3>            <p></p>            <p><strong>在canvas中,我们可以直接通过ImageData对象操纵像素数据,直接读取或将数据数组写入该对象中</strong></p>            <p></p>            <ul>                <li>getImageData(sx,sy,sw,sh),该方法用做获取一个ImageData对象,代表了画布区域的对象数据 参数:                </li>                <ul>                    <li>sw:将要被提取的图像数据矩阵区域的左上角x坐标</li>                    <li>sy:将要被提取的图像数据矩阵区域的左上角y坐标</li>                    <li>sw:将要被提取的图像数据矩形区域的宽度</li>                    <li>sh:将要被提取的图像数据矩形区域的高度</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>let canvas = document.querySelector("canvas");let ctx = canvas.getContext("2d");ctx.fillStyle = "rgba(255,192,203,1)";ctx.fillRect(0, 0, 100, 100);let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);</xmp></pre>                </div>                <p></p>                <li>ImageData对象,该对象中存储着canvas对象真实的像素数据,包含以下几个属性:</li>                <p></p>                <ul>                    <li>width:图片宽度,单位为px</li>                    <li>height:图片高度,单位为px</li>                    <li>data:Uint8ClampeArray类型的一维数组,包含着rgba格式的整形数据,范围在0到255之间(包括255) 注:该属性保存了每一个像素所占的rgba值,数组中的每四个数据就是一个像素的完整rgba值,并且值都是0到255,由黑色到白色,注意这里的a(透明度)的值也是0到255,和CSS中的透明度的算法不同                    </li>                </ul>                <p></p>                <li>putImageData(ImageData,dx,dy),该方法用于对场景进行像素数据的写入 参数:                </li>                <p></p>                <ul>                    <li>ImageData:为一个ImageData对象,该对象就是要写入的像素数据</li>                    <li>dx:要绘制图形的x坐标</li>                    <li>dy:要绘制图形的y坐标</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><xmp>let canvas = document.querySelector("canvas");let ctx = canvas.getContext("2d");ctx.fillStyle = "rgba(255,192,203,1)";ctx.fillRect(0, 0, 100, 100);let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);ctx.putImageData(imgData,100,100);</xmp></pre>                </div>                <p></p>                <li>createImageData(width,height),该方法用于直接创建一个ImageData对象 参数:                </li>                <p></p>                <ul>                    <li>width:新对象的宽度</li>                    <li>height:新对象的高度</li>                </ul>            </ul>            <p></p>            <p><strong>注意:</strong>默认情况下创建出来的ImageData对象是完全透明的,颜色为rgba(0,0,0,0)</p>            <p></p>            <div class="codeMirror">                <pre><xmp>let canvas = document.querySelector("canvas");let ctx = canvas.getContext("2d");let imgData=ctx.createImageData(100,100);for(let i=0;i<imgData.data.lenght;i++){    imgData.data[4*i+3]=255;//该索引可以取得每一个像素的透明度,同时设置为255不透明    }    ctx.putImageData(imgData,100,100);</xmp></pre>            </div>            <p></p>            <p><strong>获取单像素颜色</strong></p>            <p></p>            <div class="codeMirror">                <pre><xmp>//通过传入imgdata和需要获取的像素点得到颜色function getPxInfo(imgdata,x,y){    let color=[];    let data=imgdata.data;    let w=imgdata.width;    let h=imgdata.height;    //x代表多少行,y代表多少列    color[0]=data[(y*w+x)*4];    color[1]=data[(y*w+x)*4+1];    color[2]=data[(y*w+x)*4+2];    color[3]=data[(y*w+x)*4+3];    return color; }</xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>let canvas = document.querySelector("canvas");let ctx = canvas.getContext("2d");ctx.fillStyle = "rgba(255,192,203,1)";ctx.fillRect(0, 0, 100, 100);let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);let color=getPxInfo(imgdata,20,20);</xmp></pre>            </div>            <p></p>            <p><strong>设置单像素颜色</strong></p>            <p></p>            <div class="codeMirror">                <pre><xmp>function setPxInfo(imgdata,x,y,color){//color为传入的一个代表0到255的四个成员的数组let data=imgdata.data;let w=imgdata.width;let h=imgdata.height;data[(y*w+x)*4]=color[0];data[(y*w+x)*4+1]=color[1];data[(y*w+x)*4+2]=color[2];data[(y*w+x)*4+3]=color[3]; }</xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>let canvas = document.querySelector("canvas");let ctx = canvas.getContext("2d");ctx.fillStyle = "rgba(255,192,203,1)";ctx.fillRect(0, 0, 100, 100);let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);for(let i=0;i<imgData.width;i++){    setPxInfo(imgData,i,50,[0,0,0,255]);//通过循环可以设置一行的像素    }    ctx.putImageData(imgData, 0, 0);//要想让画布重新渲染,必须要使用该函数将已经改变了的imgData传入</xmp></pre>            </div>            <p></p>            <h3 id="s4.10">4.10 合成</h3>            <p></p>            <h4 id="s4.10.1">4.10.1 全局透明度</h4>            <p></p>            <p><strong>globalAlpha="value",该属性设置或返回绘图的当前alpha或透明值,这个属性影响到canvas里所有图形的透明度,有效的值范围是0.0(完全透明)到1.0(完全不透明),默认值为1.0</strong></p>            <p></p>            <h4 id="s4.10.2">4.10.2 覆盖合成</h4>            <p></p>            <p><strong>globalCompositeOperation="value",设置或返回新图像如何绘制到已有的图像上</strong></p>            <p></p>            <p><strong>可用的值:</strong></p>            <p></p>            <ul>                <li>source-over,在目标图像上显示源图像,新的图像层级比较高,该值为默认值</li>                <li>source-atop,在目标图像顶部显示源图像,源图像位于目标图像之外的部分是不可见的,也就是砍掉溢出的源图像部分</li>                <li>source-in,在目标图像中显示源图像,只有目标图像内的源图像部分会显示,目标图像是透明的,也就是只留下源图像与目标图像重复的部分(源图像的那部分)</li>                <li>source-out,在目标图像之外显示源图像。只会显示目标图像之外源图像部分,目标图像是透明的。也就是只留下源图像超出目标的部分</li>                <li>destination-over,在源图像上方显示目标图像,目标图像的层级较高</li>                <li>destination-atop,在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。也就是砍掉溢出的目标图像部分</li>                <li>destination-in,在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。也就是只留下源图像与目标图像重复的部分(目标图像的那部分)</li>                <li>destination-out,在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。也就是只留下超出源图像的部分</li>                <li>lighter,显示源图像和目标图像</li>                <li>copy ,显示源图像。忽略目标图像</li>                <li>xor,使用异或操作对源图像与目标图像进行组合</li>            </ul>            <p></p>            <p><strong>注意:</strong></p>            <p></p>            <ul>                <li>source:新的图像(源)</li>                <li>destination:已经绘制过的图像(目标)</li>                <li>globalCompositeOperation属性应该在第一个图像绘制后第二个图像回之前使用</li>            </ul>            <p></p>            <h3>4.11 导出与事件操作</h3>            <p></p>            <ul>                <li>将画布导出为图片 火狐、谷歌浏览器右键菜单可直接导出为图片,但是如果为手机端可以使用内置的API方法导出                </li>                <ul>                    <li>canvas.toBlob(),把canvas图片数据转换成 blob对象</li>                    <li>canvas.toDataURL(),默认导出data:png,为base64编码的二进制URL</li>                    <li>canvas.toDataURL('image/jpeg'),导出data:jpg,为base64编码的二进制URL</li>                </ul>            </ul>            <p></p>            <p><strong>注意:</strong>这些API由画布本身调用</p>            <p></p>            <ul>                <li><strong>事件操作</strong> ctx.isPointInPath(x,y),判断在当前路径是否包含有检测点,就是通过检测clientX和clientY来进行判断是否触发到了画布上的路径,x代表检测点的x坐标,y代表检测点的y坐标,两者都是相对于画布本身来说的 注意:此方法只作用于最新画出的canvas路径图像                </li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp>let canvas = document.querySelector("canvas");let ctx = canvas.getContext("2d");ctx.arc(100,100,50,0,360*Math.PI/180);ctx.fill()ctx.beginPath();//如果没有这个那么下面的代码可以在两个圆中都实现效果ctx.arc(200,200,50,0,360*Math.PI/180);ctx.fill();canvas.onclick=function(e){    e=e||window.event;    let x=e.clientX-canvas.offsetLeft;    let y=e.clientY-canvas.offsetTop;    if(ctx.isPointInPath(x,y)){        alert(123);//只有第二个圆才会触发,因为是新画的        } }</xmp></pre>            </div>        </div>        <p></p>        <div class="list" id="s5">            <h2>5.SVG</h2>            <p></p>            <h3 id="s5.1">5.1 SVG与Canvas的区别</h3>            <p></p>            <div>                <ul>                    <li><strong>SVG</strong><br/>SVG 是一种使用 XML 描述 2D 图形的语言,基于XML,这意味着SVG内部的DOM中的每个元素都是可用的,可以为某个元素附加 JavaScript 事件处理器,在SVG中,每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化,浏览器能够自动重现该图形<br/><strong>svg的特征</strong>                    </li>                    <p></p>                    <ul>                        <li>不依赖分辨率</li>                        <li>支持事件处理器</li>                        <li>最适合带有大型渲染区域的应用程序(比如谷歌地图)</li>                        <li>复杂度高会减慢渲染速度（任何过度使用DOM的应用都不快）</li>                        <li>不适合游戏应用</li>                    </ul>                    <p></p>                    <li><strong>Canvas</strong><br/>Canvas通过 JavaScript 来绘制 2D 图形,Canvas是逐像素进行渲染的,在canvas 中,一旦图形被绘制完成,它就不会继续得到浏览器的关注。如果其位置发生变化,那么整个场景也需要重新绘制,包括任何或许已被图形覆盖的对象<br/><strong>canvas的特征</strong></li>                    <p></p>                    <ul>                        <li>依赖分辨率</li>                        <li>不支持事件处理器</li>                        <li>弱的文本渲染能力</li>                        <li>能够以 .png 或 .jpg 格式保存结果图像</li>                        <li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>                    </ul>                </ul>            </div>            <p></p>            <h3 id="s5.2">5.2 引入SVG</h3>            <p></p>            <p><strong>svg是基于xml技术实现的,使用svg可以通过三种方式:</strong></p>            <p></p>            <p><strong>其中:</strong>xmlns后面的字符串为命名空间,用来区分不同的代码功能</p>            <p></p>            <div>                <ul>                    <li><strong>svg文件</strong></li>                    <p></p>                    <div class="codeMirror">                        <pre><xmp><?xml version="1.1" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"          "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">    <svg xmlns="http://www.w3.org/2000/svg"><circle cx="100" cy="100" r="40" fill="red"></circle></svg></xmp></pre>                    </div>                    <p></p>                    <li><strong>通过图片、背景、框架进行引入svg文件</strong></li>                    <p></p>                    <div class="codeMirror">                        <pre><xmp><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        html,        body {        height: 100%;        overflow: hidden;        }      </style></head><body>    <!--图片引入-->    <img src="1.svg">    <!--背景引入-->    <div style="height:200px;width:200px;background:url('1.svg')"></div>    <!--框架引入-->    <iframe src="1.svg"></iframe></body></html></xmp> </pre>                    </div>                    <p></p>                    <li><strong>直接在html页面中引入svg</strong></li>                    <p></p>                    <div class="codeMirror">                        <pre><xmp><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <style>        html,        body {            height: 100%;            overflow: hidden;            }      </style></head><body>    <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">    <circle cx="100" cy="100" r="40" fill="red"></circle>    </svg></body></html></xmp></pre>                    </div>            </div>            <p></p>            <h3 id="s5.3">5.3 基本图形</h3>            <p></p>            <p><strong>所有的svg标签(图层)会有层级关系,后续的标签如果与前面的标签重合就会覆盖点前面的标签</strong></p>            <p></p>            <h4 id="s5.3.1">5.3.1 圆</h4>            <p></p>            <p><strong>svg中的圆通过circle标签进行绘制</strong></p>            <p></p>            <ul>                <li>圆心坐标(cx,cy):写在标签上代表圆心离&lt;svg>&lt;/svg>标签左上角的距离坐标,单位为像素(不必填写)</li>                <li>圆心半径(r):写在标签上代表从(cx,cy)坐标开始向四周扩展的圆的半径</li>                <li>fill:通过填充方式画圆,填充的样式为圆的颜色,默认的填充颜色为黑色,不论是否填写了fill属性</li>                <li>stroke:通过画线的方式画圆,画线方式为圆的边框颜色</li>                <li>stroke-width:设置画线方式的线条宽度,单位为像素(不必填写)</li>                <li>stroke-dasharray:将实线改为虚线形式绘画,可以提供短划线与缺口之间的长度,通过设置该属性手动设置长度如果提供了奇数个值,则这个值的数列重复一次,从而变成偶数个值</li>                <p></p>                <div class="codeMirror">                    <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {              height: 100%;              overflow: hidden;          }        </style>      </head>      <body>        <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">          <circle cx="100" cy="100" r="40" fill="transparent" stroke="red"           stroke-width="5" stroke-dasharray="5 5 10 6"></circle>        </svg>      </body>    </html></xmp></pre>                </div>                <li>stroke-opacity:设置线条的透明度</li>                <li>fill-opacity:设置填充样式的透明度</li>            </ul>            <p></p>            <p><strong>注:</strong>如果只想要通过画线的方式画圆,需要将fill设置为transparent(透明)或者是none(没有填充色)</p>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {              height: 100%;              overflow: hidden;          }        </style>      </head>      <body>        <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">          <circle cx="100" cy="100" r="40" fill="transparent" stroke="red" stroke-width="5"></circle>        </svg>      </body></html></xmp></pre>            </div>            <p></p>            <p><strong>通过style属性设置</strong></p>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {              height: 100%;              overflow: hidden;          }        </style>    </head><body>    <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">        <circle cx="100" cy="100" r="40" style="fill:transparent;stroke:red;stroke-width:5"></circle>    </svg></body></html><!--    style中只能写样式属性,不对写cx,cy这样的定位属性和r这样的大小属性,也就是能对所有图形的公共属性设置--></xmp></pre>            </div>            <p></p>            <h4 id="s5.3.2">5.3.2 椭圆</h4>            <p></p>            <p><strong>svg中椭圆通过ellipse标签进行绘制</strong></p>            <p></p>            <ul>                <li><strong>椭圆中心坐标(cx,cy)</strong></li>                <li>rx:定义椭圆的水平半径</li>                <li>ry:定义椭圆的垂直半径</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {            height: 100%;            overflow: hidden;          }        </style>      </head><body>    <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">        <ellipse cx="100" cy="100" rx="100" ry="50" style="fill:none;stroke:red;stroke-width:5"></ellipse>    </svg></body></html></xmp></pre>            </div>            <p></p>            <h4 id="s5.3.3">5.3.3 矩形</h4>            <p></p>            <p><strong>svg中的矩形通过rect标签进行绘制</strong></p>            <p></p>            <ul>                <li>width:矩形的宽</li>                <li>height:矩形的高</li>                <li>(x,y):矩形相对于&lt;svg>&lt;/svg>标签的坐标</li>                <li>(rx,ry):设置矩形圆角,rx和ry分别为在四个角画离x和y相应距离的圆或椭圆,然后截取矩形超出的角。默认为0,如果只写rx或者只写ry那么另一个也会默认也为那个值,会用一个圆去进行切割矩形</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en"><head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>      </head>      <body>        <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">         <rect width="200" height="200" x="100" y="100" fill="red" fill-opacity="0.5" rx="30" ry="20"></rect>        </svg>      </body></html></xmp></pre>            </div>            <p></p>            <h4 id="s5.3.4">5.3.4 线条</h4>            <p></p>            <p><strong>svg中的线条通过line标签进行绘制</strong></p>            <p></p>            <ul>                <li>(x1,y1):设置线条的起点</li>                <li>(x2,y2):设置线条的终点</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {            height: 100%;            overflow: hidden;          }        </style>      </head>      <body>        <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">          <line x1="50" y1="50" x2="200" y2="200" stroke="black" stroke-width="5" stroke-  opacity="0.2"></line>        </svg>      </body>    </html></xmp></pre>            </div>            <p></p>            <h4 id="s5.3.5">5.3.5 折线</h4>            <p></p>            <p><strong>svg中的折线用polyline标签进行绘制</strong></p>            <p></p>            <ul>                <li>points:设置折线个各个点坐标,通过points="x1 y1 x2 y2 ..."或points="x1,y1,x2,y2...."进行设置 注:这两种方式也可以混合使用                </li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {            height: 100%;            overflow: hidden;          }        </style>      </head>      <body>        <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">          <polyline points="50 50 200 300 230 300 250 200 50 50" fill="none" stroke="black" stroke-width="5">          </polyline><!--折线是不闭合的,如果要闭合需要最后一个点为其实点-->          <polyline points="50 50,200 300,230 300,250 200"></polyline>        </svg>      </body>    </html></xmp></pre>            </div>            <p></p>            <h4 id="s5.3.6">5.3.6 多边形</h4>            <p></p>            <p><strong>svg中的折线用polygon标签进行绘制</strong></p>            <p></p>            <ul>                <li>points:设置折线个各个点坐标,通过points="x1 y1 x2 y2 ..."或points="x1,y1,x2,y2...."进行设置 <strong>注:</strong>这两种方式也可以混合使用                </li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {            height: 100%;            overflow: hidden;          }        </style>      </head>      <body>        <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">          <polyline points="50 50 200 300 230 300 250 200" fill="none" stroke="black" stroke-width="5">                    </polyline><!--多边形是闭合的,这与折线有区别,不必连接起点-->        </svg>      </body>    </html></xmp></pre>            </div>            <p></p>            <h4 id="s5.3.7">5.3.7 路径</h4>            <p></p>            <p><strong>svg中可以用path标签进行对一整个路径进行绘制</strong></p>            <p></p>            <ul>                <li>d:该属性用与设置路径,需要与路径命令进行配合,命令的语法d="M0 0L100 100",命令后紧跟着路径坐标,路径坐标的x和y坐标用空格隔开                    <strong>路径命令:</strong>                </li>                <ul>                    <li>M命令:设置路径的起始坐标</li>                    <li>L命令:设置路径的结束坐标</li>                    <li>Z命令:闭合路径,该命令放在前一个坐标的最后,用作闭合前面的路径</li>                    <li>H命令:绘制水平线,后面只跟着一个x坐标,对应的点会与上一个点的y坐标相同,该坐标的x也是代表着离&lt;svg>&lt;/svg>标签左上角的距离</li>                    <li>V命令:绘制垂直线,后面只跟着一个y坐标,对应的点会与上一个点的x坐标相同,该坐标的y也是代表着离&lt;svg>&lt;/svg>标签左上角的距离</li>                    <li>C,S,Q,T命令:绘制贝塞尔曲线</li>                    <ul>                        <li>C命令:绘制三次贝塞尔曲线(x1,y1,x2,y2,x,y)</li>                        <ul>                            <li>控制点一(x1,y)</li>                            <li>控制点二 (x2,y2)</li>                            <li>结束点(x,y)</li>                        </ul>                        <li>S命令:绘制平滑贝塞尔曲线(自动对称一个控制点)(x1,y1,x,y)</li>                        <ul>                            <li>控制点(x1,,y1)</li>                            <li>结束点(x,y)</li>                        </ul>                        <li>Q命令:绘制二次贝塞尔曲线(x1,y1,x,y)</li>                        <ul>                            <li>控制点(x1,y1)</li>                            <li>结束点(x,y)</li>                        </ul>                        <li>T命令:绘制一次贝塞尔曲线(x,y)</li>                        <ul>                            <li>结束点(x,y)</li>                        </ul>                    </ul>                </ul>            </ul>            <p></p>            <p><strong>注:这些命令有大小写两种方式.大写为绝对坐标(具体的坐标位置),小写为相对坐标(相对于上一个坐标点的具体长度)</strong></p>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {            height: 100%;            overflow: hidden;          }        </style>      </head>      <body>        <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">          <path d="M50 100L200 200L100 100ZM300 100H400" fill="none" stroke="black"></path>        </svg>      </body>    </html></xmp></pre>            </div>            <ul>                <li>A命令:通过d="Mx1 y1Arx ry x-axis-rotation large-arc-flag sweep-flag x2 y2",表示绘制一个椭圆圆弧经过(x1,y1),(x2,y2)点<br/><strong>注:</strong>A命令需要与M命名等一起配合使用确定圆弧的起始点<br/><strong>命令标识:</strong>                </li>                <p></p>                <ul>                    <li>rx:椭圆横轴半径</li>                    <li>ry:椭圆竖轴半径</li>                    <li>x-axis-rotation:椭圆横轴相对于CanvasX轴的偏移角度</li>                    <li>large-arc-flag:在前面三个参数确定的情况下,满足当前点(x1,y1)到指定点(x2,y2)位置条件的圆弧总是有四条,此值取0表示绘制小弧度,取值1表示绘制大弧度</li>                    <li>sweep-flag:在前三个参数确定的情况下,满足当前点(x1,y1)到指定点(x2,y2)位置条件的圆弧总是有四条,去掉通过上面large-arc-flag标识后还有两个,sweep-flag取值0表示绘制逆时针方向的圆弧,取值1表示绘制顺时针方向的圆弧</li>                </ul>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {            height: 100%;            overflow: hidden;          }        </style>      </head>      <body>        <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">          <!--绘制一段弧形圆弧-->          <path d="M150 150A100 100 0 0 1 250 150L225 175A50 50 0 0 0 175 175Z"           fill="none" stroke="black" stroke-width="5"></path>        </svg>      </body>    </html>    </xmp></pre>            </div>            <p></p>            <h3 id="s5.4">5.4 其余标签</h3>            <p></p>            <h4 id="s5.4.1">5.4.1 g标签</h4>            <p></p>            <p></p>            <p><strong>g标签是一个容器(分组)标签,专门用来组合元素的,同时可以用来设置元素公共属性,注意是公共属性(换句话说就能能写在style中的属性),不是只有某种图像自身才有的属性,自身才有的属性需要设置给自身的标签</strong></p>            <p></p>            <p><strong>注:</strong>可以使用所有元素的共用属性transform="translate(0,0)"用作移动整个组合元素</p>            <p></p>            <div class="codeMirror">                <pre><xmp><!--画一个靶心--><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>Document</title>    <style>      html,      body {        height: 100%;        overflow: hidden;      }    </style>  </head>  <body>    <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">      <g stroke="red" stroke-width="5" fill="transparent" transform="translate(200,200)">        <circle cx="100" cy="50" r="40" fill="transparent"></circle>        <circle r="30"></circle>        <circle r="20"></circle>        <circle r="10"></circle>      </g>      <!--       通过transform可以移动整个p标签和内部的元素,cx,cy是能够单独控制对应的圆相对移动后的p标签的移动       如果内部元素与g标签中属性冲突,内部元素的属性会起作用       -->    </svg>  </body>  </html></xmp></pre>            </div>            <p></p>            <h4 id="s5.4.2">5.4.2 text标签</h4>            <p></p>            <p><strong>text标签时svg中专门用来写入文本的标签</strong></p>            <p></p>            <ul>                <li>(x,y):文字标签相对于&lt;svg>&lt;/svg>标签的坐标,移动或文字的最左边靠这(x,y)坐标</li>                <li>font-size:设置文字大小,单位为像素</li>                <li>text-anchor:设置文本的对齐方式                    <strong>值:</strong>                </li>                <ul>                    <li>start:文字开头对齐(x,y)坐标</li>                    <li>middle:文字中部对齐(x,y)坐标</li>                    <li>end:文字结尾对齐(x,y)坐标</li>                </ul>            </ul>            <p></p>            <p><strong>注意:</strong>文字的颜色不能通过style中的color来设置,svg中的文字默认是fill属性来绘制的,可以通过改变fill属性的颜色来改变文字颜色,同时如果给文字加上stroke属性,会在文字周围再加上围绕的线条</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {            height: 100%;            overflow: hidden;          }        </style>      </head>      <body>        <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">          <text x="200" y="200" font-size="20" text-anchor="middle" fill="blue" stroke="red">SVG</text>        </svg>      </body></html></xmp></pre>            </div>            <p></p>            <h4 id="s5.4.3">5.4.3 imgae标签</h4>            <p></p>            <p><strong>image标签用于在svg中添加图片</strong></p>            <p></p>            <ul>                <li>width:图片的宽</li>                <li>height:图片的高</li>                <li>(x,y):图片相对于&lt;svg>&lt;/svg>标签的坐标</li>                <li>xlink:href:该属性写入图片的链接</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {            height: 100%;            overflow: hidden;          }        </style>      </head>      <body>        <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">          <image x="200" y="200" width="100" height="100" xlink:href="1.jpg"></image>        </svg>      </body>    </html></xmp></pre>            </div>            <p></p>            <h4 id="s5.4.4">5.4.4 defs与symbol标签</h4>            <p></p>            <p></p>            <p><strong>这两个标签专门用来装需要引入的元素容器,内部的元素使用ID作为唯一标识的url,通过锚点方式引入内部元素url在&lt;defs>&lt;/defs>或&lt;symbol>&lt;/symbol>标签外部显示,通常与use标签等搭配使用</strong></p>            <p></p>            <p><strong>注:</strong></p>            <p></p>            <ul>                <li>defs和symbol标签内部的原始元素不会在页面上显示出来,只有通过外部引用才能显示</li>                <li>引用的元素有内部可以写对应的样式,在引用时如果引用的标签没有做任何的操作,那么就会使用内部的样式,如果与引用标签内部规定的样式相冲突,原来样式就会无效</li>                <li>在使用通用样式时(如fill),会有层级的限制,如果直接在内部标签上那个设置fill等样式,外部引用时设置fill将不会起作用,如果设置在内部的g标签中,外部的样式就会起作用</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {            height: 100%;            overflow: hidden;          }        </style>      </head>      <body>        <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">          <defs>            <circle id="circle" cx="100" cy="100" r="50" fill="blue"></circle>          </defs>          <use xlink:href="#circle" x="120" y="150" fill="red"></use>        <!--因为use写了x和y,所以内部圆的cx和cy将无效,引入use中fill的层级没有内部圆的高,所以圆为蓝色-->        </svg>      </body></html></xmp></pre>            </div>            <p></p>            <h4 id="s5.4.5">5.4.5 filter标签</h4>            <p></p>            <p></p>            <p><strong>svg滤镜只能定义在&lt;defs>元素中,使用&lt;filter>标签用来定义svg滤镜,&lt;filter>标签使用必需的ID属性来定义向图形应用哪个滤镜</strong></p>            <p></p>            <p><strong>注:</strong>其余图形需要使用该滤镜可以通过该属性上内置的filter属性进行设置,设置方式filter="url(#引用ID名)"</p>            <p></p>            <h5 id="s5.4.5.1">5.4.5.1 模糊效果</h5>            <p></p>            <p><strong>通过&lt;feGaussianBlur>元素定义模糊效果</strong></p>            <p></p>            <ul>                <li>in="SourceGraphic":定义了由整个图像创建效果为SourceGraphic</li>                <li>stdDeviation:定义模糊量</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {            height: 100%;            overflow: hidden;          }        </style>      </head>      <body>        <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">           <defs>            <filter id="f1" x="0" y="0">              <feGaussianBlur in="SourceGraphic" stdDeviation="15" />            </filter>          </defs>          <rect width="90" height="90" stroke="green" stroke-width="3"          fill="yellow" filter="url(#f1)"></rect>        </svg>      </body>    </html></xmp></pre>            </div>            <p></p>            <h5 id="s5.4.5.2">5.4.5.2 阴影</h5>            <p></p>            <p><strong>通过&lt;feOffset>实现滤镜移动,通过&lt;feGaussianBlur>实现阴影模糊,通过&lt;feColorMatrix>为阴影周围上色</strong></p>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {            height: 100%;            overflow: hidden;          }        </style>      </head>      <body>        <svg xmlns="http://www.w3.org/2000/svg">          <defs>            <filter id="f1" x="0" y="0" width="200%" height="200%">              <feOffset result="offOut" in="SourceGraphic" dx="20" dy="20" />              <feColorMatrix result="matrixOut" in="offOut" type="matrix"              values="0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0" />              <feGaussianBlur result="blurOut" in="matrixOut" stdDeviation="10" />              <feBlend in="SourceGraphic" in2="blurOut" mode="normal" />            </filter>          </defs>          <rect width="90" height="90" stroke="green" stroke-width="3"          fill="yellow" filter="url(#f1)" />        </svg>      </body></html></xmp></pre>            </div>            <p></p>            <h4 id="s5.4.6">5.4.6 use标签</h4>            <p></p>            <p><strong>该标签可以通过使用url引用一个&lt;g>或&lt;svg>或其他具有一个唯一的ID属性和重复的图形元素,复制的是原始的元素,因此文件中的原始存在只是一个参考,并且原始影响到所有副本的任何改变</strong></p>            <p></p>            <p></p>            <ul>                <li>x:克隆元素的左上角的x轴</li>                <li>y:克隆元素的左上角的y轴</li>                <li>width:克隆元素的宽度</li>                <li>height:克隆元素的高度</li>                <li>xlink:href:通过url的方式引用克隆元素,引入方式xlink:href="#引用ID名"</li>            </ul>            <p></p>            <h3 id="s5.5">5.5 渐变</h3>            <p></p>            <p><strong>SVG渐变主要有两种类型</strong></p>            <p></p>            <ul>                <li>Linear</li>                <li>Radial</li>            </ul>            <p></p>            <h4 id="s5.5.1">5.5.1 stop标签</h4>            <p></p>            <p><strong>&lt;stop>标签用来设置渐变停止的位置</strong></p>            <p></p>            <ul>                <li>offset:偏移的停止量,参考值为0%到100%或0.0到1.0</li>                <li>stop-color:这个stop内的颜色</li>                <li>stop-opacity:这个stop类的不透明度,参考值为0到1</li>            </ul>            <p></p>            <h4 id="s5.5.2">5.5.2 线性渐变</h4>            <p></p>            <p><strong>&lt;linearGradient>标签用于定义线性渐变,线性渐变可以定义为水平,垂直或角渐变</strong></p>            <p></p>            <ul>                <li>当y1和y2相等,而x1和x2不同时,可创建水平渐变</li>                <li>当x1和x2相等,而y1和y2不同时,可创建垂直渐变</li>                <li>当x1和x2不同,且y1和y2不同时,可创建角形渐变</li>            </ul>            <p></p>            <p><strong>注意:&lt;linearGradient>标签必须嵌套在&lt;defs>的内部</strong></p>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {            height: 100%;            overflow: hidden;          }        </style>      </head>      <body>        <svg xmlns="http://www.w3.org/2000/svg">          <defs>             <!--一个水平椭圆渐变-->            <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">              <stop offset="0%" style="stop-color:rgb(255,255,0);stop-opacity:1" />              <stop offset="50%" style="stop-color:rgb(0,255,0);stop-opacity:1" />              <stop offset="100%" style="stop-color:rgb(255,0,0);stop-opacity:1" />            </linearGradient>          </defs>          <ellipse cx="200" cy="70" rx="85" ry="55" fill="url(#grad1)" />        </svg>      </body></html></xmp></pre>            </div>            <p></p>            <h4 id="s5.5.3">5.5.3 放射性渐变</h4>            <p></p>            <p><strong>&lt;radialGradient>元素用于定义放射性渐变</strong></p>            <p><strong>注意:&lt;radialGradient>标签必须嵌套在&lt;defs>的内部</strong></p>            <p></p>            <ul>                <li>渐变中心点(cx,cy):参考值为数字或%,默认是50％</li>                <li>r:渐变的半径,参考值为数字或%,默认50％</li>                <li>fx:渐变的焦点,参考值为数字或%,默认0％</li>                <li>fy:渐变的焦点,参考值为数字或%,默认0％</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>Document</title>    <style>      html,      body {        height: 100%;        overflow: hidden;      }    </style>  </head>  <body>    <svg xmlns="http://www.w3.org/2000/svg" version="1.1">        <defs>            <radialGradient id="grad1" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">                <stop offset="0%" style="stop-color:rgb(255,255,255);                                         stop-opacity:0" />                <stop offset="100%" style="stop-color:rgb(0,0,255);stop-opacity:1" />            </radialGradient>        </defs>        <ellipse cx="200" cy="70" rx="85" ry="55" fill="url(#grad1)" />    </svg>  </body></html></xmp></pre>            </div>            <p></p>            <h3 id="s5.6">5.6 使用JS创建SVG</h3>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {            height: 100%;            overflow: hidden;          }          div {            height: 100%;            width: 100%;          }        </style>      </head>      <body>        <div></div>        <script>          window.onload = () => {            let parent = document.getElementsByTagName("div")[0];            let svgNS = "http://www.w3.org/2000/svg";            let SVG = document.createElementNS(svgNS, "svg"); //创建带有命名空间的标签            SVG.setAttribute("xmlns", svgNS);            SVG.setAttribute("width", "100%");            SVG.setAttribute("height", "100%");               parent.appendChild(SVG);            //通过这种方式创建了一个svg标签,但是很麻烦          };        </script>      </body></html></xmp></pre>            </div>            <p></p>            <p><strong>功能函数</strong></p>            <p></p>            <div class="codeMirror">                <pre><xmp>function createTag(tag,Attr){    //传入一个Attr对象    let svgNS="http://www.w3.org/2000/svg"";    let oTag=document.createElementNS(svgNS,tag);    for(let attr in Attr){        let value=Attr[attr]+"";//可以传入数值转换为字符串        oTag.setAttribute(attr,value);            }        return oTag;    }</xmp></pre>            </div>            <p></p>            <h3 id="s5.7">5.7 SVG动画</h3>            <p></p>            <h4 id="s5.7.1">5.7.1 旋转</h4>            <p></p>            <p><strong>通过transform:rotate(angle x y)属性可以实现svg内置的旋转效果(不要写在style里面)</strong></p>            <p></p>            <ul>                <li>angle:旋转角度</li>                <li>(x,y):旋转中心,这个旋转中心可以是任何位置,一般都是图形的自身旋转中心点</li>            </ul>            <p></p>            <h4 id="s5.7.2">5.7.2 animate</h4>            <p></p>            <p><strong>&lt;animate>标签可以用来嵌入到其他标签元素中,使得被嵌入的标签有动画效果</strong></p>            <p></p>            <ul>                <li>attributeName:要变化的元素属性名称</li>                <ul>                    <li>可以是元素直接暴露的属性,如x和y等svg图像的专有属性</li>                    <li>可以是CSS属性,如width,height等</li>                </ul>                <li>from,to,by,values</li>                <ul>                    <li>from:动画的起始值(如果与元素的默认值一样可省略此值)</li>                    <li>to:动画的结束值</li>                    <li>by:动画结束值(相对变化的值)</li>                    <li>values:用分号分隔的一个或多个值,可以看成是动画的多个关键值点</li>                </ul>                <li>begin:动画开始时间,可为具体的时间值,也可以是其他条件触发 oﬀset-value | syncbase-value | event-value | repeat-value | accessKey-value | media-markervalue | wallclock-sync-value | "indeﬁnite"                </li>                <li>dur:动画过渡的时间 ,参考值为具体时间或indefinite(无限时间即无具体意义)</li>                <li>repeatCount, repeatDur</li>                <ul>                    <li>repeatCount:表示动画执行次数,可以是合法数值或者indefinite</li>                    <li>repeatDur:定义重复动画的总时间,可以是普通时间值或者indeﬁnite</li>                </ul>            </ul>            <p></p>            <p><strong>注意:</strong>如果想要动画结束后停留在最后的位置,需要加上fill="freeze"属性</p>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {            height: 100%;            overflow: hidden;          }        </style>      </head>      <body>        <svg xmlns="http://www.w3.org/2000/svg" height="100%" width="100%">          <rect width="100" height="100" x="100" y="100" fill="deeppink">            <animate attributeName="x" begin="0s" by="400" dur="3s" fill="freeze" repeatCount="2">                      </animate><!--by="400"同to="500"-->          </rect>        </svg>      </body></html></xmp></pre>            </div>            <p></p>            <h4 id="s5.7.3">5.7.3 animateTransform</h4>            <p></p>            <p><strong>&lt;animateTransform>标签专门用来对transform属性进行设置动画效果,通过type属性选择需要变换的类型</strong></p>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>Document</title>    <style>      html,      body {        height: 100%;        overflow: hidden;      }    </style>  </head>  <body>    <svg xmlns="http://www.w3.org/2000/svg" height="100%" width="100%">      <rect width="100" height="100" x="100" y="100" fill="deeppink">        <animateTransform attributeName="transform" type="translate" begin="0s" to="500,500" dur="3s"         fill="freeze" repeatCount="2"></animateTransform>      </rect>    </svg>  </body></html></xmp></pre>            </div>            <p></p>            <p><strong>注:</strong></p>            <p></p>            <ul>                <li>一个元素类可以写多个动画标签,但是如果相互冲突会执行最下面的动画(指的是都是控制相同的属性),如果是不同的属性会同时执行</li>                <li>可以在begin属性中设置一些限制条件来控制动画的运行</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>        <style>          html,          body {            height: 100%;            overflow: hidden;          }        </style>      </head>      <body>        <svg xmlns="http://www.w3.org/2000/svg" height="100%" width="100%">          <rect width="100" height="100" x="100" y="100" fill="deeppink">            <animateTransform              id="f1"              attributeName="transform"              type="translate"              begin="0s"              to="500,500"              dur="3s"              fill="freeze"              repeatCount="2"            ></animateTransform>              <!--下面的f1.end表示在f2运动执行完成后才执行该运动-->            <animateTransform              attributeName="transform"              type="rotate"              begin="f1.end"              to="360 100 100"              dur="3"              fill="freeze"              repeatCount="2"            ></animateTransform>          </rect>        </svg>      </body>    </html>                                  </xmp></pre>            </div>        </div>        <p></p>        <div class="list" id="s6">            <h2>6.Audio与Video</h2>            <p></p>            <p><strong>大多数人认为视频文件就是.avi .mp4等,但事实上这些仅仅只是容器的格式,只决定了怎么将视频存储起来,而不关心储存的内容,类似于压缩文件格式.zip .rar等</strong></p>            <div>                <p></p>                <p></p>                <h3 id="s6.1">6.1 容器</h3>                <p></p>                <p><strong>视频与音频容器</strong></p>                <p></p>                <ul>                    <li>视频容器包含了音频轨道、视频轨道、和其他的一些元数据,在视频播放的时候,音频轨道和视频滚到是绑定在一起的,元数据包含了视频的封面、标题、子标题、字幕等相关信息</li>                    <li>音频容器包含了音频轨道</li>                </ul>                <p></p>                <p><strong>主流的文件格式</strong></p>                <p></p>                <ul>                    <li>视频</li>                    <ul>                        <li>MPEG-4:通常以.mp4为扩展名</li>                        <li>Flash视频:通常以.fiv为扩展名</li>                        <li>Ogg:通常以.Ogv为扩展名</li>                        <li>WebM:通常以.webm为扩展名</li>                        <li>音视频交错:通常以.avi为扩展名</li>                    </ul>                    <li>音频</li>                    <ul>                        <li>MPEG-3:通常以.mp3为扩展名</li>                        <li>Acc音频:通常以.acc为扩展名</li>                        <li>Ogg音频:通常以.Ogg为扩展名</li>                    </ul>                </ul>                <p></p>                <p><strong>注:</strong>可以使用转码器进行转码改变文件格式</p>                <p></p>            </div>            <p></p>            <h3 id="s6.2">6.2 兼容</h3>            <p></p>            <p><strong>通过与&lt;source> &lt;/source>相结合可以实现在不同浏览器下的兼容写法</strong></p>            <p></p>            <div class="codeMirror">                <pre><xmp><video controls>    <source src="test.mp4" type="video/mp4"></source>    <source src="test.ogv" type="video/ogg"></source>    <source src="test.webm" type="video/webm"></source>    当前浏览器不支持视频播放,点击下载<a href="test.webm">下载视频</a></video><audio controls>    <source src="test.mp3" type="audio/mpeg"></source>    <source src="test.aac" type='audio/aac;codecs="aac"'></source>    <source src="test.ogg" type='audio/ogg;codecs="vorbis"'></source></audio><!--    type是用于浏览器进行辨认,通过type浏览器能够快速辨认自身是否支持该文件,不会浪费时间一个个下载,    所以type一定要书写正确,后面的codecs是告诉浏览器需要使用的解码器-->     </xmp></pre>            </div>            <p></p>            <h3 id="s6.3">6.3 音视频的attribute</h3>            <p></p>            <ul>                <li><strong>视频</strong></li>                <p></p>                <ul>                    <li>width:视频显示区域的宽度,单位是CSS像素</li>                    <li>height:视频展示区域的高度,单位是CSS像素</li>                    <li>poster:一个海报帧的url,用于在用户播放或者跳帧之前展示</li>                    <li>src:要嵌到页面的视频url</li>                    <li>controls:显示或隐藏用户控制界面</li>                    <li>autoplay:媒体是否循环播放</li>                    <li>muted:是否静音</li>                    <li>preload:该属性旨在告诉浏览器作者认为达到最佳的用户体验的方式是什么 值:                    </li>                    <ul>                        <li>none:提示作者认为用户不需要查看该视频,服务器也想要最小化访问流量,换句话说就是提示浏览器该视频不需要缓存</li>                        <li>metadata:提示尽管作者认为用户不需要查看该视频,但是还是需要提取元数据(如长度等)</li>                        <li>auto:用户需要这个视频优先加载,换句话说就是提示如果需要的话可以下载整个视频,即使用户不一定会使用它</li>                    </ul>                </ul>            </ul>            <p></p>            <p><strong>注意:</strong>如果值为空的字符串也是代指auto</p>            <p></p>            <ul>                <li><strong>音频</strong></li>                <p></p>                <ul>                    <li>src:要嵌到页面的视频url</li>                    <li>controls:显示或隐藏用户控制界面</li>                    <li>autoplay:媒体是否循环播放</li>                    <li>muted:是否静音</li>                    <li>preload:该属性旨在告诉浏览器作者认为达到最佳的用户体验的方式是什么 值:                    </li>                    <ul>                        <li>none:提示作者认为用户不需要查看该视频,服务器也想要最小化访问流量,换句话说就是提示浏览器该视频不需要缓存</li>                        <li>metadata:提示尽管作者认为用户不需要查看该视频,但是还是需要提取元数据(如长度等)</li>                        <li>auto:用户需要这个视频优先加载,换句话说就是提示如果需要的话可以下载整个视频,即使用户不一定会使用它</li>                    </ul>                </ul>            </ul>            <p></p>            <p><strong>注意:</strong>如果值为空的字符串也是代指auto</p>            <p></p>            <p></p>            <h3 id="s6.4">6.4 音视频的property</h3>            <p></p>            <p><strong>音视频相关的JS属性</strong></p>            <p></p>            <ul>                <li>duration:媒体总时间(只读)</li>                <li>currentTime:开始播放到现在所用的时间(可读写)</li>                <li>muted:是否静音(可读写,相比于volume优先级更高)</li>                <li>volume:0.0到1.0的音量相对值(可读写) 注意:muted与volume不会同步,所以在写muted为true的时候需要把volume也为设置0,做到两者同步                </li>                <li>paused:媒体是否暂停(只读)</li>                <li>ended:媒体是否播放完毕(只读)</li>                <li>error:媒体发生错误的时候</li>                <li>currentSrc:以字符串形式返回媒体地址(只读)</li>            </ul>            <p></p>            <p><strong>视频多出的JS属性</strong></p>            <p></p>            <ul>                <li>poster:视频播放前的预览图片(可读写)</li>                <li>width:设置视频标签的宽</li>                <li>height:设置视频标签的高</li>                <li>videoWidth:视频的实际宽(就是只有视频图像的那部分)</li>                <li>videoHeight:视频的实际高</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8">        <meta name="viewport" content="width=device-width, initial-scale=1.0">        <meta http-equiv="X-UA-Compatible" content="ie=edge">        <title>Document</title>      </head>      <body>            <video src="test.mp4"></video>            <audio src="test.mp3"></audio>            <script>              let video=document.querySelector("video");              let audio=document.querySelector("aduio");              //只写一下必要的属性              video.muted=true;              video.volume=0;              audio.muted=true;              audio.volume=0;              video.addEventListener("loadeddata",()=>{                  conosole.log(video.videoWidth);                  conosole.log(video.videoHeight);              })          </script>      </body></html></xmp></pre>            </div>            <p></p>            <p><strong>更多属性</strong></p>            <p></p>            <table>                <tr>                    <th>属性</th>                    <td>描述</td>                </tr>                <tr>                    <td>audioTracks</td>                    <td>返回表示可用音频轨道的 AudioTrackList 对象。</td>                </tr>                <tr>                    <td>autoplay</td>                    <td>设置或返回是否在加载完成后随即播放音频/视频。</td>                </tr>                <tr>                    <td>buffered</td>                    <td>返回表示音频/视频已缓冲部分的 TimeRanges 对象。</td>                </tr>                <tr>                    <td>controller</td>                    <td>返回表示音频/视频当前媒体控制器的 MediaController 对象。</td>                </tr>                <tr>                    <td>controls</td>                    <td>设置或返回音频/视频是否显示控件（比如播放/暂停等）。</td>                </tr>                <tr>                    <td>crossOrigin</td>                    <td>设置或返回音频/视频的 CORS 设置。</td>                </tr>                <tr>                    <td>currentSrc</td>                    <td>返回当前音频/视频的 URL。</td>                </tr>                <tr>                    <td>currentTime</td>                    <td>设置或返回音频/视频中的当前播放位置（以秒计）。</td>                </tr>                <tr>                    <td>defaultMuted</td>设置或返回音频/视频默认是否静音。</td>                </tr>                <tr>                    <td>defaultPlaybackRate</td>                    <td>设置或返回音频/视频的默认播放速度。</td>                </tr>                <tr>                    <td>ended</td>                    <td>返回音频/视频的播放是否已结束。</td>                </tr>                <tr>                    <td>error</td>                    <td>返回表示音频/视频错误状态的 MediaError 对象。</td>                </tr>                <tr>                    <td>loop</td>                    <td>设置或返回音频/视频是否应在结束时重新播放。</td>                </tr>                <tr>                    <td>mediaGroup</td>                    <td>设置或返回音频/视频所属的组合（用于连接多个音频/视频元素）。</td>                </tr>                <tr>                    <td>muted</td>                    <td>设置或返回音频/视频是否静音。</td>                </tr>                <tr>                    <td>networkState</td>                    <td>返回音频/视频的当前网络状态。</td>                </tr>                <tr>                    <td>paused</td>                    <td>设置或返回音频/视频是否暂停。</td>                </tr>                <tr>                    <td>playbackRate</td>                    <td>设置或返回音频/视频播放的速度。</td>                </tr>                <tr>                    <td>played</td>                    <td>返回表示音频/视频已播放部分的 TimeRanges 对象。</td>                </tr>                <tr>                    <td>preload</td>                    <td>设置或返回音频/视频是否应该在页面加载后进行加载。</td>                </tr>                <tr>                    <td>readyState</td>                    <td>返回音频/视频当前的就绪状态。</td>                </tr>                <tr>                    <td>seekable</td>                    <td>返回表示音频/视频可寻址部分的 TimeRanges 对象。</td>                </tr>                <tr>                    <td>seeking</td>                    <td>返回用户是否正在音频/视频中进行查找。</td>                </tr>                <tr>                    <td>src</td>                    <td>设置或返回音频/视频元素的当前来源。</td>                </tr>                <tr>                    <td>startDate</td>                    <td>返回表示当前时间偏移的 Date 对象。</td>                </tr>                <tr>                    <td>textTracks</td>                    <td>返回表示可用文本轨道的 TextTrackList 对象。</td>                </tr>                <tr>                    <td>videoTracks</td>                    <td>返回表示可用视频轨道的 VideoTrackList 对象。</td>                </tr>                <tr>                    <td>volume</td>                    <td>设置或返回音频/视频的音量。</td>                </tr>            </table>            <p></p>            <h3 id="s6.5">6.5 音视频相关事件及函数</h3>            <p></p>            <ul>                <li><strong>音视频方法</strong></li>                <p></p>                <table>                    <tr>                        <td>方法</td>                        <td>描述</td>                    </tr>                    <tr>                        <td>addTextTrack()</td>                        <td>向音频/视频添加新的文本轨道。</td>                    </tr>                    <tr>                        <td>canPlayType()</td>                        <td>检测浏览器是否能播放指定的音频/视频类型。</td>                    </tr>                    <tr>                        <td>load()</td>                        <td>重新加载音频/视频元素。</td>                    </tr>                    <tr>                        <td>play()</td>                        <td>开始播放音频/视频。</td>                    </tr>                    <tr>                        <td>pause()</td>                        <td>暂停当前播放的音频/视频。</td>                    </tr>                </table>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>         <meta charset="UTF-8">        <meta name="viewport" content="width=device-width, initial-scale=1.0">        <meta http-equiv="X-UA-Compatible" content="ie=edge">        <title>Document</title>      </head>      <body>            <video src="test.mp4"></video>          <audio>              <source src="test.mp3" type="audio/mpeg"></source>              <source src="test.aac" type='audio/aac;codecs="aac"'></source>              <source src="test.ogg" type='audio/ogg;codecs="vorbis"'></source>          </audio>            <script>              let video=document.querySelector("video");              let audio=document.querySelector("audio");              let source=document.querySelectorAll("source");              //默认是关闭的              video.play();//这样打开就会自动播放              setInterval(()=>{                  video.pause();//5s后自动停止播放              },5000);              video.src="test2.mp4";//如果是直接写在音视频标签上的链接改变时不需要load()方法              source[0].src="test2.mp3";              audio.load();              //如果是写在source标签上的链接在改变时需要使用该方法且是音视频标签使用才能改变链接          </script>      </body></html></xmp></pre>            </div>            <ul>                <li><strong>音视频事件</strong></li>                <p></p>                <table>                    <tr>                        <td>事件</td>                        <td>描述</td>                    </tr>                    <tr>                        <td>abort</td>                        <td>当音频/视频的加载已放弃时触发。</td>                    </tr>                    <tr>                        <td>canplay</td>                        <td>当浏览器可以开始播放音频/视频时触发。</td>                    </tr>                    <tr>                        <td>canplaythrough</td>                        <td>当浏览器可在不因缓冲而停顿的情况下进行播放时触发。</td>                    </tr>                    <tr>                        <td>durationchange</td>                        <td>当音频/视频的时长已更改时触发。</td>                    </tr>                    <tr>                        <td>emptied</td>                        <td>当目前的播放列表为空时触发。</td>                    </tr>                    <tr>                        <td>ended</td>                        <td>当目前的播放列表已结束时触发。</td>                    </tr>                    <tr>                        <td>error</td>                        <td>当在音频/视频加载期间发生错误时触发。</td>                    </tr>                    <tr>                        <td>loadeddata</td>                        <td>当浏览器已加载音频/视频的当前帧时触发。</td>                    </tr>                    <tr>                        <td>loadedmetadata</td>                        <td>当浏览器已加载音频/视频的元数据时触发。</td>                    </tr>                    <tr>                        <td>loadstart</td>                        <td>当浏览器开始查找音频/视频时触发。</td>                    </tr>                    <tr>                        <td>pause</td>                        <td>当音频/视频已暂停时触发。</td>                    </tr>                    <tr>                        <td>play</td>                        <td>当音频/视频已开始或不再暂停时触发。</td>                    </tr>                    <tr>                        <td>playing</td>                        <td>当音频/视频在因缓冲而暂停或停止后已就绪时触发。</td>                    </tr>                    <tr>                        <td>progress</td>                        <td>当浏览器正在下载音频/视频时触发。</td>                    </tr>                    <tr>                        <td>ratechange</td>                        <td>当音频/视频的播放速度已更改时触发。</td>                    </tr>                    <tr>                        <td>seeked</td>                        <td>当用户已移动/跳跃到音频/视频中的新位置时触发。</td>                    </tr>                    <tr>                        <td>seeking</td>                        <td>当用户开始移动/跳跃到音频/视频中的新位置时触发。</td>                    </tr>                    <tr>                        <td>stalled</td>                        <td>当浏览器尝试获取媒体数据，但数据不可用时触发。</td>                    </tr>                    <tr>                        <td>suspend</td>                        <td>当浏览器刻意不获取媒体数据时触发。</td>                    </tr>                    <tr>                        <td>timeupdate</td>                        <td>当目前的播放位置已更改时触发。</td>                    </tr>                    <tr>                        <td>volumechange</td>                        <td>当音量已更改时触发。</td>                    </tr>                    <tr>                        <td>waiting</td>                        <td>当视频由于需要缓冲下一帧而停止时触发。</td>                    </tr>                </table>                <p></p>                <h3 id="s6.6">6.6 视频与canvas结合</h3>                <p></p>                <div class="codeMirror">                    <pre><xmp><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <meta http-equiv="X-UA-Compatible" content="ie=edge">  <title>Document</title>  <style> canvas {        position: absolute;        top: 0;        bottom: 0;        left: 0;        right: 0;        margin: auto;        background-color: gray;        border: 1px solid #000;      }     </style></head><body>    <!--放映机-->  <video src="test.mp4" width="0" height="0"></video>    <!--荧幕-->  <canvas width="300" height="300"></canvas>  <script>  let video=document.getElementByTagNames("video")[0];        let canvas = document.querySelector("canvas");        let ctx=canvas.getContext("2d");        video.addEventListener("loadeddata",()=>{            setInterval(()=>{                ctx.drawImage(video,0,0,canvas.width,canvas.height);            },);        })    </script>   </body></html></xmp></pre>                </div>        </div>        <p></p>        <div class="list" id="s7">            <h2>7.表单验证</h2>            <p></p>            <p><strong>表单验证时有一个validity对象,通过该对象可以查看验证是否通过,内部拥有八种验证,如果八种验证都通过则返回true(是验证通过,不是每一项代表的布尔值,每一项代表的布尔值不通过会变为true),一旦验证失败返回false,验证事件通过node.addEventListener("invalid",funciotn(){},false)进行绑定,其中node为用户写入数据的input标签</strong></p>            <p></p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8">        <meta name="viewport" content="width=device-width, initial-scale=1.0">        <meta http-equiv="X-UA-Compatible" content="ie=edge">        <title>Document</title>      </head>      <body>          请输入邮箱<br>          <input type="email"/>          <script>              let input=document.querySlector("input");              input.addEventListener("invalid",function(){                  console.log(this.validity);              },false)          </script>            </body></html></xmp></pre>            </div>            <div>                <p></p>                <p><strong>八种验证</strong></p>                <p></p>                <ul>                    <li>valueMissing:输入值为空时返回true</li>                    <li>typeMismatch:控件值与预期类型不匹配返回true</li>                    <li>patternMismatch:输入值不满足pattern正则返回true</li>                    <li>tooLong:超过maxLeng最大值限制返回true</li>                    <li>rangeUnderflow:验证的range最小值返回true</li>                    <li>rangeOverflow:验证的range最大值返回true</li>                    <li>stepMismatch:验证range的当前值是否符合min、max及step的规则返回true</li>                    <li>customError:不符合用户的自定义验证返回true 注:自定义验证可以通过node.setCustonValidity("输入格式有误")传递给用户                    </li>                </ul>                <p></p>                <p><strong>关闭表单验证:</strong>通过formnovalidate属性可以关闭表单的验证</p>                <p></p>            </div>        </div>        <p></p>        <div class="list" id="s8">            <h2>8.地理信息</h2>            <p></p>            <h3 id="s8.1">8.1 位置信息来源</h3>            <p></p>            <div>                <ul>                    <li>IP地址</li>                    <li>GPS全球定位系统</li>                    <li>Wi-Fi无线网络</li>                    <li>基站</li>                </ul>            </div>            <p></p>            <h3 id="s8.2">8.2 navigator.geolocation</h3>            <p></p>            <p><strong>navigator.geolocation用于获取设备的当前位置</strong></p>            <p></p>            <p><strong>navigator.geolocation的三个方法：</strong></p>            <p></p>            <div>                <ul>                    <li>getCurrentPosition()</li>                    <li>watchPosition()</li>                    <li>clearWatch()</li>                </ul>            </div>            <p></p>            <h4 id="s8.2.1">8.2.1 getCurrentPosition</h4>            <p></p>            <p><strong>使用方法:navigator.geolocation.getCurrentPosition(successCallback,[errorCallback], [positionOptions]);</strong></p>            <p></p>            <ul>                <li>successCallback:successCallback返回一个地理数据对象position作为参数,该对象有属性timestamp和coords。timestamp表示该地理数据创建时间(时间戳),可以通过new Date(position.timestamp)得到,coords包括另外七个属性：</li>                <ul>                    <li>coords.latitude:估计纬度</li>                    <ul>                        <li>coords.longitude:估计经度</li>                        <li>coords.altitude:估计高度</li>                        <li>coords.accuracy:所提供的以米为单位的经度和纬度估计的精确度</li>                        <li>coords.altitudeAccuracy:所提供的以米为单位的高度估计的精确度</li>                        <li>coords.heading:宿主设备当前移动的角度方向，相对于正北方向顺时针计算</li>                        <li>coords.speed:以米每秒为单位的设备的当前对地速度</li>                    </ul>                </ul>                <li>errorCallback:errorCallback返回一个错误数据对象error作为参数,该对象有属性code和message</li>                <ul>                    <li>code :表示失败原因,会返回失败4种编号.</li>                    <ul>                        <li>0:不包括其他错误编号中的错误</li>                        <li>1:用户拒绝浏览器获取位置信息</li>                        <li>2:尝试获取用户信息,但失败了</li>                        <li>3:设置了timeout值,获取位置超时了</li>                    </ul>                    <li>message:错误的提示内容</li>                </ul>                <li>positionOptions: positionOptions用来设置positionOptions来更精细的执行定位,positionOptions拥有三个属性:</li>                <ul>                    <li>enableHighAccuracy:值为true或者false(默认),是否返回更详细更准确的结构,默认为false不启用,选择true则启用,但是会导致较长的响应时间及增加功耗,这种情况更多的用在移动设备上</li>                    <li>timeout:设备位置获取操作的超时时间设定(不包括获取用户权限时间),单位为毫秒,如果在设定的timeout时间内未能获取位置定位,则会执行errorCallback()返回code(3)。如果未设定timeout,那么timeout默认为无穷大,如果timeout为负数,则默认timeout为0</li>                    <li>maximumAge:设定位置缓存时间,以毫秒为单位,如果不设置该值,该值默认为0,如果设定负数,则默认为0。该值为0时,位置定位时会重新获取一个新的位置对象。该值大于0时,即从上一次获取位置时开始,缓存位置对象,如果再次获取位置时间不超过maximumAge,则返回缓存中的位置,如果超出maximumAge,则重新获取一个新的位置</li>                </ul>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp>navigator.geolocation.getCurrentPosition(position=>{    console.log(position.coords.latitude);    console.log(position.coords.longitude);    console.log(position.coords.altitude);    console.log(position.coords.accuracy);    console.log(position.coords.altitudeAccuracy);    console.log(position.coords.heading);    console.log(position.coords.speed);    console.log(new Date(position.timestamp));    },err=>{        console.log(err.code,err.message)    },{        enableHighAccuracy:false,        timeout:5000,        maximumAge:1000})</xmp></pre>            </div>            <p></p>            <h4 id="s8.2.2">8.2.2 watchPosition</h4>            <p></p>            <p><strong>该方法功能与getCurrentPosition()类似,参数也是相同的三个参数,不过该方法会在检查到位置发生改变后才会触发,所以只对移动设备有用,并且该函数会触发多次</strong></p>            <p></p>            <p><strong>**使用方法:navigator.geolocation.watchPosition(successCallback, [errorCallback] , [positionOptions])**</strong></p>            <p></p>            <h4>8.2.3 clearWatch</h4>            <p></p>            <p><strong>该方法用于配合watchPosition()使用,用于停止watchPosition()轮询</strong></p>            <p></p>            <p><strong>watchPosition()需要定义一个watchID,如let watchID = watchPosition(...)，,通过clearWatch(watchID)来停止watchPosition()，使用方法类似setInterval</strong></p>        </div>        <p></p>        <p></p>        <div class="list" id="s9">            <h2>9.Worker与EventSource</h2>            <p></p>            <h3 id="s9.1">9.1 Worker</h3>            <p></p>            <p><strong>Woreker是H5中提出的可以让JS实现多线程的对象,通过向其中传入后台处理的JS地址就能让JS通过多线程处理代码,提高效率</strong></p>            <p></p>            <div>                <ul>                    <li>postMessage:传输数据给后台</li>                    <li>onmessage事件:接收到前台和后台传输数据的事件</li>                    <li>importScripts("其余JS文件"):该函数能够引入一个JS文件并执行其中代码</li>                </ul>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>//index.jsconst worker=new Worker("worker.js);worker.postMessage(10000);worker.onmessage=function(e){    console.log(e.data);//从worker.js接收的数据    }</xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>//worker.jsimportScripts("test.js");//打印testself.onmessage=function(e){//self是固定写法,代表从父级接收到的信息    console.log(e.data);//e.data就是接收到的信息    self.postMessage(1000);//通过该方法将数据传输出去}</xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>//test.jsconsole.log("test");</xmp></pre>            </div>            <p></p>            <h3 id="s9.2">9.2 EventSource</h3>            <p></p>            <p><strong>EventSource对象能够获取到sse服务器推送的消息, 同时也是使用其onmessage事件监听接收消息</strong></p>            <p></p>            <div class="codeMirror">                <pre><xmp>const source=new EventSource("sse.php");//连接后端source.onmessage=function(e){    console.log(e.data);//打印从后台获取的信息    }</xmp></pre>            </div>        </div>        <p></p>        <div class="list" id="s10">            <h2>10.离线存储和跨文档请求</h2>            <p></p>            <h3 id="s10.1">10.1 离线存储</h3>            <p></p>            <div>                <ul>                    <li>服务器设置头信息 : AddType text/cache-manifest .manifest</li>                    <li>html标签加 : manifest=“xxxxx.manifest”</li>                    <li>写manifest文件 : 离线的清单列表 先写 : CACHE MANIFEST FALLBACK : 第一个网络地址没获取到，就走第二个缓存的 NETWORK ：无论缓存中存在与否，均从网络获取                    </li>                </ul>            </div>            <p></p>            <h3 id="s10.2">10.2 跨文档请求</h3>            <p></p>            <h4 id="s10.2.1">10.2.1 同域跨文档</h4>            <p></p>            <ul>                <li>iframe内页：</li>                <ul>                    <li>父页面操作子页面:iframe.contentWindow,iframe为需要操作的iframe标签</li>                    <li>子页面操作父页面:window.top(找到最顶级的父页面)/parent(第一父页面)</li>                </ul>                <li>新窗口页：</li>                <ul>                    <li>父页面操作子页面:window.open</li>                    <li>子页面操作父页面:window.opener</li>                </ul>            </ul>            <p></p>            <h4 id="s10.2.2">10.2.2 不同域跨文档</h4>            <p></p>            <p><strong>通过postMessage(“发送的数据”,”接收的域”)发送跨域信息,再通过对window绑定message事件进行监听 message事件: </strong></p>            <p></p>            <ul>                <li>e.origin:发送数据来源的域</li>                <li>e.data:发送的数据,通过判断发送的数据来执行相应的需求</li>            </ul>        </div>        <p></p>        <div class="list" id="s11">            <h2>11.移动端事件</h2>            <p></p>            <h3 id="s11.1">11.1 基础事件</h3>            <p></p>            <div>                <ul>                    <li><strong>PC端事件</strong></li>                    <p></p>                    <ul>                        <li>onclick:鼠标点击触发</li>                        <li>onmousedown:鼠标按下触发</li>                        <li>onmousemove:鼠标移动触发</li>                        <li>onmouseup:鼠标抬起触发</li>                    </ul>                    <p></p>                    <li><strong>移动端触屏事件</strong></li>                    <p></p>                    <ul>                        <li>ontouchstart:手指按下触发</li>                        <li>ontouchmove:手指移动触发</li>                        <li>ontouchend:手指抬起触发</li>                    </ul>                </ul>            </div>            <p></p>            <h3 id="s11.2">11.2 注意事项</h3>            <p></p>            <ul>                <li>通过on的方式添加touch事件在谷歌模拟器下无效</li>                <li>鼠标事件在移动端可以使用，但有300毫秒的延迟 点透问题:点击了页面之后,浏览器会记录点击下去的坐标300毫秒之后,在该坐标找到现在的元素,执行该事件,所以如果期间进行了移动可能会无效<br/><strong>解决办法:</strong>                </li>                <p></p>                <ul>                    <li>阻止默认事件,但在部分安卓机不支持</li>                    <li>不用a标签做页面跳转,用window.location.href做跳转,比如移动端淘宝</li>                    <li>在移动端不用鼠标事件</li>                </ul>                <li>防止误触问题:用JS做判断,手指移动就不跳转,没有移动,说明是点击,则跳转</li>            </ul>            <p></p>            <h3 id="s11.3">11.3 获取手指信息</h3>            <p></p>            <p><strong>所有的手指信息都是在触屏事件的event对象中得到</strong></p>            <p></p>            <ul>                <li>e.touches:当前屏幕上的手指列表</li>                <li>e.targetTouches:当前元素上的手指列表</li>                <li>e.changedTouches:触发当前事件的手指列表</li>                <li>e.changedTouches.length:获取手指的个数</li>                <li>e.changedTouches[0].pageX|pageY:获取X和Y坐标</li>            </ul>            <p></p>            <p><strong>注意:</strong>在touchend事件的时候想要获取手指列表,只能用e.changedTouches,因为手指抬起也就没有touches和targetTouches了,只能用changedTouches</p>        </div>        <p></p>        <p></p>        <div class="list" id="s12">            <h2>12.移动端适配</h2>            <p></p>            <div class="codeMirror">                <pre><xmp><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8">        <meta name="viewport" content="width=device-width, initial-scale=1.0">        <!--          name="viewport"视图窗口           content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"              width=device-width 设备宽度              initial-scale=1.0  100px初始化的比例值              maximum-scale=1.0  最大的比例值              user-scalable=no   用户自定义缩放，不允许缩放          加了这个meta标签，我们就可以认为让页面按照视口宽度进行显示，视口是多大内容就是按照比例变化，          不加默认是按照PC端的980px添加的          -->        <meta http-equiv="X-UA-Compatible" content="ie=edge">        <title>Document</title>      </head>      <body>       </body></html></xmp></pre>            </div>            <p></p>            <p><strong>适配方案</strong></p>            <p></p>            <div>                <ul>                    <li>固定高度，宽度百分比适配-布局非常均匀 适合百分比布局</li>                    <li>固定宽度，改变缩放比例适配-什么情况都可以</li>                    <li>rem适配</li>                    <li>PC端和移动端 分开开发</li>                    <li>响应式开发(很麻烦)</li>                    <li>Bootstrap</li>                </ul>                <p></p>                <p><strong>单位</strong></p>                <p></p>                <ul>                    <li>em:根据元素自身的字体大小计算元素自身</li>                    <li>rem:根据html的字体大小计算其他元素尺寸</li>                </ul>            </div>            <p></p>            <h3 id="s12.1">12.1 固定高度,宽度百分比</h3>            <p></p>            <ul>                <li>根据设置的大小去设置高度,单位可以用px、百分比、auto</li>                <li>常用Flex布局</li>                <li>百分比宽度</li>            </ul>            <p></p>            <h3 id="s12.2">12.2 固定宽度,改变缩放比例</h3>            <p></p>            <ul>                <li>设计图的宽度就是网页显示的宽度</li>                <li>改变视口的缩放比例</li>                <li>页面宽度固定死</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp>(function(){    /*        var html=document.querySelector("html);        var width=html.getBoundingClientRect().width;    */    var width=window.screen.width;    var fixedW=320;//设计稿的宽度    var scale=width/fixedW;    var meta=document.createElement("meta");    var metaAttr={        name:"viewport",        content:`width=${fixedW},initial-scale=${scale},minimum-scale=${scale},        maximum-scale=${scale},user-scalable=no`        }        for(var key in metaAttr){            meta[key]=metaAttr[key];            }        document.head.appendChild(meta);})</xmp></pre>            </div>            <p></p>            <h3 id="s12.3">12.3 rem适配</h3>            <p></p>            <ul>                <li>根据屏幕的分辨率动态设置html的文字大小,达到等比缩放的功能</li>                <li>保证html最终算出来的字体大小,不能小于12px</li>                <li>在不同的移动端显示不同的元素比例效果</li>                <li>把设计图的宽度分成多少分之一,根据实际情况</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp>(function(){    var html=document.querySelector("html");    var timer;    function changeRem(){    var width=html.getBoundingClientRect().with;//设备宽度    if(width>540){         width=540;        }    var scale=width/10;    html.style.fontSize=scale+"px";   }function Time(){    clearTimeout(timer);    timer=setTimeout(changeRem,50);    }//页面尺寸发生变化时.重新计算文字大小,执行changeRem函数window.addEventListener("resize",function(){    Time();});//页面加载的时候,如果是调用缓存的话,这就再执行changeRem函数window.addEventLisetner("pageshow",function(e){    if(e.persisted){//缓存        Time();    }    })})()</xmp></pre>            </div>            <p></p>            <p><strong></strong></p>            <p></p>            <div class="codeMirror">                <pre><xmp>/* 假设将屏幕大小分成10份 *//*    使用flexible布局强制不要让font-size超过设计稿设置*/@media screen and (min-width:750px){    html{        font-size:75px !important;    }}body{    margin:0 auto;    min-width:320px;    width:10rem;    max-width:750px;}</xmp></pre>            </div>            <p></p>            <h3 id="s12.4">12.4 像素比适配</h3>            <p></p>            <ul>                <li>物理像素:手机屏幕分辨率</li>                <li>独立像素 指css像素的屏幕宽度</li>                <li>像素比 = 物理像素 / css</li>                <li>获取设备的像素比:window.devicePixelRatio</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp><meta name="viewport" content="initial-scale=1/dpr,maximum-scale=1/dpr,user-scalable=0,minimum-scale=1/dpr"> <!--    dpr==1:    物理像素==独立像素缩放比为1,直接布局,和上一种方法一样,1rem=设备宽度/10    dpr==2:    物理像素==2*独立像素,1rem=2*设备宽度/10,布局出来的宽度为设备宽度的两倍,所以在meta里缩小--></xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>/*文字适配*//*给html标签设置data-dpr属性 data-dpr=dpr*/[data-dpr=1] body{    font-size:12px;}[data-dpr=2] body{    font-size:24px;}[data-dpr=3] body{    font-size:36px;}</xmp></pre>            </div>            <p></p>            <p><strong></strong></p>            <p></p>            <div class="codeMirror">                <pre><xmp>if(!dpr&&!scale){    var isAndroid=window.navigator.appVersion.match(/anroid/gi);    var isIPhone=window.navigator.appVersion.match(/iphone/gi);    var devicePixelRatio=window.devicePixelRatio;    if(isIPhone){        //IOS下,对于2和3屏,用二倍的方案,其余用一倍        if(devicePixelRatio>=3&&(!dpr||dpr>=3)){            dpr=3;        }else if(devicePixelRatio>=2&&(!dpr||dpr>=2)){            dpr=2;        }else{            dpr=1;        }    }else{//其余设备        dpr=1;    }    scale=1/dpr;//缩放比例}//动态生成metavar metaEl=document.createElement("meta");metaEl.setAttribute("name","viewport");metaEl,setAttribute("content",`width=${fixedW},initial-scale=${scale},minimum-scale=${scale},maximum-scale=${scale},user-scalable=no`);document.documentElement.firstElementChild.appendChild(metaEl);</xmp></pre>            </div>            <p></p>            <p><strong>更多优化方案</strong><a href="http://www.cnblogs.com/wujindong/p/5442275.html"> http://www.cnblogs.com/wujindong/p/5442275.html</a></p>            <p></p>            <p></p>            <h3 id="s12.5">12.5 横竖屏切换</h3>            <p></p>            <ul>                <li>window.orientation判断选择角度</li>                <li>方向:竖屏0、横屏90或-90</li>                <li>根据横屏幕的切换执行不同的事情</li>                <li>横竖屏切换监听事件:orientationchange</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp>var width=(window.orientation==90||window.orientation==-90)?window.screen.height:window.screen.width;    var fixedW=660;    var meta=document.createElement("meta");    meta.setAttribute("name","viewport");    meta,setAttribute("content",`width=${fixedW},initial-scale=${scale},    minimum-scale=${scale},maximum-scale=${scale},user-scalable=no`);    document.head.appendChild(meta);    window.addEventListener("orientationchange",function(){        setRem();//横竖屏切换        setTimeout(function(){            window.location.reload();        },600);    }));    window.addEventListener("resize",function(){        setRem();//电脑端    })        setRem();    function setRem(){        var html=document.querySelector("html");        var width=html.getBoundingClientRect().width;        html.style.fontSize=width/16+"px";    }</xmp></pre>            </div>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/grid%E5%B8%83%E5%B1%80/"/>
    <url>/CodeNote/2020/10/23/zone/html/grid%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title">            <h1>GRID布局</h1>        </div>        <p></p>        <div class="list" id="s1">            <h2>1. GRID布局简介</h2>            <p></p>            <ul>                <li>CSS Grid（网格）布局，是一个二维的基于网络的布局系统。Flexbox 的出现很大程度上改善了我们的布局方式，但它的目的是为了解决更简单的一维布局，而不是复杂的二维布局（实际上 Flexbox 和 Grid 能协同工作，而且配合得非常好）。Grid(网格) 布局是第一个专门为解决布局问题而创建的 CSS 模块</li>                <li>采用grid布局的元素，被称为grid容器(grid container)，简称“容器”。其所有直接子元素（直接子元素的子元素不包含在内）自动成为容器成员，称为grid项目(grid item)，简称“项目”</li>                <li>通过指定display: grid;指定容器使用Grid布局，Grid布局中采用网格布局的区域，称为容器，容器内部采用网格定位的子元素，称为成员。容器中水平区域称为行，垂直区域称为列，可以将其看作二位数组。划分网格的线就称为网格线，正常情况下n行有n + 1根水平网格线，m列有m + 1根垂直网格线。注意当容器设置为Grid布局以后，容器子元素的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</li>            </ul>        </div>        <p></p>        <div class="list" id="s2">            <h2>2.容器（grid container）属性</h2>            <p></p>            <p>容器上的属性</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>display: grid</td>                    <td>生成一个块级(block-level)网格</td>                </tr>                <tr>                    <td>display: inline-grid</td>                    <td>生成一个行级(inline-level)网格</td>                </tr>                <tr>                    <td>grid-template-columns</td>                    <td>定义每一列的列宽</td>                </tr>                <tr>                    <td>grid-template-rows</td>                    <td>定义每一行的行高</td>                </tr>                <tr>                    <td>row-gap</td>                    <td>指定网格线的大小，可以想象为设置行之间的间距宽度</td>                </tr>                <tr>                    <td>column-gap</td>                    <td>指定网格线的大小，可以想象为设置列间的间距宽度</td>                </tr>                <tr>                    <td>gap</td>                    <td>间距的简写</td>                </tr>                <tr>                    <td>grid-template-areas</td>                    <td>指定区域</td>                </tr>                <tr>                    <td>grid-auto-flow</td>                    <td>默认是row先行后列，column是先列后行</td>                </tr>                <tr>                    <td>justify-items</td>                    <td>属性设置单元格内容的水平位置</td>                </tr>                <tr>                    <td>align-items</td>                    <td>属性设置单元格内容的垂直位置</td>                </tr>                <tr>                    <td>place-items</td>                    <td>属性是设置 align-items 和 justify-items 的简写</td>                </tr>                <tr>                    <td>justify-content</td>                    <td>属性是整个内容区域在容器里面的水平位置</td>                </tr>                <tr>                    <td>align-content</td>                    <td>属性是整个内容区域在容器里面的垂直位置</td>                </tr>            </table>            <p></p>            <h3 id="s2.1">2.1 grid-template-columns和grid-template-rows</h3>            <p></p>            <p>grid-template-rows属性定义每一行的行高，设定为多少行就设置多少个值，取值可以为固定像素，也可以为百分比，</p>            <p>grid-template-columns属性定义每一列的列宽，设定为多少列就设置多少个值，取值可以为固定像素，也可以为百分比</p>            <p></p>            <p>使用以空格分隔的多个值来定义网格的行和列，这些值表示网格轨道(Grid Track) 大小，它们之间的空格表示网格线，属性值为：</p>            <p></p>            <p>如果没有给网格线命名，轨道值之间仅有空格时，网格线会被自动分配数字名称：</p>            <p></p>            <img src="../image/grid-auto.png" alt="">            <p></p>            <table>                <tr>                    <td>值</td>                    <td>属性</td>                </tr>                <tr>                    <td>repeat()</td>                    <td>函数可以简化重复的值，其可以自动重复设定的规则</td>                </tr>                <tr>                    <td>auto-fill</td>                    <td>auto-fill关键字表示自动填充，当容器不足容纳成员时会自适应换行</td>                </tr>                <tr>                    <td>fr</td>                    <td>表示比例关系，网格布局提供了fr关键字。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。另外 fr 还可以和px，rem,em，%单位一起使用。fr 基于与其他长度值组合时的剩余空间计算。 在这个例子中，3rem和25%将来自的尺寸之前的可用空间中减去fr计算： 1fr = ((width of grid) - (3rem) - (25% of width of grid)) / 3</td>                </tr>                <tr>                    <td>minmax</td>                    <td>minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值，当距离不够时会从最大值自动减少长度或宽度到设定最小值为止。</td>                </tr>                <tr>                    <td>auto</td>                    <td>表示由浏览器自己决定长度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。</td>                </tr>                <tr>                    <td>grid-row</td>                    <td>属性是grid-row-start属性和grid-row-end的合并简写形式</td>                </tr>                <tr>                    <td>grid-area</td>                    <td>属性指定项目放在哪一个区域</td>                </tr>                <tr>                    <td>justify-self</td>                    <td>属性设置单元格内容的水平位置</td>                </tr>                <tr>                    <td>align-self</td>                    <td>属性设置单元格内容的垂直位置</td>                </tr>            </table>            <p></p>            <h3 id="s2.2">2.2 grid-template-areas</h3>            <p></p>            <p>通过引用grid-area属性指定的网格区域的名称来定义网络模板，重复网格区域的名称会使内容扩展到这些单元格（不理解可先看示例代码）。这个语法本身可看做网格的可视化结构。属性值只有3个：</p>            <p></p>            <ul>                <li>grid-area-name：由网格项grid-area指定的网格区域名称</li>                <li>.点号：代表一个空的网格单元</li>                <li>none：不定义网格区域</li>            </ul>            <p></p>            <p>示例：创建一个四列宽三行高的网格。 整个第一行将由 header 区域组成。 中间一行将由两个 main 区域、一个空单元格和一个 sidebar 区域组成。 最后一行由footer区域组成</p>            <p></p>            <div class="codeMirror">                <pre><xmp>..item-a{    grid-area: header;}.item-b{    grid-area: main;}.item-c {    grid-area: sidebar;}.item-d {    grid-area: footer;}.container{    grid-template-columns: 50px 50px 50px 50px;    grid-template-rows: auto;    grid-template-areas:        "header header header header"        "main main . sidebar"        "footer footer footer footer";}</xmp></pre>            </div>            <p></p>            <img src="../image/grid-areas.png" alt="">            <p></p>            <p>声明中的每一行都需要有相同数量的单元格，可以使用任意数量的.来声明单个空单元格。需要注意的是，不是在用这个语法命名单元格，而是在命名区域，使用这个语法时，实际上区域两端的网格线是自动命名的。 比如，如果网格区域的名称是foo，那么区域的起始的行网格线和列网格线名称是 foo-start，并且区域终点的行网格线和列网格线名称是 foo-end。 这意味着某些网格线可能有多个名称，比如上面的例子中最左边的一条网格线有三个名字：header-start，main-start和footer-start。</p>            <p></p>            <p></p>            <p></p>            <p></p>            <p>grid-template属性<br>在单个声明中定义grid-template-columns、grid-template-rows和grid-template-areas的简写</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><xmp>.container{    grid-template-rows: [row1-start] 25px [row1-end row2-start] 25px [row2-end];    grid-template-columns: auto 50px auto;    grid-template-areas:       "header header header"       "footer footer footer";}/*以上代码可简写为以下代码*/.container{  grid-template:      [row1-start] "header header header" 25px [row1-end];      [row2-start] "footer footer footer" 25px [row2-end];      / auto 50px auto;}</xmp></pre>            </div>            <p></p>            <p>注意：由于 grid-template 不会重置隐式网格属性（grid-auto-columns，grid-auto-rows和grid-auto-flow），而这可能在大多数情况是必要的，因此建议使用grid属性来代替grid-template</p>            <p></p>            <h3 id="s2.3">2.3 grid-column-gap/grid-row-gap</h3>            <p></p>            <p>指定网格线的大小，可以想象为设置列/行之间的间距宽度，属性值为                <line-size>，一个长度值，例：</p>            <p></p>            <div class="codeMirror">                <pre><xmp>.container{    grid-template-columns: 100px 50px 100px;    grid-template-rows: 80px auto 80px;    grid-column-gap: 10px;    grid-rows-gap: 15px;}</xmp></pre>            </div>            <p></p>            <p>效果图（注意：只能在列/行之间创建缝隙，而不是在外部边缘创建）</p>            <p></p>            <img src="../image/grid-gap.png">            <p>gird-gap属性是grid-row-gap 和 grid-column-gap 的简写</p>            <p></p>            <p>如果属性值只设置了一个值，则 grid-row-gap与 grid-column-gap 被设置为相同的值</p>            <p></p>            <h3 id="s2.4">2.4 justify-items\align-items</h3>            <p></p>            <p>justify-items属性设置成员中内容的水平位置，取值为start | end | center | stretch</p>            <p></p>            <p>align-items属性设置成员中内容的垂直位置，取值为start | end | center | stretch</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>属性</td>                </tr>                <tr>                    <td>stretch</td>                    <td>填充单元格的整个高度（这是默认值）</td>                </tr>                <tr>                    <td>start</td>                    <td>对齐单元格的起始边缘</td>                </tr>                <tr>                    <td>end</td>                    <td>对齐单元格的结束边缘</td>                </tr>                <tr>                    <td>center</td>                    <td>单元格内部居中</td>                </tr>            </table>            <p></p>            <p>place-items属性是align-items属性和justify-items属性的合并简写形式，如果省略第二个值，则浏览器认为与第一个值相等。</p>            <p></p>            <p></p>            <h3 id="s2.5">2.5 justify-content\align-content</h3>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>属性</td>                </tr>                <tr>                    <td>stretch</td>                    <td>默认值：拉伸，占满单元格的整个宽度。</td>                </tr>                <tr>                    <td>start</td>                    <td>对齐单元格的起始边缘</td>                </tr>                <tr>                    <td>end</td>                    <td>对齐单元格的结束边缘</td>                </tr>                <tr>                    <td>center</td>                    <td>单元格内部居中</td>                </tr>                <tr>                    <td>space-around</td>                    <td>在 grid item 之间设置均等宽度/高度的空白间隙，其外边缘间隙大小为中间空白间隙宽度的一半</td>                </tr>                <tr>                    <td>space-between </td>                    <td>在 grid item 之间设置均等宽度/高度空白间隙，其外边缘无间隙</td>                </tr>                <tr>                    <td>space-evenly</td>                    <td>在每个 grid item 之间设置均等宽度/高度的空白间隙，包括外边缘</td>                </tr>            </table>            <p></p>            <p>place-content属性是align-content属性和justify-content属性的合并简写形式，如果省略第二个值，则浏览器认为与第一个值相等。</p>            <p></p>            <h3 id="s2.6">2.6 grid-auto-columns/grid-auto-rows</h3>            <p></p>            <p>指定自动生成的网格轨道（又名隐式网格轨道）的大小。隐式网格轨道在你显式的定位超出指定网格范围的行或列时被创建，属性值&lt;track-size>可以是一个长度值、一个百分比值或一个自由空间的一部分（fr）</p>            <p></p>            <p>首先创建一个2x2的网格</p>            <p></p>            <div class="codeMirror ">                <pre><xmp>.container {    grid-template-columns: 60px 60px;    grid-template-rows: 90px 90px}</xmp></pre>            </div>            <p></p>            <img src="../image/grid2x2.png " alt=" ">            <p></p>            <p>然后使用grid-column 和 grid-row来定位你的网格项目</p>            <p></p>            <div class="codeMirror ">                <pre><xmp>.item-a{    grid-column: 1 / 2;    grid-row: 2 / 3;}.item-b{    grid-column: 5 / 6;    grid-row: 2 / 3;}</xmp></pre>            </div>            <p></p>            <img src="../image/grid定位网格.png " alt=" ">            <p></p>            <p>这里指定 .item-b开始于列网格线 5 并结束于在列网格线 6，但并未定义列网格线 5 或 6。因为引用了不存在的网格线，宽度为0的隐式轨道就会被创建用于填补间隙。可以使用 grid-auto-columns 和 grid-auto-rows属性来指定这些隐式轨道的宽度：</p>            <p></p>            <p></p>            <div class="codeMirror ">                <pre><xmp>.container{    grid-auto-columns: 60px;}</xmp></pre>            </div>            <p></p>            <img src="../image/grid-item-b.png " alt=" ">            <p></p>            <h3 id="s2.7">2.7 grid-auto-flow</h3>            <p></p>            <p>如果有一些没有明确放置在网格上的grid item，自动放置算法会自动放置这些网格项，该属性则用于控制自动布局算法的工作方式，属性值有3个：</p>            <table>                <tr>                    <td>值</td>                    <td>属性</td>                </tr>                <tr>                    <td>row</td>                    <td>默认值：告诉自动布局算法依次填充每行，根据需要添加新行</td>                </tr>                <tr>                    <td>column</td>                    <td>告诉自动布局算法依次填充每列，根据需要添加新列</td>                </tr>                <tr>                    <td>dense</td>                    <td>告诉自动布局算法，如果后面出现较小的 grid item，则尝试填充在网格中较早的空缺</td>                </tr>                <p></p>                <p>注意：dense 只会更改网格项的可视顺序，并可能导致它们出现乱序，这对可访问性不利</p>            </table>            <p></p>        </div>        <p></p>        <div class="list" id="s3">            <h2>3.项目（Grid Items）上的属性</h2>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>grid-column-start</td>                    <td>属性：左边框所在的垂直网格线</td>                </tr>                <tr>                    <td>grid-column-end</td>                    <td>属性：右边框所在的垂直网格线</td>                </tr>                <tr>                    <td>grid-row-start</td>                    <td>属性：上边框所在的水平网格线</td>                </tr>                <tr>                    <td>grid-row-end</td>                    <td>属性：下边框所在的水平网格线度</td>                </tr>                <tr>                    <td>grid-column</td>                    <td>属性是grid-column-start和grid-column-end的合并简写形式</td>                </tr>                <tr>                    <td>grid-row</td>                    <td>属性是grid-row-start属性和grid-row-end的合并简写形式</td>                </tr>                <tr>                    <td>grid-area</td>                    <td>属性指定项目放在哪一个区域</td>                </tr>                <tr>                    <td>justify-self</td>                    <td>属性设置单元格内容的水平位置</td>                </tr>                <tr>                    <td>align-self</td>                    <td>属性设置单元格内容的垂直位置</td>                </tr>            </table>            <p></p>            <h3 id="s3.1">3.1 grid-column-start/grid-column-end/grid-row-start /grid-row-end</h3>            <p></p>            <p>使用特定的网格线确定 grid item 在网格内的位置。grid-column-start/grid-row-start属性表示grid item的网格线的起始位置，grid-column-end/grid-row-end属性表示网格项的网格线的终止位置，属性值有：</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>line</td>                    <td>可以是一个数字来指代相应编号的网格线，也可以使用名称指代相应命名的网格线</td>                </tr>                <tr>                    <td>span number</td>                    <td>网格项将跨越指定数量的网格轨道</td>                </tr>                <tr>                    <td>span name</td>                    <td>网格项将跨越一些轨道，直到碰到指定命名的网格线</td>                </tr>            </table>            <p></p>            <p>举例：</p>            <p></p>            <div class="codeMirror ">                <pre><xmp>.item-a{    grid-column-start: 2;    grid-column-end: five;    grid-row-start: row1-start;    grid-row-end: 3;}</xmp></pre>            </div>            <p></p>            <img src="../image/item-a.png " alt=" ">            <p></p>            <div class="codeMirror ">                <pre><xmp>.item-b{    grid-column-start: 1;    grid-column-end: span col4-start;    grid-row-start: 2;    grid-row-end: span 2;}</xmp></pre>            </div>            <p></p>            <img src="../image/item-b.png " alt=" ">            <p></p>            <p>如果没有声明 grid-column-end / grid-row-end，默认情况下，该网格项将跨越1个轨道</p>            <p>网格项可以相互重叠，可以使用z-index来控制它们的堆叠顺序</p>            <p></p>            <h3 id="s3.2">3.2 grid-column/grid-row</h3>            <p></p>            <p>grid-column-start+ grid-column-end，和grid-row-start+ grid-row-end 的简写形式，属性值为&lt;start-line> /&lt;end-line>，每个值的用法都和属性分开写时的用法一样，例：</p>            <p></p>            <div class="codeMirror ">                <pre><xmp>.item-c{    grid-column: 3 / span 2;    grid-row: third-line / 4;}</xmp></pre>            </div>            <p></p>            <img src="../image/item-c.png " alt=" ">            <p></p>            <p>如果没有指定结束行值，则该网格项默认跨越1个轨道</p>            <p></p>            <h3 id="s3.3">3.3 grid-area</h3>            <p></p>            <p>给 grid item 进行命名以便于使用 grid-template-areas属性创建模板时来进行引用。另外也可以做为 grid-row-start+ grid-column-start+ grid-row-end+ grid-column-end 的简写形式。属性值有：</p>            <p></p>            <ul>                <li>&lt;name>：对区域的命名</li>                <li>&lt;row-start> / &lt;column-start>/&lt;row-end> / &lt;column-end>：可以是数字，也可以是网格线的名字</li>            </ul>            <p></p>            <p>举例：</p>            <p></p>            <div class="codeMirror ">                <pre><xmp>/*给一个网格项命名*/item-d{    grid-area: header;}/*简写*/.item-d{grid-area: 1 / col4-start / last-line / 6;}</xmp></pre>            </div>            <p></p>            <img src="../image/item-d.png " alt=" ">            <p></p>            <h3 id="s3.4">3.4 justify-self\align-self</h3>            <p></p>            <p>沿着行/列轴对齐grid item 里的内容。此属性对单个网格项内的内容生效</p>            <p></p>            <ul>                <li>justify-items属性设置成员中内容的水平位置，取值为start | end | center | stretch</li>                <li>align-items属性设置成员中内容的垂直位置，取值为start | end | center | stretch</li>            </ul>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>属性</td>                </tr>                <tr>                    <td>stretch</td>                    <td>填充网格区域的宽度/高度（这是默认值）</td>                </tr>                <tr>                    <td>start</td>                    <td>将内容对齐到网格区域的左端/顶部</td>                </tr>                <tr>                    <td>end</td>                    <td>将内容对齐到网格区域的右端/底部</td>                </tr>                <tr>                    <td>center</td>                    <td>将内容对齐到网格区域的中间</td>                </tr>            </table>            <p>要为网格中的所有grid items 设置对齐方式，也可以通过justify-items /align-items属性在网格容器上设置此行为</p>            <p></p>            <p>place-self属性</p>            <p>是设置 align-self 和justify-self 的简写形式</p>            <div class="codeMirror ">                <pre><xmp>.container{    place-content: <align-self> <justify-self> | auto;}</xmp></pre>            </div>            <p></p>            <p>如果省略第二个值，则将第一个值同时分配给这两个属性</p>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/Git/"/>
    <url>/CodeNote/2020/10/23/zone/html/Git/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title">            <h1>Git</h1>        </div>        <div class="list" id="s1">            <h2>1. 基本命令</h2>            <p></p>            <ul>                <li>git config --global user.name "username"：配置用户名</li>                <li>git config --global user.email"xx@gmail.xx"：配置邮箱</li>                <li>git init：初始化一个git项目</li>                <li>git add 项目文件：将指定文件添加到仓库 可以是.表示提交文件夹内的所有文件</li>                <li>git commit -m "提示"：将添加到仓库的文件提交到仓库</li>                <li>git status：显示当前仓库的状态,可以告诉我们哪些文件被修改过没有提交已经将要提交什么样的修改,如果都没有就会告诉我们git仓库很干净</li>                <li>git diff 指定文件：查看指定文件与原来的状态有什么具体的不同,也可以使用git diff HEAD -- 指定文件来查看和最新版本的区别</li>                <li>git log：显示最近到最远的提交日志和分支合并的情况,如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数git log --pretty=oneline,而使用git log --pretty=oneline --abbrev-commit可以显示历史的提交记录<br/>注：在git中用HEAD表示当前的版本,HEAD^表示上一个版本,HEAD^^表示上两个版本,依次类推</li>                <li>git reset：用于回到git仓库以前的版本如：git reset --hard HEAD^回到上个版本                    <br/>注意：这时候使用git log就看不到最后一次提交的版本了,要重新回到那个版本需要不关闭这次窗口,然后找到前面提交的commit id,因为每次commit都会对应提交一个commit id,而且版本后不需要写全,写出前几位git会自动去寻找到对应的版本号git reset --hard 5627c,也就是所HEAD指向谁谁就是现在的版本号</li>                <li>git reflog：该命令能够记录每一次跟换版本号的命令,通过该命令能很快查找到想要直接退回的版本号</li>                <li>git checkout -- 指定文件(readme.txt)：将指定文件在工作区的修改全部撤销(注意是工作区.不是暂存区),有两种情况</li>                <ul>                    <li>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态</li>                    <li>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态</li>                </ul>            </ul>            <p></p>            <p>注意：在这里一定要在中间加上--,不然就是切换到分支了,所以git checkout其实有两种用法</p>            <p></p>            <ul>                <li>git reset HEAD 指定文件：git reset的第二个用法,将保存在暂存区的文件撤销掉,重新放回工作区,然后就可以又使用git checkout -- 指定文件来丢弃工作区的更改</li>                <li>git rm 指定文件：先在工作文件夹中使用rm 指定文件将指定文件删除,然后在使用git rm 指定文件在用git commit提交就可以删除git仓库中的指定文件<br/>注：</li>                <ul>                    <li>先手动删除文件，然后使用git rm &lt;file>和git add&lt;file>效果是一样的</li>                    <li>如不小心删错了工作区的目录,可以使用git checkout -- 指定文件修改撤销,但是要注意这个文件是要在git仓库中存在才可以,没有添加到git仓库的文件是无法恢复的</li>                </ul>            </ul>            <p></p>        </div>        <p></p>        <div class="list" id="s2">            <h2>2.工作区与暂存区</h2>            <p></p>            <p>工作区是在git中进行操作的区域,暂存区是用git add提交到的地方,然后使用git commit将暂存区里的文件提交到分支,提交后工作区就是干净的了</p>        </div>        <p></p>        <div class="list" id="s3">            <h2>3.添加到远程库</h2>            <p></p>            <p>在github或其他git仓库创建一个git的远程仓库,使用git remote add origin github上对应的地址 (git@github.com:michaelliao/learngit.git)</p>            <p></p>            <p></p>            <p>注：添加后，远程库的名字就是origin，这是git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库</p>            <p></p>            <p></p>            <p>然后使用git push -u origin master把本地库的内容推送到远程</p>            <p></p>            <p>注：用git push命令，实际上是把当前分支master推送到远程,由于远程库是空的，第一次推送master分支时，加上了-u参数，git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令</p>            <p></p>            <p></p>            <p>以后每次本地提交了修改,就可以通过git push origin master把本地的master分支推送到github,之所以是master是因为创建的时候就叫master</p>        </div>        <p></p>        <div class="list" id="s4">            <h2>4.从远程库克隆</h2>            <p></p>            <p>使用git clone github上对应的地址就可以在文件夹中克隆一个远程仓库到本地</p>        </div>        <p></p>        <div class="list" id="s5">            <h2>5.创建分支与合并</h2>            <p></p>            <p>git鼓励我们使用分支,因为更加具有安全性</p>            <p></p>            <ul>                <li>查看分支：git branch</li>                <li>创建分支：git branch &lt;name>&lt;/name></li>                <li>切换分支：git checkout &lt;name>&lt;/name></li>                <li>创建+切换分支：git checkout -b &lt;name>&lt;/name></li>                <li>合并某分支到当前分支：git merge &lt;name>&lt;/name></li>                <li>删除分支：git branch -d &lt;name><br/>注意：如果没有合并过就要删除,必须使用git branch -D &lt;name>才能够强制删除</li>            </ul>            <p></p>            <p>在本地仓库中,HEAD其实并不是指向提交,而是指向的当前分支,只是先前只有一个分支master,HEAD指向的就是当前分支</p>            <p></p>            <p></p>            <p>当我们新创建一个分支的时候,git就会新创建一个分支指针,该指针指向master相同的提交,如果再把HEAD指向该分支,当前分支就在该分支上,然后再切回master分支就可以将在该分支上的操作合并到master分支上,最后删除该分支,使得修改更加安全</p>            <p></p>            <p></p>            <ul>                <li>git checkout -b dev创建一个dev分支,并且切换到dev分支,这个加了-b的指令相当于先后执行了git branch dev创建分支和git checkout dev将当期分支切换到dev分支上</li>                <li>直接使用git branch命令可以查看当前分支。git branch命令会列出所有分支，当前分支前面会标一个*号</li>                <li>然后可以在这个dev分支上进行各种和前面一样的提交操作</li>                <li>但是使用git checkout master切换到master分支的时候会发现在dev分支上提交的所有修改和操作都没有,因为这其实是两个分支了,刚刚是在deb分支上做的修改,所有master分支上看文件是没有发生改变的</li>                <li>可以使用git merge dev用于合并指定分支到当前分支,注意这个时候是已经将当前分支切换到了master分支上了的,在查看文件的修改,会发现和在dev分支上的修改一样,说明合并是成功了的</li>                <li>然后就可以使用git branch -d dev将dev分支删除掉,再次使用git branch会发现已经没有dev分支了</li>            </ul>            <p></p>            <p></p>            <p>注：通常，合并分支时，如果可能，git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息,也就是首不知道是否进行了分支的合并,如果要强制禁用Fast forward模式，git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。我们可以使用git merge --no-ff -m "提交内容" 合并分支,这样就可以使用git log查看分支历史</p>        </div>        <p></p>        <div class="list" id="s6">            <h2>6.暂缓工作区</h2>            <p></p>            <p>当我们遇到BUG时,需要修复BUG,但是手头又有工作,这是需要先暂缓手头工作,使用git stash储存手头工作,不管有没有提交,这时git status会发现工作区是干净的,然后确立哪个分支出BUG,在那个分支上创建一个新的分支,修改完成后合并到那个分支(不一定是master),删除新创建分支,然后使用回到原来工作的分支,恢复工作区：</p>            <p></p>            <p></p>            <ul>                <li>可以先使用git stash list查看所有暂存工作区</li>                <li>然后恢复工作区,有两种方法：</li>                <ul>                    <li>一是用git stash apply恢复，但是恢复后，stash内容并不删除，需要用git stash drop来删除</li>                    <li>另一种方式是用git stash pop，恢复的同时把stash内容也删了</li>                </ul>                <li>在使用git stash list就看不到暂存内容了,也可以多次暂存工作区,每一次暂存都会在列表中添加一个,使用git stash apply 指定工作区(stash@{0})就可以恢复到对应的工作区</li>            </ul>        </div>        <div class="list" id="s7">            <h2>7.多人协作</h2>            <p></p>            <p>当从远程仓库克隆时，实际上git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin</p>            <p></p>            <ul>                <li>git remote：该命令可以查看远程仓库的信息,一般只有一个远程仓库的名字，使用git remote -v可以查看远程仓库的详细信息                    <div class="codeMirror">                        <pre><xmp>origin  git@github.com:michaelliao/learngit.git (fetch)    origin  git@github.com:michaelliao/learngit.git (push)</xmp></pre>                    </div>                    <p>上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址</p>                </li>                <li>git push 对应仓库名 对应分支名：把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上,如git push origin master和git push origin dev</li>                <p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>                <ul>                    <li>master分支是主分支，因此要时刻与远程同步</li>                    <li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步</li>                    <li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug</li>                    <li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发</li>                </ul>            </ul>            <p></p>            <h3 id="s7.1">7.1 合作开发</h3>            <p></p>            <p></p>            <p>在多人合作时，大家都会往master和dev分支上推送各自的修改,当一个成员克隆一个git项目时, 新的成员默认情况下只能看到master分支上的内容,用git branch看也只会有一个master分支显示,如果要在dev分支上进行开发,那么就需要创建远程库的dev分支都本地,使用git checkout -b dev origin/dev来创建,这样在本地的dev上做修改就能上传到远程的dev分支了</p>            <p></p>            <p></p>            <p></p>            <h3 id="s7.2">7.2 推送冲突</h3>            <p></p>            <p>如果你的提交和远程仓库中别人最新的提交有冲突,那么就会推送失败,无法推送到远程仓库,这个时候先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。但是这个dev分支会pull失败,原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示(pull错误里面会有)，设置dev和origin/dev的链接：git branch --set-upstream-to=origin/dev dev。再次pull就能成功了，然后就是手动解决冲突的问题,然后再次提交,再次push</p>            <p></p>        </div>        <p></p>        <div class="list" id="s8">            <h2>8.标签管理</h2>            <p></p>            <p>切换到需要打标签的分支上，然后敲命令git tag &lt;name>就可以打上标签，注意标签其实是打在提交上的，如git tag v1.0，可以用git tag查询所有的标签，默认标签是打在最新提交的commit上的，可以通过git tag v0.9 提交的id(f52c633)来为指定的提交打上标签,使用git show &lt;tagname>就可以显示该标签的具体信息,简化操作,如：git show v0.9</p>            <p></p>            <p></p>            <p>还可以创建带有说明的标签git tag -a v0.1 -m "version 0.1 released" 1094adb，用-a指定标签名，-m指定说明文字</p>            <p></p>            <p></p>            <p>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签</p>            <p></p>            <ul>                <li>git tag -d &lt;tagname>：删除指定标签，因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除</li>                <li>git push origin &lt;tagname>：推送某个标签到远程仓库,也可以使用git push origin --tags一次性全部推送</li>                <li>如果要删除远程仓库的标签,使用git tag -d v0.9先将本地的删除,然后使用git push origin :refs/tags/v0.9把远程标签删除</li>            </ul>        </div>        <p></p>        <div class="list" id="s9">            <h2>9.忽略文件</h2>            <p></p>            <p>使用windows时,如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了</p>            <p></p>            <p></p>            <p>如果有时添加不了一个文件,就是因为该文件被.gitignore忽略了,如果确实想添加,使用使用git add -f 添加的文件进行强制添加,或者也可以查看在.gitignore中哪个文件使用出错了.通过git check-ignore命令进行查看，如git check-ignore -v App.class</p>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/Express/"/>
    <url>/CodeNote/2020/10/23/zone/html/Express/</url>
    
    <content type="html"><![CDATA[<aside class="Left-nav" id='navbox'>    <div class="aside-head">        <h3>目录</h3>        <div class="mainnav">            <div class="rightsidebar">                <div class="column">                    <h4 class="summary" id="drop"><i></i>HTML</h4>                    <div class="onhide">                        <li>                            <a href="#">命名参考</a>                        </li>                        <li>                            <a href="#">HTML</a>                        </li>                        <li>                            <a href="#">HTML5</a>                        </li>                    </div>                </div>                <div class="column">                    <h4 class="summary" id="drop"><i></i> CSS</h4>                    <div class="onhide">                        <li>                            <a href="#">CSS</a>                        </li>                        <li>                            <a href="#">less</a>                        </li>                    </div>                </div>                <div class="column">                    <h4 class="summary" id="drop"><i></i> JavaScript</h4>                    <div class="onhide">                        <li>                            <a href="#">JS</a>                        </li>                        <li>                            <a href="#">DOM</a>                        </li>                        <li>                            <a href="#">BOM</a>                        </li>                        <li>                            <a href="#">JS编码风格指南</a>                        </li>                    </div>                </div>                <div class="column">                    <h4 class="summary" id="drop"><i></i> 数据存储与交换</h4>                    <div class="onhide">                        <li>                            <a href="#">Ajax</a>                        </li>                        <li>                            <a href="#">存储数据</a>                        </li>                    </div>                </div>                <div class="column">                    <h4 class="summary" id="drop"><i></i> Node</h4>                    <div class="onhide">                        <li>                            <a href="#">Express</a>                        </li>                        <li>                            <a href="#">Node.js</a>                        </li>                    </div>                </div>                <div class="column">                    <h4 class="summary" id="drop"><i></i>Vue</h4>                    <div class="onhide">                        <li>                            <a href="#">Vue项目创建打包与UI资源</a>                        </li>                        <li>                            <a href="#">Vue.js</a>                        </li>                        <li>                            <a href="#">Vue插件</a>                        </li>                        <li>                            <a href="#">Vue源码解析</a>                        </li>                        <li>                            <a href="#">Vue简易案例</a>                        </li>                    </div>                </div>                <div class="column">                    <h4 class="summary" id="drop"><i></i> 数据库</h4>                    <div class="onhide">                        <li>                            <a href="#">Mongodb</a>                        </li>                    </div>                </div>                <div class="column">                    <h4 class="summary" id="drop"><i></i>项目管理工具</h4>                    <div class="onhide">                        <li>                            <a href="#">Git</a>                        </li>                    </div>                </div>            </div>        </div>    </div></aside><div class="content">    <div class="main">        <div class="title">            <h1>Express</h1>            <p></p>            <p>express是一款Node.js框架</p>            <p></p>        </div>        <div class="list" id="s1">            <h2>1.引入express</h2>            <div class="codeMirror">                <pre><xmp>npm install express --save</xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>//app.jsconst express=require("express");//这句代码相当于原生的http.createServer(),创建一个服务器端口const app=express();//express可以自动将静态的文件设置好路由app.use(express.static("public"));/*上面的代码有两个作用:1.自动为public目录下的文件设置路由(public与app.js为同一层级)2.自动把public目录下的index.html设置为根路径对应的首页*//*同时可以公开指定目录,通过这种方法可以直接访问文件目录下的所有资源(通过完整的文件名)第一个参数不一定是static,可以是随便的路由标识,但是后面可以直接使用static目录的资源app.use("/static/",express.static("./static/"));而上面的方法其实是个省略第一个参数的简便写法,可以通过省略/public的方式获取资源*/                      app.listen(3000);</xmp></pre>            </div>            <p></p>            <p>热部署服务器</p>            <p></p>            <ul>                <li>node.js热部署,修改后立刻重启服务器cnpm install -g supervisor,全局安装后运行supervisor app.js(假设Node.js程序主入口是app.js)</li>                <li>热部署第二种方法为cnpm install nodemon -g,全局安装后运行nodemon app.js(假设Node.js程序主入口是app.js)</li>                <li>在使用项目前可以先初始化项目使用npm init -y</li>            </ul>            <p></p>        </div>        <div class="list" id="s2">            <h2>2.request请求</h2>            <p></p>            <ul>                <li>app.get(路由,回调函数),回调函数在符合指定路径并且是get请求时触发</li>                <li>app.post(路由,回调函数),回调函数在符合指定路径并且是post请求时触发</li>                <li>app.use(路由,回调函数),回调函数在符合指定路径并且不论请求方式是什么都会触发</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><xmp>const express=require("express");const app=express();                        app.use('/login',(req,res)=>{//query和params等属性只有通过get方式进行请求的时候才会有    console.log(req.query);//请求后面的查询数据保存在req.query中,req.query是一个对象    console.log(req.params);//后面的如:number形式的数据保存在req.params里    res.end("login");})</xmp></pre>            </div>            <p></p>            <p>获取post请求数据</p>            <p></p>            <p>express原生的post请求获取数据的方式很麻烦,所以推荐使用第三方的插件</p>            <p></p>            <p>注:现在好像不需要这个现在这个插件就能使用,只需要设置app.use(express.json())就能获取到</p>            <p></p>            <ul>                <li>formidable                    <div class="codeMirror">                        <pre><xmp>cnpm i -S formidable</xmp></pre>                    </div>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>const formidable=require("formidable");const path=require("path");var form = new formidable.IncomingForm();//创建实例form.uploadDir="./upload";//如果是要得到post请求中上传的文件,需要指定上传文件目录,注意必须先创建form.parse(req,(err,fileds,files)=>{    //fileds为字符型的post数据    //files为文件类的post数据    let extname=path.extname(files.myfile.name);    //因为通过formidable存入的文件默认是没有后缀名的,所以加上    fs.rename(files.myfile.path,files.myfile.path+extname,()=>{        res.send("OK");    }) })</xmp></pre>                    </div>                </li>                <li>body-parser                    <div class="codeMirror">                        <pre><xmp>cnpm install body-parser -S</xmp></pre>                    </div>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>const bodyParser = require('body-parser');const express=require("express");const app=express();app.use(bodyParser.urlencoded({//因为post数据传入的是url编码,所以在写中间件的时候需要解析    extended:false //是否激活扩展,默认是激活状态}));app.use(bodyParser.json());//转换为json//加入了body-parser配置后就会在req对象上多出body属性app.post("/login",(req,res)=>{    console.log(req.body);//post请求就可以直接在req.body中取得})</xmp></pre>                    </div>                </li>                <li>blueimp-md5                    <div class="codeMirror">                        <pre><xmp>cnpm install body-parser -S</xmp></pre>                    </div>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>const md5 = require("blueimp-md5");const bodyParser = require('body-parser');const express=require("express");const app=express();app.use(bodyParser.urlencoded({//因为post数据传入的是url编码,所以在写中间件的时候需要解析    extended:false //是否激活扩展,默认是激活状态}));app.use(bodyParser.json());//转换为json//加入了body-parser配置后就会在req对象上多出body属性app.post("/login",(req,res)=>{    console.log(req.body);//post请求就可以直接在req.body中取得    console.log(md5(md5(req.body.password)));    //md5二次加密,以后在使用的时候也是会加密后再比较,只能加密不能解密})</xmp></pre>                    </div>                </li>                <li>bcrypt                    <div class="codeMirror">                        <pre><xmp>cnpm install bcrypt -S</xmp></pre>                    </div>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>//bcrypt也是一个加密的模块const bcrypt=require("bcrypt");const bodyParser = require('body-parser');const express=require("express");const app=express();app.use(bodyParser.urlencoded({//因为post数据传入的是url编码,所以在写中间件的时候需要解析    extended:false //是否激活扩展,默认是激活状态}));app.use(bodyParser.json());//转换为json//加入了body-parser配置后就会在req对象上多出body属性app.post("/resgister",(req,res)=>{    console.log(req.body);//post请求就可以直接在req.body中取得    console.log(body.password = bcrypt.hashSync(req.body.password),10);    //通过散列的方法进行加密,后面的数字散列强度,数字越大强度越高,但是效率会减弱})</xmp></pre>                        <p></p>                        <div class="codeMirror">                            <pre><xmp>app.post("/login",(req,res)=>{//加密后比对密码,如果一致返回true,否则为falseconst isPasswordValid=bcrypt.compareSync(req.body.password,user.password);//req.body.password是接收到的登录密码user.password是数据库保存的密码if(!isPasswordValid){    return res.status(422).send({        message:"密码无效"    })}res.send({    user})  })</xmp></pre>                        </div>                    </div>                </li>            </ul>        </div>        <div class="list" id="s3">            <h2>3.response回应</h2>            <p></p>            <ul>                <li>res.send(数据),作为结束响应的标志,该方法比元素的res.end()方法更加强大,不只可以穿buffer数据和字符串,也可以直接传入对象和数组等值</li>                <li>res.sendFile(文件路径),发送文件到客户端,参数是文件路径</li>                <li>res.json(json对象),express封装过的方法,可以直接返回给前端一个json格式的对象字符串</li>                <li>res.render(传入的模板页面,传入ejs页面的参数对象),专门用来渲染views目录(这是必须的)下的ejs文件的方法<br/>在这里使用ejs模板引擎</li>            </ul>            <p>注:也可使用art-template模板引擎</p>            <div class="codeMirror">                <pre><xmp>cnpm install ejs -S</xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>const express = require("express");const app = express();app.set("view engine", "ejs");//在这里设置使用ejs模板引擎/*或者app.engine("ejs",require("ejs"));*/app.use('/login',(req,res)=>{    let result=10;    res.render("showIndex",{        a:result        });    /*    render()方法默认是不可用的,但是如果配置了模板引擎就可以使用    res.render()可以默认将views目录下的ejs文件直接渲染到页面,只用传文件名,    后面跟一个对象,对象中的属性就是传入ejs页面的值    如果要修改默认的views目录,可以使用app.set("views",render函数渲染的默认路径)    */})</xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp><!--showIndex.ejs--><!DOCTYPE html><html lang="en">    <head>        <meta charset="UTF-8" />        <meta name="viewport" content="width=device-width, initial-scale=1.0" />        <meta http-equiv="X-UA-Compatible" content="ie=edge" />        <title>Document</title>    </head>    <body>        <ul>          <%for(let i=0;i<a;i++){ %>    <!--a是从render函数传过来的值-->          <li>我是第<%= i%>个li</li>          <%}%>          <!--            ejs是后台模板            通过<% js代码%>可以在中间写js代码,通过<%= 变量%>可以在中间赋值,实现传值进入页面          -->          </ul>    </body></html></xmp></pre>            </div>        </div>        <div class="list" id="s4">            <h2>4.cookie和session</h2>            <p></p>            <h3 id="s4.1">4.1 cookie</h3>            <p></p>            <p>在路由的response中可以使用下面的cookie方法进行对cookie的设置</p>            <p></p>            <div class="codeMirror">                <pre><xmp>npm install express --save</xmp></pre>            </div>            <p></p>            <ul>                <li>res.cookie(name,value,[option]):设置Cookie<br/>opition包括:domain / expires / httpOnly / maxAge / path / secure / signed                    <div class="codeMirror">                        <pre><xmp>const express=require("express");const app=express();app.get("/login",(req,res)=>{    res.cookie("key","666",{        maxAge:1000 //设置此cookie过期时长    });    res.send();});</xmp></pre>                    </div>                </li>                <li>res.clearCookie():清除Cookie                    <div class="codeMirror">                        <pre><xmp>const express=require("express");const app=express();app.get("/login",(req,res)=>{    res.clearCookie();    res.send();});</xmp></pre>                    </div>                </li>            </ul>            <p></p>            <p>获取cookies信息</p>            <p></p>            <p>在express中获取cookies的信息需要使用对应的中间件cookie-parser</p>            <p></p>            <div class="codeMirror">                <pre><xmp>cnpm install cookie-parser --save</xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>const cookieParser=require("cookie-parser");const express=require("express");const app=express();app.use(cookieParser());app.get("/login",(req,res)=>{    console.log(req.cookies);//注意查询cookies在req中查看    res.send();});</xmp></pre>            </div>            <p></p>            <h3 id="s4.2">4.2 session</h3>            <p></p>            <p>在express设置和获取session需要使用中间件express-session</p>            <p></p>            <div class="codeMirror">                <pre><xmp>cnpm install express-session --save</xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>const session=require("express-session");const express=require("express");const app=express();app.use(session({    secret:"key",//配置加密字符串,与存入的session配合加密,安全性更高,防止客户端恶意伪造    cookie:{maxAge:60000},    resave:true,    //每次请求都重新设置session cookie，假设cookie是10分钟过期,每次请求都会再设置10分钟    saveUninitialized:true    /*    无论有没有session cookie,每次请求都设置个session cookie,默认给个标示为 connect.sid,    如果为false就是当正在存了数据才会发送    */}));app.get("/",(req,res)=>{    console.log(req.session);    console.log(req.session.user);});app.get("/login",(req,res)=>{    req.session.user=req.session.user||[];//通过属性进行设置    req.session.user.push(req.query.user);    res.send();})/*    读取:req.session.xxx    设置:req.session.xxx=xxx    删除:delete req.session.xxx*/</xmp></pre>            </div>            <p></p>            <p>注意:默认session数据是内存存储的,服务器一旦重启就会丢失,真正的生产环境会吧session进行持久化存储</p>            <p></p>            <h3 id="s4.3">4.3 token</h3>            <p></p>            <p>在express中同样可以设置token来获取本地的存储信息,需要使用中间件jsonwebtoken</p>            <p></p>            <div class="codeMirror">                <pre><xmp>cnpm i jsonwebtoken -S</xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>const jwt=require("jsonwebtoken");const SECRET="sadasdasda";//密钥app.post("/login",(req,res)=>{    //加密后比对密码,如果一致返回true,否则为false    const isPasswordValid=bcrypt.compareSync(req.body.password,user.password);    //req.body.password是接收到的登录密码user.password是数据库保存的密码    if(!isPasswordValid){        return res.status(422).send({            message:"密码无效"        })    }    const token=jwt.sign({//设置用户的_id为token        id:String(user._id)//只需要传入用户ID,不要传密码    },SECRET);//第二个参数是一个密钥,随便填什么都可以,但是应该是保密的,不应该在git项目中,    应该在本地,需要的时候获取,因为要多次使用,所以直接定义成一个变量    res.send({        user,        token    })  })//读取服务端返回的信息app.get("/login/profile",(req,res)=>{    const raw=String(req.headers.authorization);    //客户端发送请求的时候应该带上请求头,请求头中就是服务端返回给客户端的token    const  {id}=jwt.verify(raw,SECRET);//解密,通过token和密钥解密    const user=User.findById(id);//数据库查找用户    res.send(user);})</xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>//一般每一步都需要用户进行验证,所以需要设置一个中间件在每一次需要用户信息的时候就调用这个中间件进行判断const auth=async(req,res,next)=>{    const raw=String(req.headers.authorization);    //客户端发送请求的时候应该带上请求头,请求头中就是服务端返回给客户端的token    const  {id}=jwt.verify(raw,SECRET);//解密,通过token和密钥解密    req.user=User.findById(id);//数据库查找用户,同时因为是使用中间件,所以需要挂载到req对象上    next();}app.get("/login/profile",auth,(req,res)=>{    res.send(req.user);})</xmp></pre>            </div>        </div>        <div class="list" id="s5">            <h2>5.路由分离</h2>            <p></p>            <ul>                <li>常规写法                    <div class="codeMirror">                        <pre><xmp>//app.js/*入门模块:创建服务、做服务相关配置、模板引擎、body-parser解析post请求、提供静态资源、监听端口*/let express=require("express");let router=require("./router");let app=express();router(app);//通过这种方法将app传入router.jsapp.listen(3000,function(){    console.log("running 3000");})</xmp></pre>                    </div>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>//router.js/*路由模块:处理路由、根据不同请求方法和请求路径进行具体处理*/module.exports=function(app){    app.get("/",function(req,res){        res.send("index");    });}</xmp></pre>                    </div>                </li>                <li>express的router写法(express推荐)                    <div class="codeMirror">                        <pre><xmp>//app.jslet express=require("express");let router=require("./router");let app=express();//把路由容器挂载到app,这样就可以直接访问路由了app.use(router);//注意配置模板引擎和body-parser必须在这之前/*上面那种写法是讲所有路由都放在一个文件中,如果需要放入多个文件的话同时二级目录指定的话app.use("/login",require(./route/login));另一个文件的内部写法同上,不过如果内部也只用写二级的目录格式,不需要在前面加上/login,不过在访问的时候还是需要加上的,这种方法可以实现分路由的管理*/app.listen(3000,function(){    console.log("running 3000");})</xmp></pre>                    </div>                    <p></p>                    <div class="codeMirror">                        <pre><xmp>//router.jslet express=require("express");//创建一个路由容器let router=express.Router();//express推荐使用的挂载路由的方式//把路由都挂载到路由容器上router.get("/",function(req,res){        res.send("index");});module.exports=router;</xmp></pre>                    </div>                </li>            </ul>        </div>        <div class="list" id="s6">            <h2>6.中间件</h2>            <p></p>            <p>中间件的本质就是一个请求处理方法,我们把用户从请求到响应的整个过程分发到多个中间件中去处理,这样做的目的是提高代码的灵活性,动态可扩展的</p>            <p></p>            <h3 id="s6.1">6.1 应用程序级别中间件</h3>            <p></p>            <p>中间件的处理顺序是从上到下依次处理,而且相同的请求路径中的参数属性一致,所以才说第三方中间件必须要写在所有路由请求前,因为这样就能用中间件的各种查询了</p>            <p></p>            <ul>                <li>万能匹配的中间件(不关心任何请求路径和请求方法),全部都能匹配<br/>注:第三方中间件常常就是这种万能匹配能够匹配到所有的路径                    <div class="codeMirror">                        <pre><xmp>app.use(function(req,res,next){console.log("Time",Data.now());    next();})</xmp></pre>                    </div>                </li>                <li>匹配所有以/xxx/开头的                    <div class="codeMirror">                        <pre><xmp>app.use("/a",function(req,res,next){    console.log("Time",Data.now());    next();})</xmp></pre>                    </div>                </li>            </ul>            <p></p>            <h3 id="s6.2">6.2 路由级别中间件</h3>            <p></p>            <ul>                <li>get                    <div class="codeMirror">                        <pre><xmp>app.get("/",function(req,res){    res.send("Hello world");})</xmp></pre>                    </div>                </li>                <li>post:                    <div class="codeMirror">                        <pre><xmp>app.post("/",function(req,res){    res.send("Hello world");})</xmp></pre>                    </div>                </li>                <li>put:                    <div class="codeMirror">                        <pre><xmp>app.put("/",function(req,res){    res.send("Hello world");})</xmp></pre>                    </div>                </li>                <li>delete:                    <div class="codeMirror">                        <pre><xmp>app.delete("/",function(req,res){    res.send("Hello world");})</xmp></pre>                    </div>                </li>            </ul>            <p></p>            <p>注意:路由的中间件也是有next的,如果不调用就不会执行后续中间件,但是因为路由一般都只进入一个中间件,所有一般没有写next参数,但是如果写两个相同的路由,就必须写next才会从前面一个路由进入后面一个路由</p>            <p></p>            <h3 id="s6.3">6.3 错误处理中间件</h3>            <p></p>            <p>可以在所有的路最后写入一个错误处理中间件,只要遇到错误就会直接跳到这个错误处理中间中.不必每一个路由就要进行专门的错误处理</p>            <p></p>            <p>注意:只要向路由中的第三个形参传入值,就可以直接找到有四个参数的中间件</p>            <p></p>            <div class="codeMirror">                <pre><xmp>//错误处理中间件必须要写四个参数,第一个参数是其他中间件传过来的错误,如果只写三个就只是形参不同而已app.use(function(err,req,res,next){    console.log(err.message);    res.status(500).send("error!");})</xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>app.get("/",function(req,res,next){    fs.readFile(function(err,data){        if(err){//一般都是直接传入错误对象            next(err);          }     })})app.use(function(err,req,res,next){//上面传入的错误对象会直接复制给第一个形参err   console.log(err.message);   res.status(500).send("error!");})</xmp></pre>            </div>            <p></p>            <p>当然，我们可以自定义错误处理的中间件，比如使用一个函数来进行包装（比如使用promise时）</p>            <p></p>            <div class="codeMirror">                <pre><xmp>// middleware/async.jsmodule.export = function (handler) {    return async (req, res, next) => {        try{            await handler(req, res)        }catch(e){            next(e)        }    }}</xmp></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><xmp>const asyncMiddleware = require('../middleware/async')    app.use(asyncMiddleware(async (req, res) => {        await // do something}))</xmp></pre>            </div>            <p></p>            <p>当然，这样每次调用还是很麻烦，最后的方法是使用express-async-errors来帮忙处理异常。</p>            <p></p>            <div class="codeMirror">                <pre><xmp>// 直接加载，在index.js中加载全局引入require('express-async-errors')app.use((req, res ,next) => {    await // do something})</xmp></pre>            </div>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/DOM/"/>
    <url>/CodeNote/2020/10/23/zone/html/DOM/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title">            <h1>DOM</h1>            <p></p>            <p>DOM全称Document Object Model(文档对象模型)</p>            <p></p>            <ul>                <li>文档:整个HTML网页文档对象</li>                <li>对象:网页中的每一个部分都被转换为了一个对象</li>                <li>模型:使用模型表示对象之间的关系，方便我们获取对象</li>            </ul>        </div>        <p></p>        <div class="list" id="s1">            <h2>1.节点</h2>            <p>Node(节点)是构成HTML5的基本单元,DOM节点主要分为四类</p>            <p></p>            <h3 id="s1.1">1.1 主要事件</h3>            <div>                <ul>                    <li>文档节点:整个HTML文档</li>                    <li>元素节点:HTML文档中的HTML标签</li>                    <li>属性节点:元素的属性</li>                    <li>文本节点:HTML标签中的文本内容</li>                </ul>                <p></p>                <table>                    <tr>                        <td>节点</td>                        <td>nodeName(节点名)</td>                        <td>nodeType(节点类型)</td>                        <td>nodeValue(节点值)</td>                    </tr>                    <tr>                        <td>文档节点</td>                        <td>#document</td>                        <td>9</td>                        <td>null</td>                    </tr>                    <tr>                        <td>元素节点</td>                        <td>标签名</td>                        <td>1</td>                        <td>null</td>                    </tr>                    <tr>                        <td>属性节点</td>                        <td>属性名</td>                        <td>2</td>                        <td>属性值</td>                    </tr>                    <tr>                        <td>文本节点</td>                        <td>#text</td>                        <td>3</td>                        <td>文本内容</td>                    </tr>                </table>                <p></p>                <p>注:</p>                <p></p>                <ul>                    <li>浏览器已经为我们提供了文档节点对象window,该对象可以在页面中直接使用,代表的是整个网页</li>                    <li>通过nodeType===1可以判断某节点是否是元素节点</li>                    <li>文本节点包含了在写代码时的回车换行符间产生的空白，但是IE8及以下的浏览器中不会将空白节点当作子节点，而其他浏览器会</li>                    <li>通过nodeName返回的标签名是全大写的</li>                    <li>元素节点的名字也可以通过专门的TagName属性获得</li>                </ul>            </div>        </div>        <div class="list" id="s2">            <h2>2.DOM事件</h2>            <p></p>            <p>事件是用户和浏览器之间的交互行为</p>            <p></p>            <h3 id="s2.1">2.1 鼠标事件</h3>            <p></p>            <table>                <tr>                    <td>属性</td>                    <td>描述</td>                </tr>                <tr>                    <td>onclick</td>                    <td>当用户点击某个对象时调用的事件句柄。单击鼠标左键或者按下回车键时触发,意味着onclick事件处理程序既可以通过键盘也可以通过鼠标执行</td>                </tr>                <tr>                    <td>oncontextmenu</td>                    <td>在用户点击鼠标右键打开上下文菜单时触发。可以用做自定义菜单</td>                </tr>                <tr>                    <td>ondblclick</td>                    <td>当用户双击某个对象时调用的事件句柄。双击鼠标左键时触发</td>                </tr>                <tr>                    <td>onmousedown</td>                    <td>鼠标按钮被按下。</td>                </tr>                <tr>                    <td>onmouseenter</td>                    <td>当鼠标指针移动到元素上时触发。该事件不冒泡，即鼠标移到其后代元素上时不会触发。</td>                </tr>                <tr>                    <td>onmouseleave</td>                    <td>当鼠标指针移出元素时触发。该事件不冒泡，即鼠标移出其后代元素时不会触发。</td>                </tr>                <tr>                    <td>onmousemove</td>                    <td>鼠标被移动。</td>                </tr>                <tr>                    <td>onmouseover</td>                    <td>鼠标移到某元素之上。鼠标移到其后代元素上时会触发,意味着支持冒泡</td>                </tr>                <tr>                    <td>onmouseout</td>                    <td>鼠标从某元素移开。支持冒泡</td>                </tr>                <tr>                    <td>onmouseup</td>                    <td>鼠标按键被松开。</td>                </tr>            </table>            <p></p>            <h3 id="s2.2">2.2 键盘事件</h3>            <p></p>            <table>                <tr>                    <td>属性</td>                    <td>描述</td>                </tr>                <tr>                    <td>onkeydown</td>                    <td>某个键盘按键被按下。</td>                </tr>                <tr>                    <td>onkeypress</td>                    <td>某个键盘按键被按下并松开。</td>                </tr>                <tr>                    <td>onkeyup</td>                    <td>某个键盘按键被松开。</td>                </tr>            </table>            <p></p>            <h3 id="s2.3">2.3 框架/对象事件</h3>            <p></p>            <table>                <tr>                    <td>属性</td>                    <td>描述</td>                </tr>                <tr>                    <td>onabort</td>                    <td>图像的加载被中断。 ( &lt;object>)</td>                </tr>                <tr>                    <td>onbeforeunload</td>                    <td>该事件在即将离开页面（刷新或关闭）时触发</td>                </tr>                <tr>                    <td>onerror</td>                    <td>在加载文档或图像时发生错误。 ( &lt;object>, &lt;body>和 &lt;frameset>)</td>                </tr>                <tr>                    <td>onhashchange</td>                    <td>该事件在当前 URL 的锚部分发生修改时触发。</td>                </tr>                <tr>                    <td>onload</td>                    <td>一张页面或一幅图像完成加载。</td>                </tr>                <tr>                    <td>onpageshow</td>                    <td>该事件在用户访问页面时触发</td>                </tr>                <tr>                    <td>onpagehide</td>                    <td>该事件在用户离开当前网页跳转到另外一个页面时触发</td>                </tr>                <tr>                    <td>onresize</td>                    <td>窗口或框架被重新调整大小。由windwo调用</td>                </tr>                <tr>                    <td>onscroll</td>                    <td>当文档被滚动时发生的事件。</td>                </tr>                <tr>                    <td>onunload</td>                    <td>用户退出页面。 ( &lt;body> 和 &lt;frameset>)</td>                </tr>            </table>            <p></p>            <h3 id="s2.4">2.4 表单事件</h3>            <p></p>            <table>                <tr>                    <td>属性</td>                    <td>描述</td>                </tr>                <tr>                    <td>onblur</td>                    <td>元素失去焦点时触发</td>                </tr>                <tr>                    <td>onchange</td>                    <td>该事件在表单元素的内容改变时触发( &lt;input>, &lt;keygen>, &lt;select>, 和 &lt;textarea>)</td>                </tr>                <tr>                    <td>onfocus</td>                    <td>元素获取焦点时触发</td>                </tr>                <tr>                    <td>onfocusin</td>                    <td>元素即将获取焦点时触发</td>                </tr>                <tr>                    <td>onfocusout</td>                    <td>元素即将失去焦点时触发</td>                </tr>                <tr>                    <td>oninput</td>                    <td>元素获取用户输入时触发</td>                </tr>                <tr>                    <td>onreset</td>                    <td>表单重置时触发</td>                </tr>                <tr>                    <td>onsearch</td>                    <td>用户向搜索域输入文本时触发 ( &lt;input="search">)</td>                </tr>                <tr>                    <td>onselect</td>                    <td>用户选取文本时触发 ( &lt;input> 和&lt;textarea>)</td>                </tr>                <tr>                    <td>onsubmit</td>                    <td>表单提交时触发</td>                </tr>            </table>            <p></p>            <h3 id="s2.5">2.5 剪贴板事件</h3>            <p></p>            <table>                <tr>                    <td>属性</td>                    <td>描述</td>                </tr>                <tr>                    <td>oncopy</td>                    <td>该事件在用户拷贝元素内容时触发</td>                </tr>                <tr>                    <td>oncut</td>                    <td>该事件在用户剪切元素内容时触发</td>                </tr>                <tr>                    <td>onpaste</td>                    <td>该事件在用户粘贴元素内容时触发</td>                </tr>            </table>            <p></p>            <h3 id="s2.6">2.6 打印事件</h3>            <p></p>            <table>                <tr>                    <td>属性</td>                    <td>描述</td>                </tr>                <tr>                    <td>onafterprint</td>                    <td>该事件在页面已经开始打印，或者打印窗口已经关闭时触发</td>                </tr>                <tr>                    <td>onbeforeprint</td>                    <td>该事件在页面即将开始打印时触发</td>                </tr>            </table>            <p></p>            <h3 id="s2.7">2.7 拖动事件</h3>            <p></p>            <table>                <tr>                    <td>属性</td>                    <td>描述</td>                </tr>                <tr>                    <td>ondrag</td>                    <td>该事件在元素正在拖动时触发</td>                </tr>                <tr>                    <td>ondragend</td>                    <td>该事件在用户完成元素的拖动时触发</td>                </tr>                <tr>                    <td>ondragenter</td>                    <td>该事件在拖动的元素进入放置目标时触发</td>                </tr>                <tr>                    <td>ondragleave</td>                    <td>该事件在拖动元素离开放置目标时触发</td>                </tr>                <tr>                    <td>ondragover</td>                    <td>该事件在拖动元素在放置目标上时触发</td>                </tr>                <tr>                    <td>ondragstart</td>                    <td>该事件在用户开始拖动元素时触发</td>                </tr>                <tr>                    <td>ondrop</td>                    <td>该事件在拖动元素放置在目标区域时触发</td>                </tr>            </table>            <p></p>            <h3 id="s2.8">2.8 多媒体事件</h3>            <p></p>            <table>                <tr>                    <td>属性</td>                    <td>描述</td>                </tr>                <tr>                    <td>onabort</td>                    <td>事件在视频/音频（audio/video）终止加载时触发。</td>                </tr>                <tr>                    <td>oncanplay</td>                    <td>事件在用户可以开始播放视频/音频（audio/video）时触发。</td>                </tr>                <tr>                    <td>oncanplaythrough</td>                    <td>事件在视频/音频（audio/video）可以正常播放且无需停顿和缓冲时触发。</td>                </tr>                <tr>                    <td>ondurationchange</td>                    <td>事件在视频/音频（audio/video）的时长发生变化时触发。</td>                </tr>                <tr>                    <td>onemptied</td>                    <td>当期播放列表为空时触发</td>                </tr>                <tr>                    <td>oonended</td>                    <td>事件在视频/音频（audio/video）播放结束时触发</td>                </tr>                <tr>                    <td>onerror</td>                    <td>事件在视频/音频（audio/video）数据加载期间发生错误时触发。</td>                </tr>                <tr>                    <td>onloadeddata</td>                    <td>事件在浏览器加载视频/音频（audio/video）当前帧时触发。</td>                </tr>                <tr>                    <td>onloadedmetadata</td>                    <td>事件在指定视频/音频（audio/video）的元数据加载后触发。</td>                </tr>                <tr>                    <td>onloadstart</td>                    <td>事件在浏览器开始寻找指定视频/音频（audio/video）触发。</td>                </tr>                <tr>                    <td>onpause</td>                    <td>事件在视频/音频（audio/video）暂停时触发</td>                </tr>                <tr>                    <td>onplay</td>                    <td>事件在视频/音频（audio/video）开始播放时触发</td>                </tr>                <tr>                    <td>onplaying</td>                    <td>事件在视频/音频（audio/video）暂停或者在缓冲后准备重新开始播放时触发。</td>                </tr>                <tr>                    <td>onprogress</td>                    <td>事件在浏览器下载指定的视频/音频（audio/video）时触发。</td>                </tr>                <tr>                    <td>onratechange</td>                    <td>事件在视频/音频（audio/video）的播放速度发送改变时触发。</td>                </tr>                <tr>                    <td>onseeked</td>                    <td>事件在用户重新定位视频/音频（audio/video）的播放位置后触发。</td>                </tr>                <tr>                    <td>onseeking</td>                    <td>事件在用户开始重新定位视频/音频（audio/video）时触发。</td>                </tr>                <tr>                    <td>onstalled</td>                    <td>事件在浏览器获取媒体数据，但媒体数据不可用时触发。</td>                </tr>                <tr>                    <td>onsuspend</td>                    <td>事件在浏览器读取媒体数据中止时触发。</td>                </tr>                <tr>                    <td>ontimeupdate</td>                    <td>事件在当前的播放位置发送改变时触发。</td>                </tr>                <tr>                    <td>onvolumechange</td>                    <td>事件在音量发生改变时触发。</td>                </tr>                <tr>                    <td>onwaiting</td>                    <td>事件在视频由于要播放下一帧而需要缓冲时触发</td>                </tr>            </table>            <p></p>            <h3 id="s2.9">2.9 动画事件</h3>            <p></p>            <table>                <tr>                    <td>事件</td>                    <td>描述</td>                </tr>                <tr>                    <td>animationend</td>                    <td>该事件在 CSS 动画结束播放时触发</td>                </tr>                <tr>                    <td>animationiteration</td>                    <td>该事件在 CSS 动画重复播放时触发</td>                </tr>                <tr>                    <td>animationstart</td>                    <td>该事件在 CSS 动画开始播放时触发</td>                </tr>            </table>            <p></p>            <h3 id="s2.10">2.10 过渡事件</h3>            <p></p>            <table>                <tr>                    <td>事件</td>                    <td>描述</td>                </tr>                <tr>                    <td>transitionend</td>                    <td>该事件在 CSS 完成过渡后触发</td>                </tr>            </table>            <p></p>            <h3 id="s2.11">2.11 其他事件</h3>            <p></p>            <table>                <tr>                    <td>事件</td>                    <td>描述</td>                </tr>                <tr>                    <td>onmessage</td>                    <td>该事件通过或者从对象(WebSocket, Web Worker, Event Source 或者子 frame 或父窗口)接收到消息时触发</td>                </tr>                <tr>                    <td>onmousewheel</td>                    <td>已废弃。 使用 onwheel事件替代</td>                </tr>                <tr>                    <td>ononline</td>                    <td>该事件在浏览器开始在线工作时触发。</td>                </tr>                <tr>                    <td>onoffline</td>                    <td>该事件在浏览器开始离线工作时触发。</td>                </tr>                <tr>                    <td>onpopstate</td>                    <td>该事件在窗口的浏览历史（history 对象）发生改变时触发。</td>                </tr>                <tr>                    <td>onshow</td>                    <td>该事件当 &lt;menu> 元素在上下文菜单显示时触发</td>                </tr>                <tr>                    <td>onstorage</td>                    <td>该事件在 Web Storage(HTML 5 Web 存储)更新时触发</td>                </tr>                <tr>                    <td>ontoggle</td>                    <td>该事件在用户打开或关闭&lt;details> 元素时触发</td>                </tr>                <tr>                    <td>onwheel</td>                    <td>该事件在鼠标滚轮在元素上下滚动时触发</td>                </tr>                <tr>                    <td>DOMMouseScroll</td>                    <td>火狐(firefox)支持的绑定鼠标滚轮的事件，并且该事件必须要通过addEventListener()函数来绑定事件</td>                </tr>                <tr>                    <td>DOMContentLoaded</td>                    <td>监听文档DOM元素的内容是否加载完成，比onload事件要监听的东西更少，DOM元素加载完毕后就会执行该事件,通过addEventListener()函数来绑定事件</td>                </tr>            </table>            <p></p>            <div>            </div>        </div>        <div class="list" id="s3">            <h2>3.DOM查询</h2>            <p></p>            <h3 id="s3.1">3.1 获取DOM节点</h3>            <p></p>            <h4 id="s3.1.1">3.1.1 获取元素节点</h4>            <p></p>            <ul>                <li>getElementById()通过ID获取元素节点,返回一个普通对象<br/>注意:ID其实可以不用获取而直接使用,因为ID是具有唯一性的,但是不推荐不获取就直接使用ID，因为以后会很难区分这个变量是哪里来的</li>                <li>getElementsByTagName()方法通过标签名获取元素节点,返回一个类数组对象</li>                <li>getElementsByClassName()方法通过类名获取元素节点(IE8及以下版本不支持),返回一个类数组对象</li>                <li>getElementsByName()方法通过name属性获取元素节点,这个方法主要是获取表单项,返回一个类数组对象</li>                <li>quertSelector()方法需要一个选择器的字符串作为参数,可以根据一个CSS选择器来查询一个元素节点对象，语法和CSS语法一样，可以多个选择器一起使用,该方法在IE8也可用<br/>注意:使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，也只会返回第一个找到的</li>                <li>quertSelectorAll()方法用法同quertSelector()方法相同<br/>注意:使用该方法就返回一个类数组对象，类数组对象里包含的所有符号要求的元素对象,即使符合条件的元素只有一个，也会返回类数组</li>            </ul>            <p></p>            <p>注意:queryslector()和quertSlectorAll()方法尽量少用,这两种对元素节点的查找效率很低</p>            <p></p>            <p>静态获取与动态获取元素节点</p>            <p></p>            <ul>                <li>通过ID查找元素节点和以query开头的查找的元素节点是静态获取元素节点,这时无论元素怎么改变已经获取的元素节点所赋值后的变量永远指向该被查找到的元素节点                    <div class="codeMirror">                        <pre><code>var box=document.getElementById("box");    box.onclick=function()&#123;    box.id="wrap";    console.log(box);//还是能获取到&#125;</code></pre>                    </div>                    <p></p>                    <div class="codeMirror">                        <pre><code>var box=document.querySelectorAll(".box");//假设有5个box    document.onclick=function()&#123;    document.body.innerHTML+="<div class='box'></div>";    console.log(box);//还是5个box&#125;</code></pre>                    </div>                </li>                <li>通过集合进行获取元素节点的方式为动态获取,这时每次使用集合都会获取集合的最新状态,此时通过集合赋值的变量的值也会发生相应变化                    <div class="codeMirror">                        <pre><code>var box=document.getElementByClassName("box");//假设有5个boxdocument.onclick=function()&#123;    document.body.innerHTML+="<div class='box'></div>";    console.log(box);//6个box&#125;</code></pre>                    </div>                </li>                <p></p>                <p>注意:如果选中了集合中的单个元素,这时获取的元素节点是静态获取</p>            </ul>            <p></p>            <h4 id="s3.1.2">3.1.2 获取属性节点</h4>            <p></p>            <ul>                <li>读取元素的属性节点,使用 元素.属性名 或 元素[属性名]</li>                <li>修改元素的属性节点,使用 元素.属性名=新值 或 元素[属性名]=新值</li>            </ul>            <p></p>            <p>注意:读取元素的class属性时必须用className来代替class关键字</p>            <p></p>            <p>获取,设立和删除标签属性节点</p>            <p></p>            <p>如果JS中的自定义属性与标签属性重复时,直接获取会得到自定义属性的值,所以需要特定的值获取标签属性的方法</p>            <p></p>            <ul>                <li>通过getAttribute()方法获取标签属性节点                    <div class="codeMirror">                        <pre><code>var box=document.getElementById("box");console.log(box.getAttribute("id"));//box</code></pre>                    </div>                </li>                <li>通过setAttribute()方法设立或改变一个标签属性节点                    <div class="codeMirror">                        <pre><code>var box=document.getElementById("box");box.setAttribute("class","nameBox");console.log(box);//如果已有该属性会是重新赋值</code></pre>                    </div>                </li>                <li>通过removeAttribute()方法删除一个标签属性节点                    <div class="codeMirror">                        <pre><code>var box=document.getElementById("box");box.removeAttribute("id");console.log(box);</code></pre>                    </div>                </li>            </ul>            <p></p>            <h4 id="s3.1.3">3.1.3 获取文本节点</h4>            <p></p>            <ul>                <li>innerHTML属性可以获取双标签元素内部的html代码，包括子标签,这个属性对于单标签元素(如表单标签)没有意义,返回一个字符串</li>                <li>InnerText属性可以获取双标签元素内部的文本内容，它和InnerHTML属性类似，但会自动将HTML标签去除,返回一个字符串</li>                <li>value属性可以获取单标签元素(如表单标签)内部的内容,同时要向单标签元素写入内容也必须使用value属性,返回一个字符串</li>                <li>nodeValue属性通过获取标签内的文本节点的内容来获取元素内部的文本内容(因为文本节点实际是一个标签的子节点,所以需要先找到文本节点),返回一个字符串</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><code>&lt;!DOCTYPE html>&lt;html lang="en">&lt;head>&lt;meta charset="UTF-8" />&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" />&lt;meta http-equiv="X-UA-Compatible" content="ie=edge" />&lt;title>Document&lt;/title>&lt;/head>    &lt;div>123&lt;/div>    &lt;body>    &lt;script>      let div = document.getElementsByTagName("div")[0];      console.log(div.firstChild.nodeValue);//123        console.log(div.nodeValue);//null    &lt;/script>&lt;/body>&lt;/html></code></pre>            </div>            <p></p>            <h4 id="s3.1.4">3.1.4 获取元素子节点</h4>            <p></p>            <p>元素子节点的有同父节点一样获取子节点的方法或属性</p>            <p></p>            <ul>                <li>childNodes属性获取元素子节点，该属性会获取包括文本节点的所有子节点，返回一个类数组对象</li>                <li>children属性可以获取当前元素的所有子元素，推荐用这个属性，返回一个类数组对象,而且是动态获取</li>                <li>firstChild属性表示当前节点的第一个子节点，也包括空白文本，返回一个普通对象</li>                <li>firstElementChld属性获取第一个子元素，返回一个普通对象，但是不兼容IE8，不推荐使用兼容代码</li>                <div class="codeMirror">                    <pre><code>//获取任意一个父级元素的第一个子级元素function getFirstElementChild(element)&#123;    if(element.firstElementChild)&#123;        return element.firstElementChild;    &#125;else&#123;        let node=element.firstChild;//第一个节点        while(node&&node.nodeType!==1)&#123;//判断是否为元素节点            node=node.nextSibling;        &#125;    &#125;&#125;</code></pre>                </div>                <li>lastChild属性表示当前节点的最后一个子节点，也包括空白文本，返回一个普通对象</li>                <li>lastElementChld属性获取最后一个子元素，返回一个普通对象，但是不兼容IE8，不推荐使用</li>                <li>childElementCount属性元素子节点个数,不兼容IE8</li>            </ul>            <p></p>            <h4 id="s3.1.5">3.1.5 获取父和兄弟节点</h4>            <p></p>            <ul>                <li>parentElement属性获取当前节点的父元素(只在IE中可用)</li>                <li>parentNode属性获取当前节点的父节点,这是W3C标准的,推荐使用</li>                <li>offsetParent属性获取到离当前元素最近的开启了定位(除去默认的static)的祖先元素，如果所以的祖先元素都没有开启定位，则会返回body</li>                <li>previousSibling属性获取当前节点的前一个兄弟节点<br/>注意:可能获取空白文本，如果两个元素中间有空白就会获取空白</li>                <li>previosElementSibling属性获取前一个元素，IE8不支持</li>                <li>nextSibiling属性表示当前节点的后一个兄弟节点</li>                <li>nextElementSibling获取后一个元素，IE8不支持</li>            </ul>            <p></p>            <h4 id="s3.1.6">3.1.6 获取特殊元素节点</h4>            <ul>                <li>在document元素中有一个body属性,它保存的是对body元素的引用                    <div class="codeMirror">                        <pre><code>var body=document.body</code></pre>                    </div>                </li>                <li>在document元素中有一个documentElement属性,它保存html标签的引用                    <div class="codeMirror">                        <pre><code>var html=document.documentElement</code></pre>                    </div>                </li>                <li>在document元素中有一个all属性,该属性代表页面中所有元素(不建议使用)                    <div class="codeMirror">                        <pre><code>var all=document.all;//它的值是undefined,但是却有长度数组的特性</code></pre>                    </div>                </li>            </ul>            <p></p>            <p>表格的简便操作</p>            <p></p>            <ul>                <li>getElementsByTagName("tbody")[0]与tBodies[0]相同</li>                <li>getElementsByTagName("thead")[0]与tHead相同</li>                <li>getElementsByTagName("tfoot")[0]与tFoot相同</li>                <li>getElementsByTagName("tr")[0]与rows[0]相同</li>                <li>getElementsByTagName("td")[0]与cells[0]相同</li>            </ul>            <p></p>            <h3 id="s3.2">3.2 创建或添加元素节点</h3>            <p></p>            <ul>                <li>createElement()方法可以创建一个元素节点对象，它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回<br/>注意:该方法由document使用                    <div class="codeMirror">                        <pre><code>var oDiv=document.createElement("div");</code></pre>                    </div>                </li>                <li>createTextNote()方法可以创建一个文本节点对象，需要一个文本内容作为参数，将会根据该内容创建文本节点，并将新节点返回<br/>注意:该方法由document创建                    <div class="codeMirror">                        <pre><code>var oTxt=document.createTextNote("123");</code></pre>                    </div>                </li>                <li>createElementFragment()方法创建一个文档片段,可以向这个文档片段中添加一个个节点,然后直接将该文档片段加到要添加到的父元素中,该方法可以实现同时给页面加多个节点而只用渲染一次页面,所以如果要添加多个同级节点时最好使用这个来添加<br/>注意:放入文档片段的节点一定要是同级的片段                    <div class="codeMirror">                        <pre><code>var box=document.createDocumentFragment();box.appendChild(p1);//创建的p元素节点box.appendChild(p2);document.body.appendChild(box);</code></pre>                    </div>                </li>                <li>cloneNode()方法可以传入一个参数，克隆一个DOM节点，如果传入true则是把元素中的所有内容也一起克隆，如果传入的是false则会只克隆这一个DOM节点，不会将里面的内容也克隆(不传入参数默认为flase)                    <div class="codeMirror">                        <pre><code>&lt;!DOCTYPE html>&lt;html lang="en">    &lt;head>        &lt;meta charset="UTF-8" />        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" />        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" />        &lt;title>Document</title>    &lt;/head>    &lt;div>123&lt;/div>    &lt;body>        &lt;script>              let Odiv = document.getElementsByTagName("div")[0];              let cloneDiv = Odiv.cloneNode(false);               let cloneDiv2= Odiv.cloneNode(true);              console.log(cloneDiv);//<div></div>            console.log(cloneDiv);//<div>123</div>        &lt;/script>    &lt;/body>&lt;/html></code></pre>                    </div>                </li>                <li>appendChild()向父节点中添加一个新的子节点，可以逐层添加子节点<br/>注意:                    <ul>                        <li>该方法由父节点调用</li>                        <li>要添加子节点之前必须要先有这个子节点，没有就要先创建，并且新加的子节点会自动添加到所有子节点的最后面                            <div class="codeMirror">                                <pre><code>var parent=document.getElementById("parent");var child=document.createElement("div");parent.appendChild(child);</code></pre>                            </div>                        </li>                        <li>如果子节点不是新创建而是从原有父级节点上调用的,那么在用appenChild()方法时会先将原有父级节点上的该子节点删除                        </li>                    </ul>                </li>                <div class="codeMirror">                    <pre><code>&lt;!DOCTYPE html>&lt;html lang="en">    &lt;head>    &lt;meta charset="UTF-8" />    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" />    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" />    &lt;title>Document&lt;/title>    &lt;/head>&lt;body>    &lt;table>    &lt;tbody>        &lt;tr>        &lt;td>3&lt;/td>        &lt;/tr>        &lt;tr>            &lt;td>1&lt;/td>        &lt;/tr>        &lt;tr>             &lt;td>2&lt;/td>        &lt;/tr>        &lt;/tbody>    &lt;/table>        &lt;script>          var arr = [];          var oTab = document.getElementsByTagName("table")[0];              oTab.onclick = function() &#123;            for (var i = 0; i < oTab.tBodies[0].rows.length; i++) &#123;              arr[i] = oTab.tBodies[0].rows[i];            &#125;            //arr = [...oTab.tBodies[0].rows];简写模式                          arr.sort(function(tr1, tr2) &#123;              var n1 = parseInt(tr1.cells[0].innerHTML);              var n2 = parseInt(tr2.cells[0].innerHTML);              return n1 - n2;            &#125;);                for (var i = 0; i < arr.length; i++) &#123;              oTab.tBodies[0].appendChild(arr[i]);//排序之后页面的结果为1 2 3            &#125;          &#125;;    &lt;/script>&lt;/body>&lt;/html></code></pre>                </div>                <li>insertBefore()方法在指定的子节点前面插入子节点<br/>注意:                    <ul>                        <li>该方法由父节点调用,传入两个参数(新节点和旧节点),第一个参数必填,第二个参数可选</li>                        <li>要添加子节点之前必须要先有这个子节点，没有就要先创建，并且如果没有传入第二个参数会自动添加到所有子节点的最后面</li>                        <li>如果子节点不是新创建而是从原有父级节点上调用的,那么在用insertBefore()方法时会先将原有父级节点上的该子节点删除</li>                    </ul>                    <div class="codeMirror">                        <pre><code>var parent=document.getElementById("parent");var child=document.createElement("div");parent.insertBefore(child,parent.childNotes[0]);//将新创建的元素插入的父元素内容最前面</code></pre>                    </div>                </li>                <li>使用innerHTML属性也可以完成DOM的增删改等操作,可以给innerHTML属性赋值带有HTML标签的字符串实现操作,一般我们会将DOM查询和innerHTML属性两种方法同时使用                    <div class="codeMirror">                        <pre><code>var parent=document.getElementById("parent"); var child=document.createElement("div");child.innerHTML="123"；parent.appendChild(child);</code></pre>                    </div>                </li>            </ul>            <p></p>            <h3 id="s3.3">3.3 替换或删除元素节点</h3>            <p></p>            <ul>                <li>replaceChild()方法可以使用指定的子节点替换已有的子节点<br/>注意:                    <ul>                        <li>该方法由父节点调用</li>                        <li>要替换子节点之前必须要先有这个新的子节点，没有就要先创建</li>                        <li>如果子节点不是新创建而是从原有父级节点上调用的,那么在用replace()方法时会先将原有父级节点上的该子节点删除</li>                    </ul>                    <div class="codeMirror">                        <pre><code>var parent=document.getElementById("parent");var child=var child=document.createElement("div");parent.replaceChild(child,parent.children[0]);//替换父元素的第一个子元素</code></pre>                    </div>                </li>                <li>removeChild()方法可以用作删除一个子节点<br/>注意:该方法由父节点调用                    <div class="codeMirror">                        <pre><code>var parent=document.getElementById("parent");parent.removeChild(parent.children[0]);//删除父元素的第一个子元素</code></pre>                    </div>                </li>            </ul>            <p></p>            <p>注:上述的DOM查询方法可以混合搭配使用</p>            <p></p>            <p>如:在不知道一个子节点的父节点的情况下删除该子节点</p>            <p></p>            <p>通过 子节点.parentNode.removeChild(子节点) 的方法就可以删除</p>            <p></p>            <h3 id="s3.4">3.4 遍历DOM元素</h3>            <p></p>            <p></p>            <div class="codeMirror">                <pre><code>/*第一个函数:功能函数,用来打印节点名称第二个函数:给根节点，找到所有子节点第三个函数:给子节点，把每个节点的名字显示出来*/function f1(node)&#123;    console.log("节点的名字:"+node.nodeName);&#125;function forDOM(root)&#123;    //调用f1,显示节点的名字    f1(root);    //获取根节点中所有的子节点    var children=root.children;    //调用遍历所有子节点的函数    forChildren(children);&#125;//给该函数一个子节点,显示所有该子节点的子节点function forChildren(children)&#123;    //遍历所有的子节点    for(var i=0;i&lt;children.length;i++)&#123;        //每个子节点        var child=children[i];        //显示每个子节点的名字        f1(child);        //判断child下面是否还有子节点,如果有继续遍历        child.children&&forDOM(child);    &#125;&#125;</code></pre>            </div>        </div>        <p></p>        <div class="list" id="s4">            <h2>4.元素样式</h2>            <p></p>            <h3 id="s4.1">4.1 修改元素CSS样式</h3>            <p></p>            <h4 id="s4.1.1">4.1.1 通过style属性修改元素样式</h4>            <p></p>            <p>注意:</p>            <p></p>            <ul>                <li>如果CSS的样式名中含有-(也就是减号)，这种名称在JS中是不合法的，比如background-color,需要将这种样式名修改为驼峰命名法，去掉-，然后将-后的字母大写，如:background-color写作backgroumdColor，border-top-width写作borderTopWidth</li>                <li>因为float样式是JS中的保留字,所有在修改元素浮动属性的时候不能够直接写作 元素.style.float="样式值" 的形式,需要用styleFloat(兼容IE6~8)或cssFloat(IE9以上使用)来代替使用</li>                <li>通过style属性设置的样式都是内联样式，而内联样式有较高的优先级，所以通过JS修改的样式往往会立即重置，但是如果在样式中用了!important则样式会拥有最高优先级，导致JS修改样式失效，所以尽量不要使用important</li>                <li>通过JS的style属性设置和读取的都是内联样式，无法读取CSS样式表中的样式(外部样式和嵌套样式)</li>            </ul>            <p></p>            <p>简写方式</p>            <p></p>            <p>通过 元素.style.cssText="样式值" 的方式可以将多个CSS属性同时写入,右边的值的写法和内联的CSS样式一样的,并不用遵循驼峰命名法,也不用在意JS的保留字问题</p>            <p></p>            <p></p>            <h4 id="s4.1.2">4.1.2 通过类修改元素样式</h4>            <p></p>            <p>通过修改类(class)来修改CSS样式</p>            <p></p>            <ul>                <li>修改className属性<br/>通过修改元素的className属性(在JS中的class是保留字,所以用className来代替)来间接修改样式，这样一来，只需要修改一次，即可同时修改多个样式，浏览器只需要重新渲染页面一次，性能比较好<br/>用className属性添加一个类<br/>元素.className+=" 类名"，记得在类名前面加上空格</li>                <li>通过classList属性<br/>每个标签元素都有classList属性,这个属性和当中的一些方法可以让我们修改类时更加简便                    <ul>                        <li>classList属性返回元素的类名,该属性只读,只能通过该属性的一些方法来修改元素的类</li>                        <li>classList属性有length属性,该属性返回元素类的属性,并且该属性只读</li>                        <li>classList属性的方法</li>                    </ul>                </li>                <p></p>                <table>                    <tr>                        <td>方法</td>                        <td>描述</td>                    </tr>                    <tr>                        <td>add(class1, class2, ...)</td>                        <td>在元素中添加一个或多个类名。 如果指定的类名已存在，则不会添加</td>                    </tr>                    <tr>                        <td>contains(class)</td>                        <td>返回布尔值，判断指定的类名是否存在。可能值：true - 元素包已经包含了该类名false - 元素中不存在该类名</td>                    </tr>                    <tr>                        <td>item(index)</td>                        <td>返回元素中索引值对应的类名。索引值从 0 开始。 如果索引值在区间范围外则返回 null</td>                    </tr>                    <tr>                        <td>remove(class1, class2, ...)</td>                        <td>移除元素中一个或多个类名。注意: 移除不存在的类名，不会报错。</td>                    </tr>                    <tr>                        <td>toggle(class, true|false)</td>                        <td>在元素中切换类名。 第一个参数为要在元素中移除的类名，并返回 false。 如果该类名不存在则会在元素中添加类名，并返回 true。 第二个是可选参数，是个布尔值用于设置元素是否强制添加或移除类，不管该类名是否存在。也就是说如果写了第二个参数那么该方法就变成了add()或remover()方法</td>                    </tr>                </table>            </ul>            <p></p>            <h3 id="s4.2">4.2 获取元素样式</h3>            <p></p>            <h4 id="s4.2.1">4.2.1 通用样式</h4>            <p></p>            <ul>                <li>在IE了浏览器中通过currentStyle属性来获取当前元素正在显示的样式,如果获取的是没有设置的样式,就会返回该样式的默认值,并且如果默认是以px为单位来返回的<br/>如:没有设置width就会返回默认值auto<br/>语法:元素.currentStyle.样式名</li>                <li>在其他浏览器可以使用getComputedStyle()方法来获取元素样式(IE8以下不支持,)这个方法是window的方法，可以直接进行调用<br/>该方法有两个参数，第一个参数传入一个元素,第二个参数传入一个伪类,第二个参数可选,当不查询伪类元素的时候可以忽略或者传入null。该方法会返回一个对象，对象中封装了当前元素对应的样式，可以通过样式名来读取样式，如果获取的样式没有设置，与currentStyle属性不同,会获取真实的值，而不是默认值，同时值也是默认以px为单位来返回的<br/>如:没有设置width,不会返回auto,而是返回一个长度</li>                <div class="codeMirror">                    <pre><code>var div=document.getElementById("box");var obj=getComputedStyle(Odiv,null);    console.log(obj.width);console.log(getComputedStyle(box1,null).width);//也可以直接输出</code></pre>                </div>            </ul>            <p></p>            <p>注意:通过currentStyle属性和getComputedStyle()方法读取到的样式都是只读的，不能修改，如果要修改必须通过style属性</p>            <p></p>            <p>兼容写法</p>            <p></p>            <div class="codeMirror">                <pre><code>/*    参数:obj 要获取样式的元素    name 要获取的样式名*/function getStyle(obj,name)&#123;    if(window.getComputedStyle)&#123; //因为getComputedStyle函数实质上是一个对象，所以如果有就返回true,这里必须要用window，因为这是要在全局范围类寻找，但是IE8全局里没有这个变量，肯定会报错，必须加上window，如果没有这个window里的属性就会返回undefined    return getComputedStyle(obj，null)[name]//因为是变量必须使用[]的方法       &#125;else&#123;    return obj.currentStyle[name]    &#125;//当然if的对象也可以反过来，但是如果判断obj.currentStyle有问题在于IE8以上的IE浏览器两种方法都有，这样它就会优先使用第一个方法，但是我们推荐优先使用getComputedStyle()&#125;</code></pre>            </div>            <p></p>            <h4 id="s4.2.2">4.2.2 获取特殊样式</h4>            <p></p>            <p>注:以下获取的样式都是只读的,不能够修改</p>            <p></p>            <p>属性</p>            <p></p>            <ul>                <li>clientWidth和clientHeight属性获取元素的可见宽度和高度(内容区和内边距)，这些属性都是返回纯数值，不带单位,可以直接进行计算</li>                <li>offsetWidth和offsetHeight属性获取元素的整个宽度和高度(内容区，内边距和边框),返回值也是纯数值</li>                <li>offsetLeft和offsetTop属性获取当前元素相对于其定位父元素的水平偏移量和垂直偏移量<br/>注意:偏移量的原点是父元素的左上角(left top),和背景图片的原点相同</li>                <li>window.innerWidth和window.innerHeight属性可以获取window窗口的内部宽高<br/>注意:不包括页面的导航栏以及页面滚动条和控制台                    <div class="codeMirror">                        <pre><code>console.log(window.innerHeigth);console.log(window.innerWidth);</code></pre>                    </div>                </li>                <li>document.documentElement.clientWidth和document.documentElement.clientWidth属性获取文档可视区域,该属性的值虽然与window,innerWidth和window.innerHeight的值相同,但是对象的调用者不同,内部的含义也不同                    <div class="codeMirror">                        <pre><code>console.log(document.documentElement.clientHeith);console.log(document.documentElement.clientWidth);</code></pre>                    </div>                </li>                <li>scrollWidth和scrollHeight属性可以获取元素整个滚动区域的宽度和高度,如果没有隐藏的部分则等于clientWidth和clientHeight</li>                <li>scrollLeft和scrollTop属性可以获取水平和垂直滚动条滚动的距离<br/>浏览器滚动条问题<br/>chrome认为浏览器的滚动条是body元素的，可以通过body.scrollTopl来获取，而火狐和IE浏览器认为浏览器的滚动条是html元素的，所以在用到浏览器滚动条的时候就会出现兼容问题(现在的chrome版本已经和火狐与IE统一都是通过html元素获取了,通过body获取反而值为0)</li>                <p>兼容代码</p>                <div class="codeMirror">                    <pre><code>var st=document.body.scrollTop||document.documentElement.scrollTop;var sl=document.body.scrollLeft||document.documentElement.scrollLeft;//该兼容代码可以在计算页面的滚动条距离的时候使用</code></pre>                </div>            </ul>            <p></p>            <p>注:当满足scrollHeight-ScrollTop===clientHeight 这个表示式时说明垂直滚动条到底了，同理水平滚动条也一样</p>            <p></p>            <p>自制滚动条</p>            <p></p>            <div class="codeMirror">                <pre><code>/*    一个最大的容器box,一个装滚动条的div容器,一个滚动条div,一个文字div    滚动条的高/装滚动条div的高=box的高/文字的高-->滚动条的高=装滚动条div的高*box的高/文字div的高*/    //bar为滚动条,scroll为包裹滚动条的层，content为装文字的盒子    var box=document.getElementById("box");    var scroll=document.getElementById("scroll");    var content=document.getElementById("content");    var bar=document.getElementById("bar");        var height=scroll.offsetHeight*box.offsetHeight/content.offsetHeight;    bar.style.height=height+"px";//移动滚动条    bar.onmousedowm=function(e)&#123;        //鼠标在滚动条上的位置        var spaceY=e.clientY-bar.offsetTop;        document.onmousemove=function(e)&#123;            //滚动条纵坐标            var y=e.clientY-spaceY;            y=y<0?0:y;//最小值            y=y>(scroll.offsetHeight-bar.offsetHeight)?(scroll.offsetHeight-bar.offsetHeight):y;            bar.style.top=y+"px";            //设置鼠标移动时文字不被选中            window.getSelection?window.getSelection().removeAllRanges():document.selection.empty();                        //文字div的移动距离=滚动条的移动距离*文字div的最大移动距离/滚动条的最大移动距离            //文字的最大移动距离是content盒子的高度减去最外层盒子的高度            var moveY=y*(content.offsetHeight-box.offsetHeight)/(scroll.offsetHeight-bar.offsetHeight);            content.style.marginTop=-moveY+"px";        &#125;    &#125;    document.onmouseup=function()&#123;        //鼠标抬起将鼠标移动事件去除        document.onmousemove=null;&#125;</code></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><code>&lt;!--下面滚动条的方法与上方没有太大联系-->&lt;!DOCTYPE html>&lt;html lang="en">&lt;head>&lt;meta charset="UTF-8" />&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" />&lt;meta http-equiv="X-UA-Compatible" content="ie=edge" />&lt;title>滚动条&lt;/title>    &lt;style>      * &#123;        margin: 0;        padding: 0;      &#125;      #box &#123;        position: relative;        overflow: hidden;        margin: 50px auto;        width: 500px;        height: 600px;        background-color: rgb(231, 223, 223);        border-radius: 5px;      &#125;      #content &#123;        position: absolute;        float: left;        width: 480px;      &#125;      #content > div &#123;        text-indent: 2em;      &#125;      #bar-container &#123;        position: relative;        float: right;        height: 100%;        width: 20px;        background-color: #ccc;        border-radius: 5px;        cursor: pointer;      &#125;      #bar &#123;        position: absolute;        top: 0;        left: 0;        width: 20px;        height: 40px;        background-color: pink;        border-radius: 5px;        cursor: pointer;      &#125;    &lt;/style>    &lt;script src="js/animation.js">&lt;/script><!--装有运动函数-->    &lt;/head>    &lt;body>    &lt;div id="box">    &lt;div id="content">        code....        &lt;/div>        &lt;div id="bar-container">        &lt;div id="bar">&lt;/div>        &lt;/div>    &lt;/div>    &lt;script>      ///最大的包裹盒子      let box = document.getElementById("box");      //包裹文档的盒子      let content = document.getElementById("content");      //装滚动条的盒子      let barContainer = document.getElementById("bar-container");      //滚动条      let bar = document.getElementById("bar");      //计算滚动条的大小      let barHeight =        Math.min(box.offsetHeight / content.offsetHeight, 1) *        barContainer.offsetHeight;      bar.style.height = barHeight + "px";      //滚动条最大滚动距离      let maxScroll = barContainer.offsetHeight - bar.offsetHeight;      //内容能滑动的最大距离      let maxContent = content.offsetHeight - box.offsetHeight;      //滑动时距顶部的距离      let Top = 0;      //判断内容长度绑定事件      if (bar.offsetHeight / content.offsetHeight < 1) &#123;        mousewheel(box, function(event) &#123;          event = event || window.event;          if (event.wheelDetail > 0) &#123;            //每次滑动的像素            Top -= 10;          &#125; else &#123;            Top += 10;          &#125;          Top = Math.max(0, Top);          Top = Math.min(maxScroll, Top);          bar.style.top = Top + "px";          //文字内容滑动比例          content.style.top = -(Top / maxScroll) * maxContent + "px";        &#125;);      &#125; else &#123;        barContainer.style.display = "none";        content.style.width = "100%";      &#125;      barContainer.onclick = function(event) &#123;        Top = event.pageY - getDistance(this).top - bar.offsetHeight / 2;        //上面也可以用event.clientY-this.getBoundingClientRect().top-bar.offsetHeight / 2        Top = Math.max(0, Top);        Top = Math.min(maxScroll, Top);        if (event.target === this) &#123;          animation(//运动函数            bar,            &#123;              data: &#123;                top: Top              &#125;            &#125;,            500          );          animation(            content,            &#123;              data: &#123;                top: -(Top / maxScroll) * maxContent              &#125;            &#125;,            500          );        &#125;      &#125;;      bar.onmousedown = function(event) &#123;        event = event || window.event;        //开始时的鼠标坐标和滚动条的距离        let startY = event.clientY;        let startTop = bar.offsetTop;        //清除阻止冒泡        event.stopPropagation();        document.onmousemove = function(event) &#123;          event = event || window.event;          //拖动时的鼠标坐标和滚动距离          let nowY = event.clientY;          Top = startTop + nowY - startY;          Top = Math.max(0, Top);          Top = Math.min(maxScroll, Top);          bar.style.top = Top + "px";          //文字内容滑动比例          content.style.top = -(Top / maxScroll) * maxContent + "px";          event.preventDefault();        &#125;;        document.onmouseup = function() &#123;          this.onmousemove = null;          this.onmouseup = null;        &#125;;      &#125;;      function mousewheel(dom, callback, bool) &#123;        //bool为传入的一个布尔值,如果是true则阻止默认行为,默认是不阻止        var type = "mousewheel";        if (dom.onmousewheel === undefined) &#123;          //不能通过判断下面的那个,因为在火狐中dom属性也没有这个属性          type = "DOMMouseScroll";        &#125;        //真正的事件函数        function cb(event) &#123;          /*            自定义属性event.wheelDtail控制鼠标滚轮,所以在外部使用时应该用event.wheelDetail          */          /*外部可以传入event作为事件对象也可以不传入直接使用,也不需要进行兼容,          但是不传入时应该用event          */          event = event || window.event;          //把滚动事件的方向处理一致          event.wheelDetail = event.wheelDelta / 123 || event.detail / -3;          //每次滚动的值为1,并且向上滚动为正值,向下滚动为负值          //阻止默认行为          if (!!bool) &#123;            if (event.preventDefault) &#123;              event.preventDefault();            &#125; else &#123;              event.returnValue = flase;            &#125;          &#125;          callback.call(this, event);        &#125;        if (dom.addEventListener) &#123;          dom.addEventListener(type, cb);        &#125; else &#123;          dom, attachEvent("on" + type, cb);        &#125;      &#125;      //获取当前定位元素距离body顶部的距离      function getDistance(dom) &#123;        let obj = &#123;          top: 0,          left: 0        &#125;;        while (dom != document.body) &#123;          obj.top = dom.offsetTop;          obj.left = dom.offsetLeft;          dom = dom.offsetParent;        &#125;        return obj;      &#125;      &lt;/script>&lt;/body>&lt;/html></code></pre>            </div>            <p></p>            <p>方法</p>            <p></p>            <ul>                <li>getBoundingClientRect()方法获取元素节点对象到窗口的左上角(恒定为刚打开页面时的左上角为原点)的距离值以及自身的长宽等属性,该方法不用传入参数</li>                <li>scrollIntoView()方法让滚动条滚动到调用对象的可视区,一旦执行此方法调用此方法的页面就会滚动到该元素节点的位置,此方法不用传入参数</li>            </ul>        </div>        <div class="list" id="s5">            <h2 id="s5">5.事件对象</h2>            <p></p>            <p>当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为默认实参(如果没有传入参数位置为arguments[0])传递进响应函数，在事件对象中封装了当前事件相关的一些信息，比如:鼠标的坐标，键盘哪个按键被按下 ，鼠标滚轮滚动的方向</p>            <p></p>            <p></p>            <p>注:</p>            <p></p>            <ul>                <li>一般都会把形参写在事件对象的形参里,虽然不写也不会报错,但是获取方式会相对麻烦</li>                <li>在IE中,event事件对象通过window.event来获取，在其他浏览器中是作为参数传入使用</li>                <div class="codeMirror">                    <pre><code>//写实参调用event    function eventTest(event)&#123;        event=event||window.event;    &#125;        //不写实参调用event    function eventTest()&#123;        var event = window.event||arguments[0];    &#125;        //传入额外实参    function eventTest(a,b)&#123;        var event = window.event || arguments.callee.caller.arguments[0];    &#125;        //如果传入了参数却如第二种写法的话，则arguments中将会传入已经传入的参数，    这时获取的arguments[0]就会是第一个传入的参数</code></pre>                </div>                <p></p>                <div class="codeMirror">                    <pre><code>//target为该调用对象target = event.srcElement||event.target//低版本IE用srcElement</code></pre>                </div>            </ul>            <p></p>            <h3 id="s5.1">5.1 基本事件对象</h3>            <p></p>            <ul>                <li>常量                    <p></p>                    <table>                        <tr>                            <td>静态变量</td>                            <td>描述</td>                        </tr>                        <tr>                            <td>CAPTURING-PHASE</td>                            <td>当前事件阶段为捕获阶段(1)</td>                        </tr>                        <tr>                            <td>AT-TARGET</td>                            <td>当前事件是目标阶段,在评估目标事件(1)</td>                        </tr>                        <tr>                            <td>BUBBLING-PHASE</td>                            <td>当前的事件为冒泡阶段 (3)</td>                        </tr>                    </table>                </li>                <p></p>                <li>属性                    <p></p>                    <table>                        <tr>                            <td>属性</td>                            <td>描述</td>                        </tr>                        <tr>                            <td>bubbles</td>                            <td>返回布尔值，指示事件是否是起泡事件类型。</td>                        </tr>                        <tr>                            <td>cancelable</td>                            <td>返回布尔值，指示事件是否可拥可取消的默认动作。</td>                        </tr>                        <tr>                            <td>currentTarget</td>                            <td>返回其事件监听器触发该事件的元素。</td>                        </tr>                        <tr>                            <td>eventPhase</td>                            <td>返回事件传播的当前阶段。</td>                        </tr>                        <tr>                            <td>target</td>                            <td>返回触发此事件的元素（事件的目标节点）。不兼容低版本IE,低版本IE用srcElement</td>                        </tr>                        <tr>                            <td>timeStamp</td>                            <td>返回事件生成的日期和时间。</td>                        </tr>                        <tr>                            <td>type</td>                            <td>返回当前 Event 对象表示的事件的名称。</td>                        </tr>                    </table>                </li>                <p></p>                <li>方法                    <p></p>                    <table>                        <tr>                            <td>方法</td>                            <td>描述</td>                        </tr>                        <tr>                            <td>initEvent()</td>                            <td>初始化新创建的 Event 对象的属性。</td>                        </tr>                        <tr>                            <td>preventDefault()</td>                            <td>通知浏览器不要执行与事件关联的默认动作。</td>                        </tr>                        <tr>                            <td>stopPropagation()</td>                            <td>不再派发事件。</td>                        </tr>                    </table>                </li>            </ul>            <p></p>            <h3 id="s5.2">5.2 目标事件对象</h3>            <p></p>            <p>方法</p>            <p></p>            <table>                <tr>                    <td>方法</td>                    <td>描述</td>                </tr>                <tr>                    <td>addEventListener()</td>                    <td>允许在目标事件中注册监听事件(IE8 = attachEvent())</td>                </tr>                <tr>                    <td>dispatchEvent()</td>                    <td>允许发送事件到监听器上 (IE8 = fireEvent())</td>                </tr>                <tr>                    <td>removeEventListener()</td>                    <td>运行一次注册在事件目标上的监听事件(IE8 = detachEvent())</td>                </tr>            </table>            <p></p>            <h3 id="s5.3">5.3 事件监听对象</h3>            <p></p>            <p>方法</p>            <p></p>            <table>                <tr>                    <td>方法</td>                    <td>描述</td>                </tr>                <tr>                    <td>handleEvent()</td>                    <td>把任意对象注册为事件处理程序</td>                </tr>            </table>            <p></p>            <h3 id="s5.4">5.4 文档事件对象</h3>            <p></p>            <p>方法</p>            <p></p>            <table>                <tr>                    <td>方法</td>                    <td>描述</td>                </tr>                <tr>                    <td>createEvent()</td>                    <td>返回新创建的event对象</td>                </tr>            </table>            <p></p>            <h3 id="s5.5">5.5 鼠标/键盘事件对象</h3>            <p></p>            <ul>                <li>属性                    <table>                        <tr>                            <td>属性</td>                            <td>描述</td>                        </tr>                        <tr>                            <td>altKey</td>                            <td>返回当事件被触发时，"ALT" 是否被按下。</td>                        </tr>                        <tr>                            <td>button</td>                            <td>返回当事件被触发时，哪个鼠标按钮被点击。</td>                        </tr>                        <tr>                            <td>clientX</td>                            <td>返回当事件被触发时，鼠标指针的水平坐标。</td>                        </tr>                        <tr>                            <td>clientY</td>                            <td>返回当事件被触发时，鼠标指针的垂直坐标。</td>                        </tr>                        <tr>                            <td>ctrlKey</td>                            <td>返回当事件被触发时，"CTRL" 键是否被按下。</td>                        </tr>                        <tr>                            <td>Location</td>                            <td>返回按键在设备上的位置</td>                        </tr>                        <tr>                            <td>charCode</td>                            <td>返回onkeypress事件触发键值的字母代码。</td>                        </tr>                        <tr>                            <td>key</td>                            <td>在按下按键时返回按键的标识符。</td>                        </tr>                        <tr>                            <td>keyCode</td>                            <td>返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。</td>                        </tr>                        <tr>                            <td>which</td>                            <td>返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。</td>                        </tr>                        <tr>                            <td>metaKey</td>                            <td>返回当事件被触发时，"meta" 键是否被按下。</td>                        </tr>                        <tr>                            <td>relatedTarget</td>                            <td>返回与事件的目标节点相关的节点。</td>                        </tr>                        <tr>                            <td>screenX</td>                            <td>返回当某个事件被触发时，鼠标指针的水平坐标。</td>                        </tr>                        <tr>                            <td>screenY</td>                            <td>返回当某个事件被触发时，鼠标指针的垂直坐标。</td>                        </tr>                        <tr>                            <td>shiftKey</td>                            <td>返回当事件被触发时，"SHIFT" 键是否被按下。</td>                        </tr>                    </table>                </li>                <li>方法                    <table>                        <tr>                            <td>方法</td>                            <td>描述</td>                        </tr>                        <tr>                            <td>initMouseEvent()</td>                            <td>初始化鼠标事件对象的值</td>                        </tr>                        <tr>                            <td>initKeyboardEvent()</td>                            <td>初始化键盘事件对象的值</td>                        </tr>                    </table>                </li>            </ul>        </div>        <div class="list" id="s6">            <h2 id="s6">6.事件的冒泡(Bubble)</h2>            <p></p>            <p>所谓的冒泡指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发，在开发中大部分情况冒泡都是有用的，如果不希望发生事件冒泡，可以通过事件对象来取消冒泡，可以通过设置event.cancelBubble=true来取消冒泡，这个需要设置在子元素的事件中，并且大多数都是设置的可以冒泡，除了某些函数默认不冒泡</p>            <p></p>            <p></p>            <p></p>            <p>如果在父元素里面设置了一个事件,而在子元素中也有相同的事件,不想要父元素的事件在子元素的范围内出现时，可以通过多种方式设置取消冒泡</p>            <p></p>            <ol>                <li>event.cancelBubble=true(低版本IE都通过该方法)</li>                <li>因为这是默认行为，所以也可以直接在事件函数返回flase即可(return flase)<br/>注意:这种方法阻止默认行为只能够阻止通过onclick等绑定的事件,不能阻止通过addEventListener()等绑定的事件</li>                <li>通过event.stopPropagation()来阻止事件冒泡，但是不会阻止默认行为(低版本IE不兼容),低版本IE用event.returnValue=false</li>                <li>通过event.preventDefault()阻止默认行为来阻止冒泡</li>            </ol>            <p></p>            <p>兼容写法</p>            <p></p>            <div class="codeMirror">                <pre><code>if(event.stopPropagation)&#123;    event.stopPropagation();&#125;else&#123;    event.cancelBubble=true;//或event.returnValue=false;&#125;</code></pre>            </div>        </div>        <p></p>        <div class="list" id="s7">            <h2 id="s7">7.事件的委派</h2>            <p></p>            <p>事件的委派指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件,事件委派是利用了冒泡，通过委派可以事件绑定的次数，提高程序的性能</p>            <p></p>            <p></p>            <p>例子:</p>            <p></p>            <p>为每一个超链接都绑定一个单击响应函数，这里我们为每一个超链接都绑定了一个单击响应函数，这种中操作比较麻烦，而且这些操作只能为已有的超链接设置事件，而新添加超链接必须重新绑定</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><code>var a=document.getElementByTagName("a");for(var i=0;i&lt;a.length;i++)&#123;    a[i].onclick=function()&#123;    alert(123);    &#125;&#125;</code> </pre>            </div>            <p></p>            <p>我们希望，只绑定一次事件，即可应用到多个元素上，即使元素是后添加的，我们可以尝试将其绑定给元素的共同的祖先元素</p>            <p></p>            <div class="codeMirror">                <pre><code>//假设所以的a元素都是由一个父元素包裹var parent=document.getElementById("parent");parent.onclick=function()&#123;    alert(123);&#125;</code></pre>            </div>            <p></p>            <p>但是这个例子需要判断如果触发的对象是我们期望的元素,就执行该代码,否则不执行,因为如果点击的是a元素之外的其它地方就不触发弹窗效果,这个时候需要使用target 事件对象中的event中的target表示的触发事件的对象</p>            <p></p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><code>parent.onclick=function(event)&#123;    event=event||window.event;    if(event.target.nodeName==="A")&#123;//nodeName返回的标签名全大写        alert(123);       &#125;&#125;</code></pre>            </div>            <p></p>        </div>        <div class="list" id="s8">            <h2>8.事件的绑定</h2>            <p></p>            <h3 id="s8.1">8.1 绑定事件</h3>            <p></p>            <p>通过 对象.事件=函数 的形式绑定的响应函数，只能同时为一个元素的一个事件绑定一个响应函数，不能够绑定多个，如果绑定了多个，则后边绑定的响应函数会覆盖掉前边的</p>            <p></p>            <ul>                <li>通过addEventListener()方法(不支持IE8及以下浏览器)可以为元素绑定多个响应函数,该方法有三个参数<br/>参数                    <ul>                        <li>代表事件的字符串,不要加on</li>                        <li>回调函数，当事件触发时该函数会被调用</li>                        <li>是否在捕获或冒泡阶段触发事件，需要一个布尔值，true表示事件在捕获阶段执行,flase表示在冒泡阶段执行,默认值为false(可选),如果想要这两个事件都可以在同一个对象上发生必须添加两次事件</li>                    </ul>                </li>                <div class="codeMirror">                    <pre><code>btn.addEventListener("click",function()&#123;    alert(123);&#125;,false)</code></pre>                </div>                <p></p>                <p>addEventListene0r()方法可以同时为一个元素的相同事件绑定响应函数，这样当事件被触发时，响应函数将会按照函数的绑定顺序执行</p>                <p></p>                <p></p>                <li>在IE8及以下浏览器中可以通过attachEvent()方法为元素绑定多个响应函数,该方法有两个参数<br/>参数</li>                <p></p>                <ul>                    <li>事件的字符串，要加on</li>                    <li>回调函数</li>                </ul>                <p></p>                <div class="codeMirror">                    <pre><code>btn.attachEvent("onclick",function()&#123;    alert(123);&#125;)</code></pre>                </div>                <p>attachEvent()方法也可以同时为一个元素的相同事件绑定响应函数，不同的是该方法是后绑定的响应函数先执行</p>                <p></p>                <p>注:</p>                <li>大部分时候响应函数的执行顺序都不重要，如果需要对顺序要求就写成一个响应函数，要用这种方法添加的响应函数都是顺序不重要的函数</li>                <li>事件的绑定和委派等最好都是通过addEventListener()方法等来绑定,以免和别人的发生冲突</li>            </ul>            <p></p>            <p>注意:addEventListener()方法中的this是绑定事件的对象，attachEvent()方法中的this是window对象</p>            <p></p>            <p>兼容写法</p>            <p></p>            <p>注意:addEventListener()中的this是绑定事件的对象，attachEvent()中的this是window，需要统一两个方法的this</p>            <p></p>            <div class="codeMirror">                <pre><code>/*参数:obj 要绑定事件的对象eventStr 事件的字符串callback 回调函数*/function addEvent(obj,eventStr,callback) &#123;if(obj.addEventListener)&#123;    obj.addEventListener(eventStr,callback,false)&#125;else&#123;    obj.attachEvent("on"+eventStr,function () &#123;        callback.call(obj);    &#125;)&#125;&#125;/*因为this的不统一必须在attchEvent()中加一个回调函数，浏览器自动调用函数，然后我们自己手动调用函数，这样我们就能控制callback方法中的this了*/</code></pre>            </div>            <p></p>            <h3 id="s8.2">8.2 移除绑定</h3>            <p></p>            <ul>                <li>通过removeEventListener()方法(不支持IE8及以下浏览器)可以为元素移除响应函数,该方法有三个参数<br/>参数                    <ul>                        <li>代表事件的字符串,不要加on</li>                        <li>需要被移除的事件函数</li>                        <li>是否在捕获或冒泡阶段取消绑定事件，需要一个布尔值，true表示事件在捕获阶段执行,flase表示在冒泡阶段执行,默认值为false(可选)</li>                    </ul>                </li>                <li>在IE8及以下浏览器中可以通过detachEvent()方法为元素移除响应函数,该方法有两个参数<br/>参数                    <ul>                        <li>事件的字符串，要加on</li>                        <li>回调函数</li>                    </ul>                </li>            </ul>            <p></p>            <p>注意:</p>            <p></p>            <ul>                <li>如果要使用移除绑定,那么绑定时需要必须通过函数赋值的方式来绑定,因为如果是匿名函数移除的函数并不是同一个对象</li>                <li>如果不为removeEventListener()方法传入第三个参数会默认是移除冒泡状态的事件函数,不会移除捕获阶段的,因为这其实是两个不同的事件</li>                <li>移除绑定只能对用上述方法绑定的函数器作用,不会对用onclick属性等绑定的函数起作用</li>            </ul>            <p></p>            <p>兼容写法</p>            <p></p>            <div class="codeMirror">                <pre><code> /*参数:obj 要绑定事件的对象eventStr 事件的字符串callback 回调函数*/function removeEvent(obj,eventStr,callback) &#123;    if(obj.removeEventListener)&#123;        obj.removeEventListener(eventStr,callback,false)    &#125;    else&#123;        obj.detachEven("on"+eventStr,callback)    &#125;&#125;</code></pre>            </div>        </div>        <p></p>        <div class="list" id="s9">            <h2 id="s9">9.事件的传播</h2>            <p></p>            <p>关于事件的传播网景公司和微软公司有不同的看法</p>            <p></p>            <ul>                <li>微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就是说事件应该在冒泡阶段执行</li>                <li>网景公司认为事件应该是由外向内传播，也就是当前事件被触发时，应该先触发当前元素的最外层的祖先元素的事件，然后再向内传播给后代元素，这个阶段叫做捕获阶段</li>            </ul>            <p></p>            <p>最后，W3C综合了两个公司的方案，将事件传播分成了三个阶段</p>            <p></p>            <p>1.捕获阶段</p>            <p></p>            <p>在捕获阶段时从最外层的祖先元素，向目标元素进行进行事件的捕获，但是默认此时不会触发事件</p>            <p></p>            <p>2.目标阶段</p>            <p></p>            <p>事件捕获到目标元素，捕获结束开始在目标元素上触发事件</p>            <p></p>            <p>3.冒泡阶段</p>            <p></p>            <p>事件从目标元素向它的祖先元素传递，依次触发祖先元素上的事件</p>            <p></p>            <p>注意:</p>            <p></p>            <ul>                <li>如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true,一般情况下我们不会希望在捕获阶段触发事件，所以这个事件一般都是false</li>                <li>IE8及以下没有捕获阶段</li>            </ul>        </div>        <div class="list" id="s10">            <h2 id="s10">10.拖拽事件</h2>            <p></p>            <p>当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，此时会导致拖拽功能的异常，这个是浏览器提供的默认行为,如果不希望发生这个行为，可以通过return false来取消默认行为，但是对IE8及以下浏览器不起作用(并不是说IE8不支持使用return false来取消默认效果，只是不支持在拖拽时取消默认效果)</p>            <p></p>            <p></p>            <p></p>            <p>注意:</p>            <p></p>            <ul>                <li>使用addEventListener()方法绑定的响应函数，取消默认行为时不能使用return false,需要使用event事件对象通过event.preventDefault()方法来取消默认行为,但是IE8及以下浏览器不能支持该方法(包括addEventListener()方法)，使用该方法会报错，所以在调用的时候需要使用：event.preventDefault&&:event.preventDefault();</li>                <li>IE8中有setCapture()这一对鼠标按下相关事件进行捕获的方法，当一个调用一个元素的setCapture()方法以后，这个元素将会把下一次所有的鼠标按下相关的事件捕获到自己身上，其他鼠标触发都会由这个元素执行(包含在网页外面点击)，所以可以设置需要进行的行为对象在按下鼠标的时候捕获到所有的事件</li>            </ul>            <p></p>            <p>当鼠标松开时，取消对事件的捕获，取消捕获用releaseCapture()方法</p>            <p></p>            <div class="codeMirror">                <pre><code>var Odiv=document.getElementById("Odiv");Odiv.attachEvent("onmousedown",function()&#123;    Odiv.setCapture();    Odiv.attachEvent("onmousemove",function()&#123;    console.log(123);&#125;);&#125;);Odiv.attachEvent("onmouseup",function()&#123;    Odiv.releaseCapture();    console.log(456);&#125;);</code></pre>            </div>            <p></p>            <p>注:</p>            <ul>                <li>setCapture()和releaseCapture()必须成对出现</li>                <li>其它浏览器一样不支持该方法,所以在调用的时候用 Odiv.setCapture&&Odiv.setCapture()和Odiv.releaseCapture()&&Odiv.releaseCapture()                </li>            </ul>        </div>        <div class="list" id="s11">            <h2 id="s11">11.滚轮事件</h2>            <p></p>            <ul>                <li>onscroll事件为元素添加滚动(注意不是滚轮,滚动是滚动条发生变化)事件,该事件是滚动条变化就发生事件,所以一次鼠标滚动可能会发生很多次该事件</li>                <li>onwheel鼠标滚动事件,会在鼠标滚动时触发,推荐使用该事件</li>                <li>onmousewheel鼠标滚轮事件，会在滚轮滚动时触发，但是火狐不支持该属性，在火狐中需要使用DOMMouseScroll来绑定滚动事件，注意该事件需要通过addEventListener()方法来绑定</li>            </ul>            <p></p>            <p>鼠标滚轮滚动方向</p>            <p></p>            <ul>                <li>通过事件对象event.wheelDelta可以获取鼠标滚轮滚动的方向，向上滚为正，向下滚为负,值为数值120的倍数(一般为120,滚动过快会为120的倍数)<br/>注:只看正负，不看大小</li>                <li>在火狐中不支持event.wheelDelta属性,使用事件对象event.detail，向上滚为负，向下滚为正，与上方属性相反，并且每次滚动的数值为3的倍数(一般为3,滚动过快会为3的倍数)</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><code>&lt;!--通过滚轮控制盒子大小-->&lt;!DOCTYPE html>&lt;html lang="en">&lt;head>&lt;meta charset="UTF-8" />&lt;title>鼠标的滚轮事件&lt;/title>&lt;style>      #box1 &#123;        width: 100px;        height: 100px;        background-color: red;        margin: 500px auto;      &#125;      &lt;/style>      &lt;script>      window.onload = function() &#123;        var box1 = document.getElementById("box1");        //为box1绑定一个鼠标滚轮的事件        box1.onmousewheel = function(event) &#123;          event = window.event || event;          //火狐对鼠标滚轮方向的获取的属性时detail，其他浏览器是wheelDelta          //鼠标向上滚时wheelDelta是正数，向下是负数，detail刚好相反。          if (event.wheelDelta > 0 || event.detail < 0) &#123;            box1.style.height = parseFloat(box1.style.height) - 10 + "px";             //两种方式都可以，需要注意style.height必须是内联样式            //所以必须用内联样式，同时这个的返回值是有单位的，必须转换            box1.style.width = box1.clientWidth - 10 + "px";          &#125;          //当鼠标滚轮向下滚动,box1变长          //当鼠标滚轮向上滚动，box1变短          else &#123;            box1.style.height = parseFloat(box1.style.height) + 10 + "px";            box1.style.width = box1.clientWidth + 10 + "px";          &#125;          //这个只是为了再火狐通过addEventListener()方法添加事件的时候用          event.preventDefault && event.preventDefault();          //去除默认事件          return false;        &#125;;        addEvent(box1, "DOMMouseScroll", box1.onmousewheel);//给火狐添加        function addEvent(box1, eventStr, callback) &#123;          if (box1.addEventListener) &#123;            box1.addEventListener(eventStr, callback, false);          &#125; else &#123;            box1.attachEvent("on" + eventStr, function() &#123;              callback.call(box1);            &#125;);          &#125;        &#125;      &#125;;      &lt;/script>      &lt;/head>      &lt;body>      &lt;div id="box1" style="height: 100px">&lt;/div>     &lt;/body>&lt;/html></code></pre>            </div>            <p></p>            <p>兼容写法(包括控制滚动的方向)</p>            <p></p>            <div class="codeMirror">                <pre>                         <code>function mousewheel(dom,callback,bool)&#123;    //bool为传入的一个布尔值,如果是true则阻止默认行为,默认是不阻止    var type="mousewheel";                                  if(dom.onmousewheel===undefined)&#123;//不能通过判断下面的那个,因为在火狐中dom属性也没有这个属性        type="DOMMouseScroll";    &#125;    //真正的事件函数    function cb(event)&#123;        /*            自定义属性event.wheelDtail控制鼠标滚轮,所以在外部使用时应该用event.wheelDetail        */        //外部可以传入event作为事件对象也可以不传入直接使用,也不需要进行兼容,但是不传入时应该用event        event=event||window.event;        //把滚动事件的方向处理一致        event.wheelDetail=event.wheelDelta/123 || event.detail/-3        //每次滚动的值为1,并且向上滚动为正值,向下滚动为负值                //阻止默认行为        if(!!bool)&#123;            if(event.preventDefault)&#123;                event.preventDefault();            &#125;else&#123;                event.returnValue=flase;            &#125;        &#125;        callback.call(this,event);    &#125;        if(dom.addEventListener)&#123;        dom.addEventListener(type,cb);    &#125;else&#123;        dom,attachEvent("on"+type,cb)    &#125;&#125;</code></pre>            </div>        </div>        <p></p>        <div class="list" id="s12">            <h2 id="s12">12.键盘事件</h2>            <p></p>            <h3 id="s12.1">12.1 事件触发</h3>            <p></p>            <ul>                <li>onkeydown事件触发表明键盘按键被按下,如果一直按着某个按键不松手，则事件会一直触发<br/>注意:当onkeydown事件连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常快，这种设计是为了防止误操作事故的发生,如果不想要这种效果请使用定时器</li>                <li>onkeyup事件触发表明键盘按键被松开</li>            </ul>            <p></p>            <p>注:键盘事件有一般都会绑定给一些可以获取到焦点的对象或者是document，有焦点的对象就是可以让光标停留的地方，比如input标签</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><code>var input=document.getElementById("input");    input.onkeydowm=function()&#123;                                    &#125;</code></pre>            </div>            <p></p>            <h3 id="s12.2">12.2 事件属性</h3>            <p></p>            <p>通过事件对象event的keyCode和key属性可以获取按键的编码和输入键的字符，可以判断哪个按键被按下</p>            <p></p>            <div class="codeMirror">                <pre><code>if(event.keyCode===89)&#123;    console.log("y被按下了");    &#125;                                   if(event.key==="y")&#123;        console.log("y被按下了");    &#125;</code></pre>            </div>            <p></p>            <p>事件对象中还提供了几个辅助属性</p>            <p></p>            <ul>                <li>altKey属性判断alt键是否被按下，如果按下则返回true，否则返回false</li>                <li>ctrlKey属性判断ctrl键是否被按下，如果按下则返回true，否则返回false</li>                <li>shiftKey属性判断shift键是否被按下，如果按下则返回true，否则返回false</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><code>//判断y和ctrl是否同时被按下document.onkeydown=function(event)&#123;    event=event||window.event;if(event.keyCode===89&&event.ctrlKey)&#123;console.log("ctrl和y都被按下了")&#125;&#125;</code></pre>            </div>            <p></p>            <p>注意:在文本框中输入内容，属于onkeydown的默认行为，如果在onkeydown中取消了默认行为return false，则输入的内容不会出现在文本框中</p>            <p></p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><code>//文本框中不能输入数字input,onkeydown=function(event)&#123;    event=event||window.event;    if(event.keyCode>=48&&event.keyCode<=57)&#123;            return false;        &#125;&#125;</code></pre>            </div>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/css/"/>
    <url>/CodeNote/2020/10/23/zone/html/css/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title">            <h1>CSS</h1>        </div>        <p></p>        <div class="list" id="s1">            <h2>1.外部链接</h2>            <div class="codeMirror">                <pre><code>@charset "UTF-8";/*在外部的css中最上方应该写上上面的代码*/</code></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><code><link href="" rel="stylesheet" type="text/css">/*    这是链入外部样式表    rel用来定义链接的文件与HTML之间的关系，rel="stylesheet"指在页面中使用这个外部链接表    type指定文件类型 type="text/css"指文件的类型是样式表文本*/<link href="" rel="icon">/*这种是用来设置logo图标,该图标就是title前面的小图形href就是要引入的小图片的域名*/</code></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><code><style type="text/css">@import url("");</style>/*    导入外部样式表@import url("");用在style里，用法和link很相似，但是实际上相当于是内部链接*/</code></pre>            </div>        </div>        <p></p>        <div class="list" id="s2">            <h2>2.类和ID及css选择器</h2>            <p></p>            <h3 id="s2.1">2.1 类</h3>            <p></p>            <p><code><标记名 class=""></code>            </p>            <p></p>            <h3 id="s2.2">2.2 ID</h3>            <p></p>            <p><code><标记名 id="">id具有唯一性</code></p>            <p></p>            <h3 id="s2.3">2.3 css选择器</h3>            <p></p>            <p><strong>选择器的权重大小:ID>类>标签名>通配符</strong></p>            <p></p>            <p>在选择器中的属性出现相同的时候,优先考虑ID选择器,然后是类选择器,标签选择器,最后才考虑通配符选择器 在都有这些选择器的时候再看每一个选择器的数量,从ID到标签选择器,数量多的属性生效,如果数量完全相同,那么写在下方的生效</p>            <p></p>            <p></p>            <p><strong>注意:</strong> </p>            <p></p>            <ol>                <li>如果css是写在行内的,无视所有选择器直接拿到权重</li>                <li>相同选择器数量的情况下内部样式的权重大于外部样式的权重,但是如果外部用的是ID选择器内部是类选择器,那么外部的属性生效</li>                <li>可以使用!important将权重提升到最高,甚至超过行内样式,但是尽量减少important的使用,因为过多的使用容易造成对于样式设置的混乱</li>            </ol>            <p></p>            <ul>                <li>标签选择器<br/><strong>通过标签直接对所有该标签元素进行样式的修改</strong></li>                <li>通配符选择器<br/><strong>能选择所有的标签元素，权重很低,在开发中不推荐使用</strong><br/>用法:*{}</li>                <li>后代元素选择器<br/><strong>选择当前标签下的所有相匹配的后代,不一定是子代,可以是孙子代,中间用空格隔开</strong><br/>如:.类 ul li p这样的选择器就是选择当前类下的ul标签中的所有li标签中的所有p标签</li>                <li>子元素选择器<br/><strong>基本与后代元素选择器的用法相同,不过只能够选择子代,不能选择孙子代,中间用>符合隔开</strong><br/>如:.类>li>a等就是对必须是li下面的a元素才起作用</li>                <li>兄弟选择器</li>                <ul>                    <li><strong>相邻兄弟选择器,匹配前面一个选择器后紧跟的同级选择器,中间用+符号隔开</strong><br/>如:a+p{}表示匹配在前一个a元素的后面紧跟着的一个p元素</li>                    <li><strong>一般兄弟选择器,匹配前一个元素后面的所有同级的某一个元素,中间用~符号隔开</strong><br/>如:a~p{}表示匹配在前一个a元素的所有后面p的元素</li>                </ul>                <p></p>                <li>伪元素选择器</li>                <p></p>                <ul>                    <li><strong>创建伪元素before/after<br/>伪元素必须依赖某一个标签才能产生<br/>如下：</strong></li>                </ul>            </ul>            <p></p>            <div class="codeMirror">                <pre><code>div::before&#123;/*或者是after*/    content:"";/*这个属性必须写,没有就赋空值*/    display:inline-block;/*伪元素的默认表现形式是inline*/    height:;    width:;    background-color：    &#125;    /*        div::before/after是在div的内容前面加上一个元素，这个元素依然在该元素里面    */</code></pre>            </div>            <ul>                <li><strong>注：</strong></li>                <ul>                    <li>伪元素可以传入图片,一种是通过background-image属性传入,一种是在content处用url()函数来传入图片</li>                    <li>可以通过在content处写上attr()函数来获取伪元素所在环境的标签上的属性</li>                </ul>            </ul>            <div class="codeMirror">                <pre><code>div::before&#123;        content:attr(data-test);/*通过这种方法可以把下方div中data-test属性的值取出*/    &#125;/*    注意:在H5的规范中自定以属性前面最好加上data-的标识*/ </code></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><code><div data-test="123"></div></code></pre>            </div>            <p></p>            <p>可以通过伪元素来清除浮动</p>            <p></p>            <div class="codeMirror">                <pre><code>.clear::after&#123;    content:"";    display:block;    clear:both;&#125;/*    只需要给因为子元素浮动而造成本身高度塌陷的父元素.clear这个类就能够清除浮动效果*/</code></pre>            </div>            <p>伪类选择器<br/>注:伪类可以对链接在不同状态下定义不同的样式效果，伪类是CSS已经定义了的<br/>如：</p>            <p></p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><code>E:empty&#123;&#125;//匹配内容为空的标签(空格也算作内容)E:first-letter&#123;&#125;//匹配对象的第一个字符E:first-line&#123;&#125;//匹配对象内的第一个行E:selection&#123;Background-color:black;color:white;&#125;//设置对象被选择时的样式,上面使得被选中时呈现黑底白色E:hover&#123;&#125;//匹配对象被鼠标悬浮时的样式/*伪类一般是对a标签进行控制的,下面几种伪类选择器一般都是对a标签生效*/a:link&#123;&#125;//匹配a标签没触发时的状态a:visited&#123;&#125;//匹配a标签被点击后的状态a:hover&#123;&#125;//匹配a标签被悬浮时的状态的状态a:active&#123;&#125;//匹配a标签被点击但是鼠标还没放开时的激活状态/*记忆方法:love hate*//*    如果四个标签一起出现,必须要严格的顺序要求,link visited hover activ    如果默认与被访问过一样，可以进行缩写直接a&#123;&#125;代替，但是hover和active如果需要必须写上*/</code></pre>            </div>            <p></p>            <p>属性选择器</p>            <p></p>            <p>属性选择器选择时一般都是通过[]将要进行筛选的属性括起来<br/>如</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><code>a[herf]&#123;&#125;//表示任何带有href的a标记a[herf="http://www.baidu.com"]&#123;&#125;//表示将指向百度的链接ap[class=cc]&#123;&#125;/*    找到所有p标签中class属性等于cc的,这个的用法最常见于区分input属性type=password*/</code></pre>            </div>            <p></p>            <p>前缀和后缀和包含匹配</p>            <p></p>            <div class="codeMirror">                <pre><code>/*前缀使用[^=]*/[id^="user"]&#123;&#125;/*    则所有有id并且前缀为user的元素都可以被设置    如:<p id="userName">李振</p>等可被设置*//*后缀使用[$=]*/[id$="Name"]&#123;&#125;/*    则所有有id并且后缀为Name的元素都可以被设置*//*包含使用[*=]*/[id*="test"]&#123;&#125;/*    则所有有id并且id中包含有test的元素都可以被设置*/</code></pre>            </div>            <p></p>            <ul>                <li>交并集选择器</li>                <ul>                    <li>交集选择器需要两个选择器紧挨着写,并且如果有标签选择器标签需要在最前面写</li>                    <li>并集选择器则是用逗号(,)隔开就可以,这样就会选中所有的被,隔开的选择器</li>                </ul>                <li>序选择器</li>                <ul>                    <li>:first-child选中同级别第一个<br/>如:p:first-child这样用相当于和p做交集选出同级别第一个元素后与p做交集</li>                    <li>:first-of-type选中同级别同类型的第一个元素</li>                    <li>:last-child选中同级别最后一个标签，不区分类型</li>                    <li>:last-of-type选中同级别同类型的最后一个</li>                    <li>:nth-child(n)选中同级别中的第n个标签，不区分类型<br/>拓展用法:odd代表奇数行 even代表偶数行<br/>用xn+y这样的语法进行选择:x和y是用户自定义的,而0是一个计数器，从0开始递增</li>                    <li>:nth-of-type(n)选中同级别中、同类型的第n个标签，用法同上</li>                    <li>:nth-lastchild(n)选中同级别的第倒数第几个标签</li>                    <li>:only-child选中只有一个子元素的父元素带的子元素</li>                    <li>:only-of-type选中父元素中唯一类型的标签</li>                    <li>:not(tagname)选中不是指定标签的所有标签</li>                </ul>                <p>注意:CSS样式的继承性:</p>                <p></p>                <p>只有以color/font-/text-/line开头的属性才可以继承</p>                <p></p>                <p>特例:a标签的下划线和颜色不能继承，h标签的字体大小不能继承</p>                <p></p>                <p>计算权重时只对被直接选中的元素进行选择</p>            </ul>        </div>        <p></p>        <div class="list" id="s3">            <h2>3.文本样式</h2>            <p></p>            <h3 id="s3.1">3.1 字体样式</h3>            <p></p>            <p>1.字体类型font-family</p>            <p></p>            <p>font-family属性表示用哪一个字体,这个属性后面写需要的字体,字体可以写多个,但总是从第一个开始用,如果用户<br/>没有第一个字体样式.那么会依次用后面的字体</p>            <p></p>            <p><strong>如何用外部引用的字体:</strong></p>            <p></p>            <div class="codeMirror">                <pre><code>@font-face &#123;    font-family:"字体名称";    src:"字体文件在服务器上的相对或绝对路径";&#125;/*    设置之后就能在font-family里面设置自己需要的字体了*/</code></pre>            </div>            <p></p>            <p>2.字体尺寸font-size</p>            <p></p>            <p>font-size属性表示字体大小,这个属性一般用的单位为px,也可以用一般表示大小的单词来直接表示大小,这个大小<br/>是由浏览器加上的,如:xx-small x-small等绝对尺寸,smaller和larger等相对尺寸以及百分比尺寸</p>            <p></p>            <p></p>            <p>3.字体粗细font-weight</p>            <p></p>            <p>font-weight属性改变字体粗细,可以写具体的数字也可以写表示大小的单词由浏览器加上</p>            <ul>                <li>100-900表示字体粗细的数字值</li>                <li>normal表示正常字体粗细，相当于数字值400</li>                <li>bold表示粗体，相当于数字值700,同时这个值也是最常用的,一般不用数字值,而且这个属性一般也只用作让字体加粗</li>                <li>bolder lighter定义比继承者值更重和更轻的值 ,这是相对值</li>            </ul>            <p></p>            <p>4.字体风格font-style</p>            <p></p>            <p>font-style属性表示字体风格,一般都用作让字体倾斜</p>            <ul>                <li>nomal表示正常字体</li>                <li>italic和oblique都是表示斜体,但是实质上还是有差别,一般都用italic</li>            </ul>            <p></p>            <p>5.字体显示小型大写字符font-variant</p>            <p></p>            <p>font-variant属性定义小写字母是否显示为小型大写字母，默认的值为normal</p>            <p></p>            <p>用法:font-variant:small-caps;</p>            <p></p>            <p>字体混合属性用法:font:font-style font-variant font-weight font-size font-family 中间可以少,但是必须按照<br/>这个顺序排列</p>            <p></p>            <p></p>            <p>6.字体颜色color</p>            <p></p>            <p>color属性表示字体颜色,支持英文单词,16进制颜色和rgb颜色</p>            <p></p>            <p>注意:</p>            <ul>                <li>rgb()和rgba()后者最后一个是透明度</li>                <li>color:transparent为颜色透明</li>            </ul>            <h3 id="s3.2">3.2 行高line-height</h3>            <p></p>            <p>line-height属性设置行高，行高和字体高度不同,但是行高默认会随着字体大小的变化而变化,而撑开盒子高度就是靠的行高            </p>            <p></p>            <p>注意:通过设置行高和内容高度相等可以使得单行文本垂直居中</p>            <p></p>            <p>多行文本垂直居中方法:</p>            <p></p>            <p>方法一：使用插入 table (包括tbody、tr、td)标签，或者父元素使用display:table和子元素使用 display:table-cell属性来模拟表格，同时设置子元素vertical-align:middle            </p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><code><div class="span_box bg_box">    <span class="words_span">方法一：父元素使用display:table和子元素使用display:table-cell属性来模拟表格，子元素设置vertical-align:middle即可垂直居中    </span></div></code></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><code>.bg_box &#123;    width: 300px;    height: 300px;    margin-top: 20px;    background-color: #BBBBBB;&#125;/*方法一*/.span_box &#123;    display: table;&#125;.words_span &#123;    display: table-cell;    vertical-align: middle;&#125;</code></pre>            </div>            <p></p>            <p>方法二：对子元素设置display:inline-block属性，使其转化成行内块元素，模拟成单行文本。元素设置对应的height和line-height。对子元素设置vertical-align:middle属性，使其基线对齐添加line-height属性，覆盖继承自父元素的行高。缺点：文本的高度不能超过外部盒子的高度</p>            <p></p>            <div class="codeMirror">                <pre><code><div class="p_box bg_box">    <p class="words_p">        方法二：对子元素设置display:inline-block属性，使其转化成行内块元素，模拟成单行文本。        父元素设置对应的height和line-height。对子元素设置vertical-align:middle属性，        使其基线对齐。添加line-height属性，覆盖继承自父元素的行高。        缺点：文本的高度不能超过外部盒子的高度。    </p></div></code></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><code>.bg_box &#123;    width: 300px;    height: 300px;    margin-top: 20px;    background-color: #BBBBBB;&#125;/*方法二*/.p_box &#123;    line-height: 300px;&#125;.words_p &#123;    display: inline-block;    line-height: 20px;  /*单独给子元素设置行高，覆盖父级元素的行高*/    vertical-align: middle;  /*基线居中对齐*/&#125;</code></pre>            </div>            <p></p>            <p>方法三:脱离文档流的居中方式，把内部div设置宽高之后，再设置top为50%，使用负边距调整，将margin-top设置为负的高度的一半就可以垂直居中了。缺点:需要计算出多行文字固定的高度。高度一旦改变，负边距也要调整。</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><code>&lt;div class="wrapper bg_box">    &lt;div class="content_box">    方法三：脱离文档流的居中方式，把内部div设置宽高之后，再设置top为50%，使用负边距调整，    将margin-top设置为负的高度的一半就可以垂直居中了。缺点：需要计算出多行文字固定的高度。    高度一旦改变，负边距也要调整。    &lt;/div>    &lt;/div></code></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><code>.bg_box &#123;    width: 300px;    height: 300px;    margin-top: 20px;    background-color: #BBBBBB;&#125;/*方法三*/.wrapper &#123;    position: relative;    overflow: hidden;&#125;.content_box &#123;    position: absolute;    top: 50%;    width: 300px;    height: 127px; /*本页面中这么多文字的高度，文本篇幅改变，高度也会变*/    margin-top: -63.5px;  /*height的一半*/&#125;</code></pre>            </div>            <p></p>            <p></p>            <h3 id="s3.3">3.3 文字上下对齐vertical-align</h3>            <p></p>            <p>vertical-align属性设置内联元素的上下对齐方式,在父元素设置此样式时,会inline-block和inline类型的子元素都有用,这个样式一般用做图片和文字的对齐,因为内联元素的独特的对齐方式,所以设置图文对齐的方法一般都是图形和文字都设置vertical-align:middle来使得图文对齐</p>            <p></p>            <p></p>            <p></p>            <p>verticl-align的值:</p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>baseline</td>                    <td>默认。元素放置在父元素的基线上</td>                </tr>                <tr>                    <td>sub</td>                    <td>垂直对齐文本的下标</td>                </tr>                <tr>                    <td>super</td>                    <td>垂直对齐文本的上标</td>                </tr>                <tr>                    <td>top</td>                    <td>把元素的顶端与行中最高元素的顶端对齐</td>                </tr>                <tr>                    <td>text-top</td>                    <td>把元素的顶端与父元素字体的顶端对齐</td>                </tr>                <tr>                    <td>middle</td>                    <td>把此元素放置在父元素的中部</td>                </tr>                <tr>                    <td>bottom</td>                    <td>把元素的顶端与行中最低的元素的顶端对齐</td>                </tr>                <tr>                    <td>text-bottom</td>                    <td>把元素的底端与父元素字体的底端对齐</td>                </tr>                <tr>                    <td>length</td>                    <td>定义固定的值</td>                </tr>                <tr>                    <td>%</td>                    <td>使用 "line-height" 属性的百分比值来排列此元素。允许使用负值</td>                </tr>                <tr>                    <td>inherit</td>                    <td>规定应该从父元素继承 vertical-align 属性的值</td>                </tr>            </table>            <p></p>            <p>内联元素的对齐方式:</p>            <p></p>            <p>所有的内联元素都是通过文字基线对齐方式来实现对齐的,默认情况下是以小写x的两个下角为边界进行图文对齐,图片不会超过x的下角所在水平线的位置,vertical-align的默认值是baseline,元素是放在父元素的基线上的</p>            <p></p>            <p>不知道盒子高度的情况下将文本垂直居中</p>            <p></p>            <div class="codeMirror">                <pre><code>/*设置伪元素使文本居中*/p:before&#123;display:inline-block;    content:"";    height:100%;    vertical-align:middle;&#125;</code></pre>            </div>            <p></p>            <h3 id="s3.4">3.4 文本水平对齐text-align</h3>            <p></p>            <p>text-align属性设置水平对齐方式</p>            <p></p>            <p>值:left左对齐 right右对齐 center居中对齐 justify两端对齐</p>            <p></p>            <h3 id="s3.5">3.5 文本换行white-space</h3>            <p>white-space属性可以对文本的换行操作进行控制,默认值是nomal,设置文本到达父元素的边界就自动换行</p>            <p></p>            <p>white-space:nowrap设置文本不换行,意思是文本到达边界依然会继续的由左向右平铺,该属性只要都是设置这个值,除此之外还有其他的值,如:white-space:pre不换行又保留多个空格 white-space:pre-wrap保留空白字符但是换行 white-space: pre-line保留换行符white-space:inherit继承父元素的该属性</p>            <p></p>            <p></p>            <p></p>            <p>实现文本超出显示省略号:</p>            <p></p>            <p>需要三个属性的组合</p>            <p></p>            <ul>                <li>white-space:nowrap不换行</li>                <li>text-overflow:ellipsis文本超出显示省略号</li>                <li>overflow:hidden超出隐藏</li>            </ul>            <h3 id="s3.6">3.6 单词换行word-break</h3>            <p></p>            <p>word-break属性可以控制单词或字符进行换行,默认值为normal,使浏览器遵循默认的换行规则</p>            <p></p>            <p>word-break:break-all强制换行,允许在单词内部换行,如果只写一个因为单词但是太长用了这个属性就会强制把单词断开</p>            <p></p>            <p>word-break:keep:all,只允许在半角空格或连字符处换行</p>            <p></p>            <h3 id="s3.7">3.7 文本缩进text-indent</h3>            <p></p>            <p>text-indent属性控制文本在一个父元素最前方字符的缩进距离,该属性可以通过调试来让文本显示在父元素的一些特殊位置,可以把它用做于padding-left的作用类似，默认值是not specified,也就是不首行缩进</p>            <p></p>            <p></p>            <p>设置的值一般都是固定的缩放距离，比如:text-indent:2em 首行缩进2个字符。也可以是百分比，定义基于父元素宽度的百分比的缩进</p>            <p></p>            <p></p>            <h3 id="s3.8">3.8 控制单词形式text-transform</h3>            <p></p>            <p>text-transform属性控制英文单词大小写转换</p>            <p></p>            <p>值:none 无转换 capitalize将每个单词的第一个字母大写 uppercase将所有字母大写 lowercase将所有字母小写ful-width全角</p>            <p></p>            <h3 id="s3.9">3.9 字符与单词间距</h3>            <p></p>            <p>一行文字如果中间没有空格隔开就是组成部分就是一个个字符,这一行文字就是一个单词,而如果有空格隔开,根据空格的数量来判断单词的数量</p>            <p></p>            <p></p>            <p>letter-spacing用来控制字符间的间距,默认值为normal,具体也是通过写固定的值来实现字符间距</p>            <p></p>            <p>注:汉字也是被认为是一个个的字符,因为中间没有用空格隔开</p>            <p></p>            <p>word-spacing为单词间距,该间距是每一个用空格隔开英文单词的间距.只有用空格隔开的词才会认为是一个单词,单词内部间距不变</p>            <p></p>            <h3 id="s3.10">3.10 文本修饰text-decoration</h3>            <p></p>            <p>text-decoration属性用于修改文本的样式,是一个复合属性,该属性也是由一些小的属性的组合属性,但是在运用时都是直接用这个属性</p>            <p></p>            <p>子属性:</p>            <p></p>            <p>1.text-decoration-line设置文本修饰的样式线条,一般标签的默认值为none关闭修饰,而a标签的默认值是</p>            <p></p>            <p>underline 下划线文本,所以一般a标签都需要通过设置text-decoration:none来修改a标签的样式,其它值还有overline上划线 line-through贯穿线(也叫作删除线)</p>            <p></p>            <p></p>            <p>2.text-decoration-style设置文本修饰的风格,值:</p>            <p></p>            <p>solid实线 double双线 dotted点线 dashed虚线 wave波浪线</p>            <p></p>            <p>3.text-decoration-color设置文本修饰颜色,用来指定文本装饰线条的颜色,如果不写这个属性这是默认用的字体颜色color</p>            <p></p>            <h3 id="s3.11">3.11 文本阴影text-shadow</h3>            <p></p>            <p>text-shadow属性设置文本周围是否出现阴影,默认值为none 无阴影</p>            <p></p>            <p>设置阴影test-shadow:长度1 长度2 长度3 颜色 (长度三和颜色为可选属性)</p>            <p></p>            <ul>                <li>长度1设置水平偏移值，可以为负值，正值表示阴影在右，负值在左</li>                <li>长度2设置垂直偏移量 正值在下负值在上</li>                <li>长度3用来设置文本的阴影模糊值，不允许用负值</li>                <li>颜色用来设置阴影的颜色</li>            </ul>            <p></p>            <p>注:可以写多组阴影,每一组阴影中间用逗号隔开</p>            <p></p>            <h3 id="s3.12">3.12 文本书写模式writing-mode</h3>            <p></p>            <p>writing-mode 属性定义了文本在水平或垂直方向上如何排布</p>            <p></p>            <p>语法:</p>            <p></p>            <div class="codeMirror">                <pre><code>writing-mode: horizontal-tb | vertical-rl | vertical-lr |sideways-rl | sideways-lr;</code></pre>            </div>            <p>值：</p>            <p></p>            <ul>                <li>horizontal-tb：水平方向自上而下的书写方式。即 left-right-top-bottom</li>                <li>vertical-rl：垂直方向自右而左的书写方式。即 top-bottom-right-left</li>                <li>vertical-lr：垂直方向内内容从上到下，水平方向从左到右</li>                <li>sideways-rl：内容垂直方向从上到下排列</li>                <li>sideways-lr：内容垂直方向从下到上排列</li>            </ul>            <p></p>            <h3 id="s3.13">3.13 列表属性list-style</h3>            <p></p>            <p>list-style是复合的列表属性,包含list-style-image,list-style-position和list-style-type等</p>            <p></p>            <ul>                <li>list-style-image属性用来设置对象的列表项是否图像作为项目符号<br/>list-style-image:url()来指定图片的域名,还有一个none值意为不指定图片符号</li>                <li>list-style-position属性用来设置对象的列表序号的位置<br/>list-style-positon:outside（inside）ouside为默认值,让列表符号与文字分离开,inside使得列表序号在文本内,可以通过控制文本来控制</li>                <li>list-style-type属性为设置对象的列表项所使用的项目符号<br/>list-style-type:disc实心圆 circle空心圆 square实心方块 decimal阿拉伯数字 lower-alpha小写英文字母 upper-alpha大写英文字母 none 为不用项目符号<br/>列表复合属性语法: <br/>list-style:list-style-image list-style-position list-style-type 按照这个顺序进行书写                    如果list-style-image这个属性有值并且生效,那么list-style-type属性将不会生效,如果这个属性使none那么list-style-type属性生效                </li>            </ul>            <h3 id="s3.14">3.14 文本溢出text-overflow</h3>            <p></p>            <p>text-overflow 属性规定当文本溢出包含元素时发生的事情,默认值是clip,修剪文本,将文本剪裁掉</p>            <p></p>            <p>值:</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>clip</td>                    <td>修剪文本</td>                </tr>                <tr>                    <td>ellipsis</td>                    <td>显示省略符号来代表被修剪的文本</td>                </tr>                <tr>                    <td>string</td>                    <td>使用给定的字符串来代表被修剪的文本</td>                </tr>            </table>            <p></p>            <h3 id="s3.15">3.15 内容溢出overflow</h3>            <p></p>            <p>overflow属性定义溢出元素内容区的内容会如何处理,默认值是visible，超出内容不会被修剪，会呈现在元素框之外</p>            <p></p>            <p>值:</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>hidden</td>                    <td>内容会被修剪，并且其余内容是不可见的。</td>                </tr>                <tr>                    <td>scroll</td>                    <td>内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</td>                </tr>                <tr>                    <td>auto</td>                    <td>如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</td>                </tr>                <tr>                    <td>inherit</td>                    <td>规定应该从父元素继承 overflow 属性的值。</td>                </tr>                <tr>                    <td>visible</td>                    <td>默认值。内容不会被修剪，会呈现在元素框之外。</td>                </tr>            </table>        </div>        <p></p>        <div class="list" id="s4">            <h2>4.盒子模型</h2>            <p></p>            <p><strong>注意:因为不同的浏览器会为盒子自动添加不同的内外边距.如果要让网页在每一个浏览器上都显示一样的效果.需要在写代码前把默认的边距全部清空,在平时可以用通配符选择器来清空,但是写正规项目的时候不要这样写,因为通配符选择器的权重太低了</strong> </p>            <p></p>            <p></p>            <p></p>            <p>HTML盒模型由4个元素组成:content padding border margin(按由内到外的顺序)</p>            <p></p>            <p>font-family属性表示用哪一个字体,这个属性后面写需要的字体,字体可以写多个,但总是从第一个开始用,如果用户<br/>没有第一个字体样式.那么会依次用后面的字体</p>            <p></p>            <p></p>            <p><strong>盒子大小的计算方法:content(内容区)+padding(内边距)+border(边框)+margin(外边距)</strong></p>            <p></p>            <h3 id="s4.1">4.1 margin的注意点</h3>            <ul>                <li>两个紧挨的兄弟盒子同时设margin,左右两边的margin会叠加,而上下的margin会重叠,margin值更大的盒子的margin会生效</li>                <li>当两个盒子是父子关系时,设置子盒子左右的margin值会让子盒子在父盒子里面进行偏移,如果设置上下的 margin值则会有margin重合的现象,让父盒子也跟着子盒子一起移动,给父盒子添加border属性可以避免这种现象</li>            </ul>            <h3 id="s4.2">4.2 box-sizing</h3>            <p>box-sizeing属性能改变盒子大小的计算方法</p>            <p></p>            <div class="codeMirror">                <pre><code>box-sizing：content-box|border-box;</code></pre>            </div>            <p></p>            <p>默认值是content-box,默认情况下width和height只改变内容区</p>            <p></p>            <p>padding和border的宽度一起算入width和height中,当宽度和高度固定时,变化padding和border值会自动的将内容区域缩小</p>            <p></p>            <h3 id="s4.3">4.3 边框border</h3>            <p></p>            <h4 id="s4.3.1">4.3.1 一般边框</h4>            <p></p>            <p>border属性是一个复合属性,可以按照border-width border-style border-color的顺序设置边框</p>            <p></p>            <p>border:宽度 样式 颜色</p>            <ul>                <li>border-width属性,定义边框厚度</li>                <table>                    <tr>                        <td>值</td>                        <td>描述</td>                    </tr>                    <tr>                        <td>thin</td>                        <td>定义细的边框。</td>                    </tr>                    <tr>                        <td>medium</td>                        <td>默认。定义中等的边框。</td>                    </tr>                    <tr>                        <td>thick</td>                        <td>定义粗的边框。</td>                    </tr>                    <tr>                        <td>length</td>                        <td>允许自定义边框的宽度。</td>                    </tr>                    <tr>                        <td>inherit</td>                        <td>规定应该从父元素继承边框宽度。</td>                    </tr>                </table>                <li>通常情况下边框的宽度都是直接写固定的值border-style属性定义边框的样式</li>                <table>                    <tr>                        <td>值</td>                        <td>描述</td>                    </tr>                    <tr>                        <td>none</td>                        <td>定义无边框。除非用border-image边框才能使边框生效</td>                    </tr>                    <tr>                        <td>hidden</td>                        <td>与 "none" 相同。不过应用于表时除外，对于表，hidden 用于解决边框冲突。</td>                    </tr>                    <tr>                        <td>dotted</td>                        <td>定义点状边框。在大多数浏览器中呈现为实线。</td>                    </tr>                    <tr>                        <td>dashed</td>                        <td>定义虚线。在大多数浏览器中呈现为实线。</td>                    </tr>                    <tr>                        <td>solid</td>                        <td>定义实线。</td>                    </tr>                    <tr>                        <td>double</td>                        <td>定义双线。双线的宽度等于 border-width 的值。</td>                    </tr>                    <tr>                        <td>groove</td>                        <td>定义 3D 凹槽边框。其效果取决于 border-color 的值。</td>                    </tr>                    <tr>                        <td>ridge</td>                        <td>定义 3D 垄状边框。其效果取决于 border-color 的值。</td>                    </tr>                    <tr>                        <td>inset</td>                        <td>定义 3D inset 边框。其效果取决于 border-color 的值。</td>                    </tr>                    <tr>                        <td>outset</td>                        <td>定义 3D outset 边框。其效果取决于 border-color 的值。</td>                    </tr>                    <tr>                        <td>nherit</td>                        <td>规定应该从父元素继承边框样式。</td>                    </tr>                </table>                <li>border-color属性,定义边框线的颜色<br/>注意:<br/>以上的三个属性也全部都是复合属性,都是上下左右四个方向的复合属性结构,只写一个值是上下左右四个面全部都是那个值,可以通过如:border-top-width这样的写法来单独设置某一个面,也可以写四个值来分别显示四个面的结果 ,一样的遵循上右下左的格式</li>            </ul>            <p></p>            <h4 id="s4.3.2">4.3.2 圆角边框</h4>            <p></p>            <p>border-radius属性决定是否边角出现圆角,这个属性也是个复合属性,决定左上 右上 右下 左下四个方向的圆角大小,也可以只写一个来代表所有方向,这个属性和border属性无关,即使没有边框也可以作用</p>            <p></p>            <p></p>            <p>注意:这个属性经常用做显示胶囊状的盒子,同时如果盒子的宽高相等,再将这个属性设置为50%，就会出现圆形的盒子</p>            <p></p>            <h4 id="s4.3.3">4.3.3 图像边框</h4>            <p></p>            <p>border-image属性设置是否用图像边框.启用的这个属性border-style设置的边框将会无效,同时这个属性也是个复合属性</p>            <p></p>            <div class="codeMirror">                <pre><code>border-image:border-image-sorce border-image-slice/border-image-width/*(/号不是或者的意思,如果要写必须写/）*/ border-image-outside border-image-repeat/*具体用法如下*/border-image:url() slice/width outside repeat;</code></pre>            </div>            <p></p>            <ul>                <li>border-image-sorce属性用于指定要用于绘制边框的图像的位置,该属性默认值是none,如果要传入图片和写背景图片的用法是一样的用url("")来传入图片的地址</li>                <li>border-image-slice属性控制边框图像地切片方式,也是指定四个位置</li>                <div class="codeMirror">                    <pre><code>border-image-slice: number|%|fill;</code></pre>                </div>                <p></p>                <li>这个属性的值可以是具体的数值也可以是百分比,如果后面再加fill表示保留着中间部分，相当于盒子作为了背景图片<br/>注意: 此属性指定顶部 ，右，底部，左边缘的图像向内偏移，分为九个区域：四个角，四边和中间。图像中间部分将被丢弃（完全透明的处理），除非填写关键字。如果省略第四个数字/百分比，它和第二个相同的。如果也省略了第三个，它和第一个是相同的。如果也省略了第二个，它和第一个是相同的。</li>                <li>border-image-width属性用于指定使用多厚的边框来承载被裁剪后的图像</li>                <div class="codeMirror">                    <pre><code>border-image-width: number|%|auto;</code></pre>                </div>                <li>该属性的值可以是具体的数值也可以是百分比,默认是1,该属性同样也是包含上右下左的复合属性,该属性有一个值是auto,如果指定了，宽度是相应的image-slice的内在宽度或高度</li>                <li>border-image-outside属性指定边框图像向外扩展所定义的数值,默认值是0的长度,这个值可以用具体的带单位的数值和用纯数字来作为值,纯数字代表border-width的倍数</li>                <li>border-image-repeat属性用于指定边框图像地填充方式 ,默认值为stretch,拉伸图像来填充区域</li>                <div class="codeMirror">                    <pre><code>border-image-repeat: stretch|repeat|round|initial|inherit;</code></pre>                </div>            </ul>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>stretch</td>                    <td>默认值。拉伸图像来填充区域</td>                </tr>                <tr>                    <td>repeat</td>                    <td>平铺（repeated）图像来填充区域。</td>                </tr>                <tr>                    <td>round</td>                    <td>类似 repeat 值。如果无法完整平铺所有图像，则对图像进行缩放以适应区域。</td>                </tr>                <tr>                    <td>space</td>                    <td>类似 repeat 值。如果无法完整平铺所有图像，扩展空间会分布在图像周围。</td>                </tr>                <tr>                    <td>initial</td>                    <td>将此属性设置为默认值。</td>                </tr>                <tr>                    <td>inherit</td>                    <td>从父元素中继承该属性。</td>                </tr>            </table>            <p></p>            <p>注:border-collapse属性指定是否用做合成单一的边框,这个属性一般都是给表格使用的,默认值是separate分开</p>            <p></p>            <h3 id="s4.4">4.4 盒子阴影</h3>            <p></p>            <p>box-shadow属性为是否显示盒子阴影,默认值是none没有阴影,这个属性的用法text-shadow用法基本一致有阴影box-shadow:水平偏移量 垂直偏移量 阴影模糊半径 阴影扩展半径 阴影颜色 可以在最后加上inset表示阴影是否是内阴影,默认是外阴影outset,阴影扩展是在原本阴影的上下左右再继续添加阴影,如果没有写阴影颜色,阴影颜色由盒子内容的颜色决定所以简写只用写前面3个</p>            <p></p>            <p></p>            <p></p>            <p></p>            <h3 id="s4.5">4.5 表现形式</h3>            <p></p>            <h4 id="s4.5.1">4.5.1 display</h4>            <p></p>            <p>display属性,这个属性能从根本上改变盒子的存在方式,常用的值有 none inline block inline-block以及flex(弹性盒子)</p>            <p></p>            <h4 id="s4.5.2">4.5.2 visiblity</h4>            <p></p>            <p>visiblity属性,这个属性指定是否显示一个元素生成的元素框,但是无论怎么设置原本的盒子都不会脱离文档流,依然会占据其本来的空间,默认值是visible可见的            </p>            <p></p>            <p></p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>visible</td>                    <td>默认值。元素是可见的。</td>                </tr>                <tr>                    <td>hidden</td>                    <td>元素是不可见的。</td>                </tr>                <tr>                    <td>collapse</td>                    <td>当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 "hidden"。</td>                </tr>                <tr>                    <td>inherit</td>                    <td>规定应该从父元素继承 visibility 属性的值。</td>                </tr>            </table>            <p></p>            <h4 id="s4.5.3">4.5.3 opacity</h4>            <p></p>            <p>opacity属性设置一个元素的透明度,值为0到1,0为完全透明,1为正常显示,默认值是1</p>            <p>注意:这个属性在ie8以及ie8以下的浏览器不起作用,但是ie浏览器有自己设置透明度的方式</p>            <p>filter:alpha(opacity=num)这个属性能代替opacity在ie浏览器中生效,但是值是0到100,对应opacity的0到1</p>            <p></p>            <p>如要要兼容ie8浏览器,可以两个属性都写上,应为其他浏览器不支持下方的属性,该属性相当于没有写</p>            <p></p>            <p>让盒子在页面中消失:</p>            <p></p>            <ul>                <li>display:none能让一个盒子脱离文档流在一个页面中完全消失并且不可被选中</li>                <li>visiblity:hidden能让一个盒子在页面中隐藏但是还是占据了原本的位置,并没有脱离文档流</li>                <li>opacity:0能让一个盒子的透明度为0从而达到消失的效果,但是这个消失的效果并不好,因为还能够选中文字,当然也并没有脱离文档流</li>            </ul>            <p></p>            <h3 id="s4.6">4.6 弹性盒子</h3>            <p></p>            <p>弹性盒子由display申明,通过设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器,弹性容器内包含了一个或多个弹性子元素</p>            <p></p>            <p></p>            <p>设置弹性盒子时需要用到的属性:</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>display</td>                    <td>指定 HTML 元素盒子类型。</td>                </tr>                <tr>                    <td>flex-direction</td>                    <td>指定了弹性容器中子元素的排列方式</td>                </tr>                <tr>                    <td>justify-content</td>                    <td>设置弹性盒子元素在主轴（横轴）方向上的对齐方式。</td>                </tr>                <tr>                    <td>align-items</td>                    <td>设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式。</td>                </tr>                <tr>                    <td>flex-wrap</td>                    <td>设置弹性盒子的子元素超出父容器时是否换行。</td>                </tr>                <tr>                    <td>align-content</td>                    <td>修改 flex-wrap 属性的行为，类似align-items, 但不是设置子元素对齐，而是设置行对齐</td>                </tr>                <tr>                    <td>flex-flow</td>                    <td>flex-direction 和 flex-wrap 的简写</td>                </tr>                <tr>                    <td>order</td>                    <td>设置弹性盒子的子元素排列顺序。</td>                </tr>                <tr>                    <td>align-self</td>                    <td>在弹性子元素上使用。覆盖容器的 align-items 属性。</td>                </tr>                <tr>                    <td>flex</td>                    <td>设置弹性盒子的子元素如何分配空间,下面三个属性的简写。</td>                </tr>                <tr>                    <td>flex-grow</td>                    <td>定义项目的放大比例</td>                </tr>                <tr>                    <td>flex-shrink</td>                    <td>定义项目的缩小比例</td>                </tr>                <tr>                    <td>flex-basis</td>                    <td>定义项目对空间的分配行为</td>                </tr>            </table>            <p></p>            <h4 id="s4.6.1">4.6.1.flex-direction</h4>            <p></p>            <p>flex-direction属性定义弹性盒子中项目的主轴方向,弹性盒模型将盒子中的内容通过主轴和侧轴进行显示,主轴默认是水平从左向右的,侧轴默认垂直从上到下</p>            <p></p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>row</td>                    <td>默认值。灵活的项目将水平显示，正如一个行一样。</td>                </tr>                <tr>                    <td>row-reverse</td>                    <td>与 row 相同，但是以相反的顺序。</td>                </tr>                <tr>                    <td>column</td>                    <td>设灵活的项目将垂直显示，正如一个列一样。</td>                </tr>                <tr>                    <td>column-reverse</td>                    <td>与 column 相同，但是以相反的顺序。</td>                </tr>                <tr>                    <td>initial</td>                    <td>设置该属性为它的默认值。</td>                </tr>                <tr>                    <td>inherit</td>                    <td>从父元素继承该属性。</td>                </tr>            </table>            <p></p>            <h4 id="s4.6.2">4.6.2.flex-wrap</h4>            <p></p>            <p>flex-wrap属性规定了flex盒子在主轴上单行超出是否换行,默认值是nowrap不换行</p>            <p></p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>nowrap</td>                    <td>默认值。规定灵活的项目不拆行或不拆列。</td>                </tr>                <tr>                    <td>wrap</td>                    <td>规定灵活的项目在必要的时候拆行或拆列。</td>                </tr>                <tr>                    <td>wrap-reverse</td>                    <td>规定灵活的项目在必要的时候拆行或拆列，但是以相反的顺序。</td>                </tr>                <tr>                    <td>initial</td>                    <td>设置该属性为它的默认值。</td>                </tr>            </table>            <p></p>            <p>注意:</p>            <p> </p>            <p>在弹性盒子中因为flex-wrap的默认值是nowrap,如果设置了子元素的宽高超出了弹性盒子的总范围的时候会对子元素的大小进行弹性压缩,让超出的子元素等比例缩小到一行中,但是如果子元素里面有文字的时候,最多子元素只能被压缩到文字的大小,因为文字不能被弹性压缩,只能通过font-size来设置,被压缩到文字大小后就会超出弹性盒子</p>            <p></p>            <p></p>            <p></p>            <p>注:上面两个属性用flex-flow代替的时候flex-direction写在前面,flex-wrap写在后面</p>            <p></p>            <h4 id="s4.6.3">4.6.3 justify-content</h4>            <p></p>            <p>justify-content 用于设置或检索弹性盒子元素在主轴方向上的对齐方式，默认值是flex-start,让项目位于弹性盒子的开头</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>flex-start</td>                    <td>默认值。项目位于容器的开头</td>                </tr>                <tr>                    <td>flex-end</td>                    <td>项目位于容器的结尾。</td>                </tr>                <tr>                    <td>center</td>                    <td>项目位于容器的中心。</td>                </tr>                <tr>                    <td>space-between</td>                    <td>项目位于各行之间留有空白的容器内。先将盒子的一行的两端占据,再将剩下的空间平分</td>                </tr>                <tr>                    <td>space-around</td>                    <td>项目位于各行之前、之间、之后都留有空白的容器内。将盒子的一行完全平分</td>                </tr>                <tr>                    <td>initial</td>                    <td>设置该属性为它的默认值。</td>                </tr>                <tr>                    <td>inherit</td>                    <td>从父元素继承该属性</td>                </tr>            </table>            <p></p>            <h4 id="s4.6.4">4.6.4 align-items</h4>            <p></p>            <p>align-items属性定义了项目在侧轴上的对齐方式(algin-items主要支持单行项目),默认值是stretch,当子元素没有在侧轴方向定义宽或高的具体长度或者长度为auto时拉伸子元素的宽度或高度到整个侧轴的长度</p>            <p></p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>stretch</td>                    <td>默认。 拉伸元件以适应容器。</td>                </tr>                <tr>                    <td>center</td>                    <td>中心元素在容器内。</td>                </tr>                <tr>                    <td>flex-start</td>                    <td>位置元素在容器的开头。</td>                </tr>                <tr>                    <td>flex-end</td>                    <td>位置元素在容器的末端。</td>                </tr>                <tr>                    <td>baseline</td>                    <td>位置元素在容器的文本基线。将子元素类的文字对齐</td>                </tr>                <tr>                    <td>initial</td>                    <td>设置为默认值。</td>                </tr>                <tr>                    <td>inherit</td>                    <td>从父元素继承该属性</td>                </tr>            </table>            <p></p>            <p>注意:如果align-items的值表示默认值stretch而且子元素又没有给具体的宽高,它的大小由里面的内容撑开</p>            <p></p>            <h4 id="s4.6.5">4.6.5 align-content</h4>            <p></p>            <p>align-content定义了多行子元素在侧轴上的对齐方式,默认值是strtch,效果和align-items的相同,只不过是多行子元素进行平分整个侧轴长度</p>            <p></p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>stretch</td>                    <td>默认值。项目被拉伸以适应容器。</td>                </tr>                <tr>                    <td>center</td>                    <td>项目位于容器的中心。</td>                </tr>                <tr>                    <td>flex-start</td>                    <td>项目位于容器的开头。</td>                </tr>                <tr>                    <td>flex-end</td>                    <td>项目位于容器的结尾。</td>                </tr>                <tr>                    <td>space-between</td>                    <td>项目位于各行之间留有空白的容器内。</td>                </tr>                <tr>                    <td>space-around</td>                    <td>项目位于各行之前、之间、之后都留有空白的容器内。</td>                </tr>                <tr>                    <td>initial</td>                    <td>设置该属性为它的默认值</td>                </tr>                <tr>                    <td>inherit</td>                    <td>从父元素继承该属性</td>                </tr>            </table>            <p></p>            <p>align-items和align-content的异同:</p>            <ul>                <li>align-items和align-content有相同的功能，不过不同点是align-items是用来让每一个单行的容器居中而不是让整个容器居中</li>                <li>所以对于只有一行的flex元素，align-content是没有效果的，只有用align-items才能达到预期的效果</li>                <li>如果是多行flex元素,至于使用align-content才能让所有的flex元素在侧轴方向上面有类似justify-content在主轴上的居中效果,而使用align-items时两个flex元素间总是有间隙</li>            </ul>            <p>上面是针对于整个容器的属性,现在是针对项目上的属性</p>            <p></p>            <h4 id="s4.6.6">4.6.6 order</h4>            <p>order属性设置项目中的子元素在它那一行中主轴的排列顺序,默认是每一个子元素都是0,数值越小排序越靠前</p>            <p></p>            <p>注:该属性接受负值,且接受的值是整数</p>            <p></p>            <h4 id="s4.6.7">4.6.7 flex-grow</h4>            <p></p>            <p>flex-grow属性设置项目中的子元素在主轴上还有剩余的空间的时候通过设置一个数字来获取对于剩余空间的占比, 默认值是0            </p>            <p></p>            <p>具体用法:会将所有子元素的flex-grow属性的数字加起来然后用各自的flex-grow的数字除以这个数就是每个子元素再分配得剩余空间大小的量</p>            <p></p>            <p></p>            <p>公式:该元素分得剩余空间=该元素的flex-grow值/所有flex-grow值之和剩余空间大小</p>            <p></p>            <p>注:该属性不接受负值,允许接受浮点数</p>            <p></p>            <h4 id="s4.6.8">4.6.8 flex-shrink</h4>            <p></p>            <p>flex-shrink属性设置项目中的子元素在主轴上空间不足(这里flex-wrap没有设置为wrap)的时候,通过设置一个数字进行对自身比例的缩小从而使得flex-shrink为0的子元素保持其本身设置的大小,该属性的默认值也是0</p>            <p></p>            <p></p>            <p></p>            <p>具体用法:会将所有子元素的flex-shrink属性的数字加起来然后用各自的flex-shrink的数字除以这个数就是每个子元素对于超出弹性盒子容积空间占比要缩小的量</p>            <p></p>            <p></p>            <p></p>            <p>公式:该元素缩小空间=该元素的flex-shrink值/所有flex-shink值之和超出弹性盒子空间大小</p>            <p></p>            <p>注:该属性不接受负值,允许接受浮点数</p>            <p></p>            <h4 id="s4.6.9">4.6.9 flex-basis</h4>            <p></p>            <p>flex-basis属性定义项目对空间分配行为时,项目的实际大小(这个属性会和width和heigth等属性起冲突,在弹性盒子中有这个属性width或heigth将会无效),同时只要用这个属性设置了固定的大小,该元素就不会受到扩大或者收缩的影响</p>            <p></p>            <p></p>            <p></p>            <p>合法值："auto"、"inherit" 或一个后跟 "%"、"px"、"em" 或任何其他长度单位的数字</p>            <p></p>            <p>注意:</p>            <ul>                <li>如果该元素占据的那一行占满了弹性盒子长度,那么后面的元素会自动到下一行</li>                <li>有这个属性的元素的最大长度不能超过弹性盒子长度</li>            </ul>            <p></p>            <h4 id="s4.6.10">4.6.10 align-self</h4>            <p></p>            <p>align-self 属性定义flex子项单独在侧轴方向上的对齐方式,默认值是auto，继承父元素的align-items属性的值</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>auto</td>                    <td>默认值。元素继承了它的父容器的 align-items 属性。如果没有父容器则为 "stretch"。</td>                </tr>                <tr>                    <td>stretch</td>                    <td>元素被拉伸以适应容器。</td>                </tr>                <tr>                    <td>center</td>                    <td>元素位于容器的中心。</td>                </tr>                <tr>                    <td>flex-start</td>                    <td>元素位于容器的开头。</td>                </tr>                <tr>                    <td>flex-end</td>                    <td>元素位于容器的结尾。</td>                </tr>                <tr>                    <td>baseline</td>                    <td>元素位于容器的基线上。</td>                </tr>                <tr>                    <td>initial</td>                    <td>设置该属性为它的默认值</td>                </tr>                <tr>                    <td>inherit</td>                    <td>从父元素继承该属性</td>                </tr>            </table>            <p></p>            <h3 id="s4.7">4.7 BFC环境</h3>            <p></p>            <p>全称叫block formatting context块级格式化上下文,具有流体特性</p>            <p></p>            <p>作用:元素内部的标签无论发生什么情况都不会影响其本身的位置的值的计算</p>            <p></p>            <p>开启BFC环境的方式:</p>            <ul>                <li>overflow值不为visible都能开启</li>                <li>float的值不为none</li>                <li>position的值为绝对和固定定位</li>                <li>display的值为inline-block,flex,inline-flex等</li>            </ul>            <p></p>            <p>常见用法:</p>            <ul>                <li>阻止兄弟元素上下外边距的合并问题,具体可用一个大盒子包裹下方的盒子,然后让大盒子overflow:hidden开启BFC环境</li>                <li>防止因子元素浮动而导致的父元素高度塌陷问题</li>                <li>用作双栏式的页面布局,左边是固定宽度,右边是自适应的宽度,这种布局需要给左边的导航栏开启BFC,让左边的内容被隔离出来,类似于float,但是又占着原来的位置,左右两个部分相当于是inline-block的表现形式</li>            </ul>            <div class="codeMirror">                <pre><code>top&#123;    overflow:hidden;    width:300px;    height:200px;    background:red&#125;bottom&#123;    height:200px;    background:green&#125;</code></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><code>&lt;div class="top">    &lt;/div>&lt;div class="bottom">&lt;/div></code></pre>            </div>        </div>        <p></p>        <div class="list" id="s5">            <h2>5.背景</h2>            <p></p>            <p>background设置背景属性,该属性是一个复合属性</p>            <p></p>            <div class="codeMirror">                <pre><code>background:background-color|background-image|background-repeat|background-attachment|background-position/background-size/*(如果如果要写大小必须写位置,不然会报错,同时格式也是这样写的)*//*下面是一般写法*/background:color url repeat position/size/*(如果同时写了位置和和大小必须用/隔开)*/ </code></pre>            </div>            <p></p>            <h3 id="s5.1">5.1 background-color</h3>            <p></p>            <p>background-color属性设置元素的背景颜色，默认值是transparent透明色</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>color_name</td>                    <td>规定颜色值为颜色名称的背景颜色（比如 red）</td>                </tr>                <tr>                    <td>hex_number</td>                    <td>规定颜色值为十六进制值的背景颜色（比如 #ff0000）</td>                </tr>                <tr>                    <td>rgb_number</td>                    <td>规定颜色值为 rgb 代码的背景颜色（比如 rgb(255,0,0)。也可以使用rgba,最后一个控制背景颜色的透明度</td>                </tr>                <tr>                    <td>transparent</td>                    <td>默认。背景颜色为透明。</td>                </tr>                <tr>                    <td>inherit</td>                    <td>规定应该从父元素继承 background-color 属性的设置</td>                </tr>            </table>            <p></p>            <p>元素背景的范围</p>            <p></p>            <p>background-color 属性为元素设置一种纯色。这种颜色会填充元素的内容、内边距和边框区域,扩展到元素边框的外边界(但不包括外边距)。如果边框有透明部分(如虚线边框),会透过这些透明部分显示出背景色。</p>            <p></p>            <p>渐变色背景(这里是线性渐变,还有一种径向渐变)(IE基本不支持渐变色,要作渐变色最好还是用图片)</p>            <p></p>            <p>渐变颜色由颜色渐变函数linear-gradient()设置,第一个参数是要渐变的方向,如果不写就是默认方向,后面可以跟上任意颜色参数，同时在两个颜色参数中间(一定要是中间)还可以跟上一个百分比的参数表示两个颜色间过渡区域的占比</p>            <p></p>            <p>渐变色有方向性,如果写了两种颜色默认是从上向下平方渐变,渐变的方向只能是左右,上下和对角方向或者指定一个度数</p>            <p></p>            <p>为了创建一个线性渐变,需要设置一个起始点和一个方向（指定为一个角度）的渐变效果,还需要定义终止色,,所以 必须最少指定至少两种，当然也会可以指定更多的颜色去创建更复杂的渐变效果。</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>to top</td>                    <td>从下往上渐变</td>                </tr>                <tr>                    <td>to bottom</td>                    <td>从上往下渐变</td>                </tr>                <tr>                    <td>to left</td>                    <td>从右往左渐变</td>                </tr>                <tr>                    <td>to right</td>                    <td>从左往右渐变</td>                </tr>                <tr>                    <td>to top left</td>                    <td>从右下往左上渐变</td>                </tr>                <tr>                    <td>to top right</td>                    <td>从左上往右下渐变</td>                </tr>                <tr>                    <td>to bottom left</td>                    <td>从右上往左下渐变</td>                </tr>                <tr>                    <td>to bottom right</td>                    <td>从左上往右下渐变</td>                </tr>            </table>            <p></p>            <div class="codeMirror">                <pre><code>background-image:linear-gradient(to top,yellow,white);/*表示颜色由下往上从黄色渐变为白色*/background-image:linear-gradient(to top left,yellow,80%,white);/*表示颜色从右下网左上从80%处开始渐变*/background-image:linear-gradient(45deg,yellow,white)/*表示在45度方向方向开始渐变*/</code></pre>            </div>            <p></p>            <p>注意:渐变函数linear-gradient()占用的是background-image属性</p>            <p></p>            <h3 id="s5.2">5.2 background-image</h3>            <p></p>            <p>background-image属性设置背景图像,默认值是none,如要要设置背景图片和border-image一样用url("")中间写图 片的地址来设置</p>            <p></p>            <h3 id="s5.3">5.3 background-repeat</h3>            <p></p>            <p>background-repeat属性设置背景图片是否重复,默认值为repeat,意为水平和垂直方向都要重复,其它值有 no-repeat只展示一次背景图片 repeat-x只在水平方向重复 repeat-y只在垂直方向重复</p>            <p></p>            <p></p>            <h3 id="s5.4">5.4 background-attachment</h3>            <p></p>            <p>background-attachment属性设置背景图像是否固定或者随着页面的其余部分滚动,默认值是scroll，背景图片会随着页面其余部分滚动而滚动,如果要让背景图片不移动,设置次属性为fixed</p>            <p></p>            <p></p>            <h3 id="s5.5">5.5 background-position</h3>            <p></p>            <p>background-positon设置背景图像的起始位置,默认的起始值是0% 0%,也就是在盒子的左上角位置</p>            <p></p>            <p>这个属性的值可以是具体的像素数值,也可以是百分比,还可以用一些表示方位的关键词来写</p>            <ul>                <li>如果是用数值或者百分比来写,有两个值,第一个值是水平位置,第二个值是垂直位置,如果只规定了一个值,那么第二个值默认是50%,可以数值和百分号一起使用</li>                <li>如果用关键词来写,具体的关键词有top left right bottom center,也是第一个值表示水平位置,第二个词表示垂直位置，如果只写了一个值,那么第二个值是center</li>            </ul>            <p></p>            <h3 id="s5.6">5.6 background-size</h3>            <p></p>            <p>background-size属性规定背景图像的尺寸,默认值是auto</p>            <p></p>            <p>background-size:长度/百分比/auto/cover/contain</p>            <p></p>            <p>auto真实大小 cover将背景图像等比例缩放到完全覆盖容器,直到将容器填满,不会让图片变形,有可能超出容器 contain将图像等比拉伸，直到高度或者宽度将容器填满且始终包含在容器内</p>            <p></p>            <p></p>            <p>background-size实际上是控制两个地方,宽和高,如果只写一个就是指控制宽,而高自动为auto</p>            <p></p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>length</td>                    <td>设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 "auto"。</td>                </tr>                <tr>                    <td>percentage</td>                    <td>以父元素的百分比来设置背景图像的宽度和高度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 "auto"。</td>                </tr>                <tr>                    <td>cover</td>                    <td>把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。</td>                </tr>                <tr>                    <td>contain</td>                    <td>把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。</td>                </tr>            </table>            <p></p>            <h3 id="s5.7">5.7 background-origin</h3>            <p></p>            <p>background-origin 属性规定background-position属性相对于什么位置来定位,默认值是padding-box,从padding</p>            <p></p>            <p>位置开始当做背景参考原点</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>padding-box</td>                    <td>背景图像相对于内边距框来定位。</td>                </tr>                <tr>                    <td>border-box</td>                    <td>背景图像相对于边框盒来定位。</td>                </tr>                <tr>                    <td>content-box</td>                    <td>背景图像相对于内容框来定位。</td>                </tr>            </table>            <p></p>            <h3>5.8 background-clip</h3>            <p></p>            <p>background-clips属性背景的绘制区域,默认值是border-box,在border作为绘制背景图片的区域,其实背景图片的 border区域一直有背景图,但是如果border的样式是实现的话就看不见图片,如果是点线等中空的线条的话就能看见</p>            <p></p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>padding-box</td>                    <td>背景被裁剪到内边距框。</td>                </tr>                <tr>                    <td>border-box</td>                    <td>背景被裁剪到边框盒。</td>                </tr>                <tr>                    <td>content-box</td>                    <td>背景被裁剪到内容框。</td>                </tr>            </table>            <p></p>            <h3 id="s5.9">5.9 多背景图片</h3>            <p></p>            <p>可以多张背景图片一起组合作为背景图,每一个背景图中间用逗号隔开</p>            <p></p>            <p>语法:</p>            <p></p>            <div class="codeMirror">                <pre><code>background:color url repeat position/size，color url repeat position/size，color url repeat position/size；</code></pre>            </div>            <p></p>            <h3 id="s5.10">5.10 filter</h3>            <p></p>            <p>filter 属性定义了元素(通常是&lt; img>)的可视效果</p>            <p></p>            <div class="codeMirror">                <pre><code>filter: none | blur() | brightness() | contrast() | drop-shadow() | grayscale() | hue-rotate() | invert() | opacity() | saturate() | sepia() | url(); </code></pre>            </div>            <p></p>            <p>注意:</p>            <ul>                <li>滤镜通常使用百分比 (如：75%), 也可以使用小数来表示 (如：0.75)</li>                <li>使用空格可以分隔多个滤镜</li>                <li>一般可以使用blur()来设置毛玻璃效果</li>            </ul>            <table>                <tr>                    <td>Filter</td>                    <td>描述</td>                </tr>                <tr>                    <td>none</td>                    <td>默认值，没有效果。</td>                </tr>                <tr>                    <td>blur(px)</td>                    <td>给图像设置高斯模糊。"radius"一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起， 所以值越大越模糊； 如果没有设定值，则默认是0；这个参数可设置css长度值，但不接受百分比值。</td>                </tr>                <tr>                    <td>brightness(%)</td>                    <td>给图片应用一种线性乘法，使其看起来更亮或更暗。如果值是0%，图像会全黑。值是100%，则图像无变化。其他的值对应线性乘数效果。值超过100%也是可以的，图像会比原来更亮。如果没有设定值，默认是1。</td>                </tr>                <tr>                    <td>contrast(%)</td>                    <td>调整图像的对比度。值是0%的话，图像会全黑。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。</td>                </tr>                <tr>                    <td>drop-shadow(h-shadow v-shadow blur spread color)</td>                    <td>给图像设置一个阴影效果。阴影是合成在图像下面，可以有模糊度的，可以以特定颜色画出的遮罩图的偏移版本。 函数接受(在CSS3背景中定义)类型的值，除了"inset"关键字是不允许的</td>                </tr>                <tr>                    <td>grayscale(%)</td>                    <td>将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0；</td>                </tr>                <tr>                    <td>hue-rotate(deg)</td>                    <td>给图像应用色相旋转。"angle"一值设定图像会被调整的色环角度值。值为0deg，则图像无变化。若值未设置，默认值是0deg。该值虽然没有最大值，超过360deg的值相当于又绕一圈。</td>                </tr>                <tr>                    <td>invert(%)</td>                    <td>反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。值在0%和100%之间，则是效果的线性乘子。 若值未设置，值默认是0。</td>                </tr>                <tr>                    <td>opacity(%)</td>                    <td>转化图像的透明程度。值定义转换的比例。值为0%则是完全透明，值为100%则图像无变化。值在0%和100%之间，则是效果的线性乘子，也相当于图像样本乘以数量。 若值未设置，值默认是1。该函数与已有的opacity属性很相似，不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。</td>                </tr>                <tr>                    <td>saturate(%)</td>                    <td>转换图像饱和度。值定义转换的比例。值为0%则是完全不饱和，值为100%则图像无变化。其他值，则是效果的线性乘子。超过100%的值是允许的，则有更高的饱和度。 若值未设置，值默认是1。</td>                </tr>                <tr>                    <td>sepia(%)</td>                    <td>将图像转换为深褐色。值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0；</td>                </tr>                <tr>                    <td>url()</td>                    <td>URL函数接受一个XML文件，该文件设置了 一个SVG滤镜，且可以包含一个锚点来指定一个具体的滤镜元素。例如：filter: url(svg-url#element-id)</td>                </tr>                <tr>                    <td>initial</td>                    <td>设置属性为默认值</td>                </tr>                <tr>                    <td>inherit</td>                    <td>从父元素继承该属性</td>                </tr>            </table>        </div>        <p></p>        <div class="list" id="s6">            <h2>6.CSS盒子布局和定位</h2>            <p></p>            <h3 id="s6.1">6.1 position</h3>            <p></p>            <p>position定位属性指定一个元素的定位方法的类型,默认值是static静态定位,遵循正常的文档流</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>absolute</td>                    <td>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位，一个绝对定位元素会忽略父元素的padding属性,元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。</td>                </tr>                <tr>                    <td>fixed</td>                    <td>生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。</td>                </tr>                <tr>                    <td>relative</td>                    <td>生成相对定位的元素，相对于其正常位置进行定位,依然会占据原本文档流的位置</td>                </tr>                <tr>                    <td>static</td>                    <td>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</td>                </tr>                <tr>                    <td>sticky</td>                    <td>粘性定位，该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。</td>                </tr>                <tr>                    <td>inherit</td>                    <td>规定应该从父元素继承 position 属性的值。</td>                </tr>                <tr>                    <td>initial</td>                    <td>设置该属性为默认值</td>                </tr>            </table>            <p></p>            <p>在上述值中:只有absolute,fixed和sticky在超出滚动距离的时候才会脱离文档流,脱离文档流的盒子不会影响到其他盒子的表现形式</p>            <p></p>            <p>注意:</p>            <ul>                <li>在使用top,left,right,bottom这些方位词时,原则上是只写top和bottom，left和right中的一个,另外一个默认是 auto，如果都写了那么相互的拉伸力就会相互抵消,从而达不到想要的效果</li>                <li>绝对定位(absolute)默认是相对于body来定位的,如果要让子元素相对于父元素进行定位,必须在父元素上同样 设置定位属性(静态定位除外),如果父元素没有设置定位,那么就会以最近的定位元素为参考点,以此类推最会会 以body为参考点，不会因为是 某个元素的子元素就以它为参考点</li>                <li>绝对定位如果是以body作为参考点,那么是以网页的首屏作为参考点,就是刚刚进来时看见的页面,而不是以整个 网页的宽度和高度作为参考点</li>                <li>默认情况下定位流的元素会盖住标准流的元素</li>                <li>默认情况下定位流的元素后面编写的会盖住前面编写的</li>                <li>所有绝对定位的盒子的表现形式都会变为block</li>            </ul>            <p></p>            <p>通过绝对定位让子元素在父元素里面水平垂直居中</p>            <p></p>            <div class="codeMirror">                <pre><code>.father&#123;    position:relative;    width:200px;    height:200px;&#125;.child&#123;    position:absolute;    top:0;    bottom:0;    left:0;    right:0;    margin:auto;    width:100px;    height:100px;&#125;</code></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><code>&lt;div class="father">    &lt;div class="child">&lt;    /div> &lt;/div></code></pre>            </div>            <p></p>            <h3 id="s6.2">6.2 z-index</h3>            <p></p>            <p>z-index分层属性设置元素的堆叠顺序,使得拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面,默认的值为auto,元素在当前层叠上下文中的层叠级别是0.不会创建新的局部上下文</p>            <p></p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>auto</td>                    <td>默认。堆叠顺序与父元素相等。</td>                </tr>                <tr>                    <td>number</td>                    <td>设置元素的堆叠顺序。</td>                </tr>                <tr>                    <td>inherit</td>                    <td>规定应该从父元素继承 z-index 属性的值。</td>                </tr>            </table>            <p></p>            <p>注意:</p>            <ul>                <li>z-index有从父现象，如果父元素没有设置z-index，那么子元素谁的层级大谁就显示，如果父元素设置的z-index，那么子元素的z-index就会失效，而会跟随父元素的z-index</li>                <li>z-index 仅能在定位元素上生效,在static定位上不生效</li>                <li>所有元素默认值是auto,也是0层,正常情况下相同层级的元素后面的可以覆盖掉前面的,设置z-index的值为数值,数值越大层级越高,可以有负值,负值越大层级越小</li>            </ul>            <p></p>            <h3 id="s6.3">6.3 float</h3>            <p></p>            <p>float属性定义元素在哪个方向浮动,默认值是none,元素不浮动</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>left</td>                    <td>元素向左浮动。</td>                </tr>                <tr>                    <td>right</td>                    <td>元素向右浮动。</td>                </tr>                <tr>                    <td>none</td>                    <td>默认值。元素不浮动，并会显示在其在文本中出现的位置。</td>                </tr>                <tr>                    <td>inherit</td>                    <td>规定应该从父元素继承 float 属性的值。</td>                </tr>            </table>            <p></p>            <p>注意：</p>            <ul>                <li>浮动的元素会脱离正常的文档流,如果是子元素在父元素里面浮动,父元素不设置高可能会造成高度塌陷的问题</li>                <li>浮动的元素可以与浮动的元素进行操作,支持margin等值</li>                <li>浮动流和定位流选择其中一个使用,最好不要同时使用</li>                <li>假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止</li>            </ul>            <p></p>            <h3 id="s6.4">6.4 clear</h3>            <p></p>            <p>clear属性定义了元素的哪边上不允许出现浮动元素,这个属性常用做清除浮动,默认值为none，允许出现浮动元素</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>left</td>                    <td>在左侧不允许浮动元素。</td>                </tr>                <tr>                    <td>right</td>                    <td>在右侧不允许浮动元素。</td>                </tr>                <tr>                    <td>both</td>                    <td>在左右两侧均不允许浮动元素。</td>                </tr>                <tr>                    <td>none</td>                    <td>默认值。允许浮动元素出现在两侧。</td>                </tr>                <tr>                    <td>inherit</td>                    <td>规定应该从父元素继承 clear 属性的值。</td>                </tr>            </table>            <p></p>            <p>注意：</p>            <ul>                <li>因为不允许出现浮动元素,但是被设置了浮动的元素已经变成块级元素,所以依然会得到块级元素的换行特性</li>                <li>如果上一层是float元素，用了clear属性的元素的margin属性将会失效</li>            </ul>            <p></p>            <p>清除浮动的六种方法</p>            <p></p>            <ul>                <li>给上一个父元素盒子设置高度</li>                <li>clear清除浮动</li>                <li>外墙法清除浮动:在两个盒子中间额外添加一个块级元素，并且设置clear:both<br/>注意:只有第二个元素能用margin-top,第一个元素不能用margin-bottom来隔开距离,所以一般隔开距离的方式是添加中间的div的高度</li>                <li>内墙法清除浮动:在第一个盒子最后一个元素后面添加一个块级元素并且设置clear:both<br/>注意:该方法第一第二个盒子都可以使用margin属性</li>                <li>为第一个盒子添加伪元素(类似内墙法),但不占用内存空间,推荐使用</li>                <div class="codeMirror">                    <pre><code>box1::after&#123;    content:"";    display:block;    height:0;    visiblity:hidden;    clear:both;    &#125;</code></pre>                </div>                <li>在前一个盒子里面使用overflow:hidden,给这个盒子添加BFC环境<br/>拓展:也可以利用oveflow:hidden来让外面的盒子不设置边框的情况下里面的盒子使用margin-top的时候不会将外面的盒子一起顶下来</li>            </ul>            <p></p>            <p>不定宽度的块状元素有三种方法居中</p>            <ul>                <li>加入 table 标签</li>                <div class="codeMirror">                    <pre><code>&lt;table>    &lt;tbody>        &lt;tr>            &lt;td></td>         &lt;/tr>    &lt;/tbody>&lt;/table></code></pre>                </div>                <li>设置 display: inline 方法:与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置</li>                <li>设置 position:relative 和 left:50%;利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的 如:给父元素设置float:left;position:relative;left:50%;给子元素设置position:relative;left:-50%                </li>            </ul>        </div>        <p></p>        <div class="list" id="s7">            <h2>7.过渡模块</h2>            <p></p>            <p>transition过渡属性规定某一个要变化的属性从初始值到变化值的延迟效果,该属性是一个复合属性</p>            <p></p>            <p>复合属性语法:</p>            <p></p>            <div class="codeMirror">                <pre><code>transition:transition-property transition-duration transition-timing-function transition-delay </code></pre>            </div>            <p></p>            <p>过渡效果的要素：</p>            <ul>                <li>必须有属性变化</li>                <li>必须告诉系统哪个属性需要执行过渡效果</li>                <li>必须告诉系统过渡效效果持续时长</li>            </ul>            <p></p>            <p>上面的语法依次为:transition:过渡属性 过渡时长 过渡速度 延迟时间。可以省略后面两个参数，因为前面两个已经有了过渡的三要素</p>            <p></p>            <p>如果想给多个属性添加过渡效果,需要用逗号隔开</p>            <p></p>            <p>transition:过渡属性 过渡时长 过渡速度 延迟时间,过渡属性 过渡时长 过渡速度 延迟时间;</p>            <p></p>            <h3 id="s7.1">7.1 过渡属性</h3>            <p></p>            <p>transition-property属性设置要过渡的属性,默认值是all,也就是所有变化的属性,需要哪些元素的哪些属性发生改变,就在transition里面设置哪个属性,如果所有的属性要变化的时间,速度和延迟时间等都写了并且相同,可以直接写all代替</p>            <p></p>            <p></p>            <p></p>            <p>如果有多个属性要过渡:transition-property:属性1,属性2;</p>            <p></p>            <h3 id="s7.2">7.2 过渡时间</h3>            <p></p>            <p>transition-duration属性设置要实现过渡效果所用的时间,单位为s或者ms,如果不设置时间默认是0</p>            <p></p>            <p>如果有多个属性要过渡:transition-duration:时间1,时间2;</p>            <p></p>            <h3 id="s7.3">7.3 过渡速度</h3>            <p></p>            <p>transition-timing-function属性设置在相同的时间内过渡是通过怎样的方式进行的,默认的值是ease先慢后快</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>linear</td>                    <td>规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。</td>                </tr>                <tr>                    <td>ease</td>                    <td>规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。</td>                </tr>                <tr>                    <td>ease-in</td>                    <td>规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。</td>                </tr>                <tr>                    <td>ease-out</td>                    <td>规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。</td>                </tr>                <tr>                    <td>ease-in-out</td>                    <td>规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。</td>                </tr>                <tr>                    <td>cubic-bezier(n,n,n,n)</td>                    <td>在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。</td>                </tr>            </table>            <p></p>            <p>注:过渡速度一般都用的匀速linear,如果想用一些特别的速度模式,用cubil-bezier(贝塞尔曲线)来写出自己想要的运动模式,这个一般可以直接在百度上搜索然后调试出来</p>            <p></p>            <p></p>            <h3 id="s7.4">7.4 过渡延迟</h3>            <p></p>            <p>transition-delay属性设置过渡的延迟时间,告诉系统延迟多少秒之后才开始进行过渡动画，可以通过设置这个来达到多个盒子实现跑火车的效果</p>            <p></p>            <p></p>            <p>不支持过渡的属性:display:none</p>            <p></p>            <p>让一个元素消失的过渡一般用透明opacity来做,但是这个属性设置之后可以选中文本.所以一般配合 visibility:hidden来使用,至于为什么直接用这个属性来实现消失的过渡效果,因为这个属性的过渡效果很奇怪,元素 其他过渡完成后才突然消失,虽然不像display:none一样直接开始就消失,但是也没有过渡效果产生</p>            <p></p>            <p></p>            <p></p>            <p>注意:</p>            <ul>                <li>一般过渡效果都是具体的值来变化的,这样才最适合,当一个元素设定absolute时,如果不设置初始位置，那么默 认的初始位置是上下左右全为auto而不是0,所以如果不设置初始位置,过渡变化absolute时不会支持过渡属性</li>                <li>要写过渡元素时，先不要管过渡属性，而是先写基本界面，修改我们认为需要修改的属性，最后再反过来修改 过渡元素</li>            </ul>        </div>        <p></p>        <div class="list" id="s8">            <h2>8.动画模块</h2>            <p></p>            <p>animation动画属性规定元素呈现自动运行的过渡效果,该属性是一个复合属性</p>            <p></p>            <p>复合属性语法:animation:动画名称 动画时长 动画运动速度 延迟时间 执行次数 往返动画</p>            <p></p>            <div class="codeMirror">                <pre><code>animation: animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction;</code></pre>            </div>            <p></p>            <p>动画三要素</p>            <ul>                <li>告诉系统执行哪个动画用animation-name:run(名称随便取)确定动画名称</li>                <li>告诉系统我们需要创建一个名称叫做run的动画</li>                <li>告诉系统动画持续的时长如:animation-duration:3s;</li>            </ul>            <p></p>            <h3 id="s8.1">8.1 动画名称</h3>            <p></p>            <p>animation-name属性为@keyframes(关键帧)动画规定名称,只有通过这个名称才能将元素与动画联系起来</p>            <p></p>            <p>创建一个关键帧:</p>            <p></p>            <div class="codeMirror">                <pre><code>/*第一种方法,只能进行两次动画帧的修改*/@keyframes run&#123;    from&#123;        margin-left:0;            &#125;        to&#123;        margin-left:500px;            &#125;        &#125;        /*第二种方法,能进行多次动画帧的修改*/        @keyframes run&#123;        0%&#123;        &#125;        1%&#123;        &#125;        /*         中间可以用0%到100%的任意值，想指定多少节点就指定多少个         注意:0%是初始帧,100%是最后一帧，与animation-fill-mode属性相关         比如:            */        @keyframes run&#123;         0%&#123;        left:0;        top:0;        &#125;        25%&#123;        left:300px;        top:0;        &#125;        50%&#123;        left:300px;        top:300px;        &#125;        75%&#123;        left:0;        top:300px;        &#125;        100%&#123;        left:0;        top:0;        &#125;         &#125;         /*          注意:可以用多元素选择器,如果不同的帧有相同的样式可以用,隔开一起设置            比如:50%处和75处都是一样的            50%,75%&#123;                      &#125;          */</code></pre>            </div>            <p></p>            <h3 id="s8.2">8.2 动画时长</h3>            <p></p>            <p>tanimation-duration属性定义动画完成一个周期所需要的时间,单位为s或者ms</p>            <p></p>            <h3 id="s8.3">8.3 动画运动速度</h3>            <p></p>            <p>animation-timing-function属性规定动画的速度曲线,默认值是ease,先慢后快</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>linear</td>                    <td>规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。</td>                </tr>                <tr>                    <td>ease</td>                    <td>规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。</td>                </tr>                <tr>                    <td>ease-in</td>                    <td>规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。</td>                </tr>                <tr>                    <td>ease-out</td>                    <td>规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。</td>                </tr>                <tr>                    <td>ease-in-out</td>                    <td>规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。</td>                </tr>                <tr>                    <td>cubic-bezier(n,n,n,n)</td>                    <td>在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。</td>                </tr>            </table>            <p></p>            <h3 id="s8.4">8.4 动画延迟</h3>            <p></p>            <p>animation-delay 属性定义动画何时开始,单位为s或者ms,这个动画延迟是触发动画后离正式进行动画的时间差</p>            <p></p>            <p>注意:这个属性的值允许负值,如:-2s使动画马上开始,但跳过 2 秒进入动画,而过渡不能有负值</p>            <p></p>            <h3 id="s8.5">8.5 动画播放次数</h3>            <p></p>            <p>animation-iteration-count属性定义动画的播放次数,默认值是1,代表动画值进行一次</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>n</td>                    <td>定义动画播放次数的数值。</td>                </tr>                <tr>                    <td>infinite</td>                    <td>规定动画应该无限次播放。</td>                </tr>            </table>            <p></p>            <h3 id="s8.6">8.6 动画进行方向</h3>            <p></p>            <p>animation-direction属性是否应该轮流反向播放动画,默认值是normal.动画正常播放</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>normal</td>                    <td>默认值。动画按正常播放</td>                </tr>                <tr>                    <td>reverse</td>                    <td>动画反向播放</td>                </tr>                <tr>                    <td>alternate</td>                    <td>动画先正向播放再反向播放</td>                </tr>                <tr>                    <td>alternate-reverse</td>                    <td>动画先反向播放再正向播放</td>                </tr>            </table>            <p></p>            <h3 id="s8.7">8.7 动画状态</h3>            <p></p>            <p>animation-play-state属性告诉系统当前动画的进行状态,默认值为running执行动画</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>paused</td>                    <td>指定暂停动画,通常用做hover效果等悬停暂停效果</td>                </tr>                <tr>                    <td>running</td>                    <td>指定正在运行的动画</td>                </tr>            </table>            <p>注:动画有三个状态:等待状态 执行状态 结束状态</p>            <p></p>            <h3 id="s8.8">8.8 动画应用样式</h3>            <p></p>            <p>animation-fill-mode属性规定当动画不播放时(当动画完成时，或当动画有一个延迟未开始播放时),要应用到元素的样式，默认值是none,不应用任何样式</p>            <p></p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>none</td>                    <td>默认值。动画在动画执行之前和之后不会应用任何样式到目标元素。</td>                </tr>                <tr>                    <td>forwards</td>                    <td>在动画结束后,动画会回到本身属性设置的地方,这个属性让元素保持最后一帧100%是的位置和样式</td>                </tr>                <tr>                    <td>backwards</td>                    <td>在动画开始前(在动画延迟时间里或者动画本身的原始状态和第一帧的状态不一样时),应用第一帧0%的样式</td>                </tr>                <tr>                    <td>both</td>                    <td>相当于同时应用了forwards和backwards</td>                </tr>            </table>            <p></p>            <p>过渡动画与动画之间的异同</p>            <p></p>            <p>1.不同点</p>            <p></p>            <p>过渡必须认为的触发才会执行动画 动画不需要人为的就可以执行</p>            <p></p>            <p>2.相同点</p>            <p></p>            <p>过渡和动画都是用来给元素添加动画的,过渡和动画都是系统新增的一些属性,过渡和动画都需要满足三要素才会有动画效果</p>        </div>        <p></p>        <div class="list" id="s9">            <h2>9. 2D/3D转换模块</h2>            <p></p>            <h3 id="s9.1">9.1 transform</h3>            <p></p>            <p>transform属性意为变化,通过这个属性可以对一个盒子进行2D\3D形式的变化</p>            <p></p>            <h4 id="s9.1.1">9.1.1 rotate</h4>            <p></p>            <p>rotate旋转,这个值控制盒子是否进行2D旋转,可以接收一个参数里面的值需要带单位,支持负值</p>            <p></p>            <p>deg度数 turn圈 rad弧度 grad梯度 比如:rotate(45deg)就是顺时针旋转45度,rotate(45deg)就是逆时针旋转45度</p>            <p></p>            <p>旋转中心</p>            <p></p>            <p>默认情况下旋转的中心是元素自身的中心点,如正方形就是两条对角线的交界处</p>            <p></p>            <p>如果要改变旋转的中心点,可以通过形变中心点属性transform-origin来修改参考点</p>            <p></p>            <p>transform-origin:水平 垂直,里面的坐标是相对于自身元素的</p>            <p></p>            <p>比如transform-origin:0 0代表元素自身的左上角</p>            <p></p>            <p>取值的三种形式:</p>            <ul>                <li>具体像素,只有3DZ轴旋转的时候才支持,2D旋转不支持具体像素</li>                <li>百分比,比如默认的是宽度和高度的50%处 写作 50% 50%</li>                <li>特殊关键字,如left right top bottom center等</li>            </ul>            <p></p>            <p>默认情况下所有元素围绕Z轴旋转，也就是transform:rotateZ(),想围绕那个轴旋转,只用在rotate后添加想要旋转的 轴即可,但是如果要向绕X和Y轴旋转，虽然在2D的情况下也能用这个值,但是看出来很怪异,所以在2D情况下一般都 是遵循默认情况</p>            <p></p>            <p></p>            <p></p>            <h4 id="s9.1.2">9.1.2 skew</h4>            <p></p>            <p>skew倾斜,让元素产生2D扭曲,这个值可以接收2个参数,第一个是在x轴上的倾斜,第二个参数是y轴,值的单位是deg, 控制x轴倾斜视角上呈现的是左右向两边拉动,高度变小,y轴视角上时上下向两边拉动,宽度变小,最终使元素呈现扭 曲的样式,最后可能会扭曲消失</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><code>transform:skew(45deg,45deg);/*上方这种写就会让整个元素消失不见*/</code></pre>            </div>            <p></p>            <h4 id="s9.1.3">9.1.3 translate</h4>            <p></p>            <p>translate位移,这个值可以接受两个参数(x,y),其中x和y分别代表x轴和y轴,意为水平和垂直方向，如果只写一个参 数,只会对x轴起作用            </p>            <p></p>            <div class="codeMirror">                <pre><code>transform:translate(100px,100px);</code></pre>            </div>            <p></p>            <p>也可以单独的只设置x轴或者y轴方向上的位移</p>            <ul>                <li>translateX,这个值只接收一个参数,就是水平方向上的位移                    <div class="codeMirror">                        <pre><code>transform:translateX(100px);</code></pre>                    </div>                </li>                <li>translateY,这个值只接收一个参数,就是垂直方向上的位移                    <div class="codeMirror">                        <pre><code>transform:translateY(100px);</code></pre>                    </div>                </li>                <li>translateZ，同上, 定义3D之后才用translateZ,这时translateX等就不是2D面上的偏移了,而是在3D的坐标轴上 偏移                    <div class="codeMirror">                        <pre><code>transform:translateZ(100px);</code>                                </pre>                    </div>                </li>            </ul>            <p></p>            <p>注意:</p>            <p></p>            <ul>                <li>因为可以在transform中写入不同的2D变化,中间只需要用空格隔开,所以如果旋转了再平移,平移的坐标系就会 发生改变,平移的坐标系应为旋转后会修改坐标系                    <br/>所以如果要多个一起写,translate放在最前面</li>                <li>位移后实际上还是占据了原来的位置,这一点和相对定位类似,但是比相对定位简单一点</li>                <li>这个的值可以是具体的值也可以是百分比,这个百分比是相对自身长度或高度的百分比,不是父元素的</li>                <li>位移的方向计算方式和background-position一样,都是以右和下为正方向,上和左为负方向</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><code>/*在不知道父元素宽高的情况下如果让子元素在父元素里面绝对居中*/.father&#123;    position:relative;&#125;.child&#123;    position:absolute;    top:50%;    left:50%;    transform:translate(-50%,-50%);&#125;</code></pre>            </div>            <p></p>            <h4 id="s9.1.4">9.1.4 scale</h4>            <p></p>            <p>scale缩放,将一个元素缩放为原来的多少倍数,可以接受两个参数,第一个参数是对水平方向进行缩放,第二个参数是对垂直方向进行缩放,默认是scale(1,1),值为0到正无穷大的数字,值为0到1是缩小(值为0是没有缩放),值为1到正无穷是放 大,如果水平和垂直的缩放一样,可以只写一个参数</p>            <p></p>            <p></p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><code>transform:scale(2,1);</code></pre>            </div>            <p></p>            <p>注意:正常情况下scale中传入的参数为负值应该是没有用的,但是在这里传入负值的样子会向电磁感应一样,如果传入的是-1会以上方为中心绕x轴一圈反向展示</p>            <p></p>            <p></p>            <h3 id="s9.2">9.2 3D转换模块</h3>            <p></p>            <h4 id="s9.2.1">9.2.1 perspective</h4>            <p></p>            <p>perspective为透视属性,定义 3D 元素距视图的距离,单位为px,默认值是none,与单位为0相同,该属性允许用户改变 3D 元素查看 3D 元素的视图。</p>            <p></p>            <p></p>            <p>注意:</p>            <p></p>            <ul>                <li>当为元素定义 perspective 属性时,其子元素会获得透视效果,而不是元素本身。在需要呈现效果元素的父元素或祖先元素中加一个perspective属性,就能呈现近大远小效果,给人带来3D的视觉感受 像素的数值是元素距离视图的距离,若为10px则效果特别明显，若为10000px则基本没变化，因为距离太远，具体的值需要自己进行调试                    <br/>注意:这个属性不兼容所有浏览器,如果用chrome需要-webkit-perspective</li>                <li>perspective 属性只影响 3D 转换元素</li>                <li>这个元素最好与perspective-origin 属性一起使用,这样就能改变3D元素的底部位置</li>            </ul>            <p></p>            <h4 id="s9.2.2">9.2.2 perspective-origin</h4>            <p></p>            <p>perspective-origin属性定义 3D 元素所基于的x轴和y轴,该属性允许用户改变3D元素的底部位置,,和 transform-origin属性一样都是有两个参数x轴和y轴,默认值为50% 50%,也就是x和y轴的中间位置</p>            <p></p>            <p></p>            <p></p>            <p>取值的三种形式:</p>            <p></p>            <ul>                <li>具体像素,因为本来就是3D状态,支持具体的像素值</li>                <li>百分比,比如默认的是宽度和高度的50%处 写作 50% 50%</li>                <li>特殊关键字,如left right top bottom center等</li>            </ul>            <p></p>            <h4 id="s9.2.3">9.2.3 transform-style</h4>            <p></p>            <p>transform-style属性规定如何在 3D 空间中呈现被嵌套的元素,默认值为flat,子元素将不保留其 3D 位置</p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>flat</td>                    <td>子元素将不保留其 3D 位置。</td>                </tr>                <tr>                    <td>preserve-3d</td>                    <td>子元素将保留其 3D 位置。</td>                </tr>            </table>            <p></p>            <p>注意：该属性必须与transform属性一起使用</p>            <p></p>            <h4 id="s9.2.4">9.2.4 backface-visibility</h4>            <p></p>            <p>backface-visibility属性定义当元素不面向屏幕时是否可见,默认值是visible,显示背面是可见的,该属性通常用在旋转时不想要看见元素背面</p>            <p></p>            <p></p>            <table>                <tr>                    <td>值</td>                    <td>描述</td>                </tr>                <tr>                    <td>visible</td>                    <td>背面是可见的。</td>                </tr>                <tr>                    <td>hidden</td>                    <td>背面是不可见的。</td>                </tr>            </table>            <p></p>            <p>企业开发的正方体竖直轮转</p>            <p></p>            <p>按照上 后 下 前的顺序做每一个边(因为左右两个边其实可以不呈现出来),假如父元素的厚度为200px</p>            <p></p>            <p>transform:rotateX(90deg/180deg/270deg/360deg)(里面的角度分别对应了上后下前的顺序) translateZ(100px)</p>            <p></p>            <p>(里面的数字是父元素的一半厚度，因为默认这些子元素是在父元素的中间）</p>            <p></p>            <p>最后只用给这个正方体的父元素设置3D视角就可以了</p>            <p></p>            <p>扩展:要做长方体只用把上 后 下 前四个面用transform:scale扩大(只扩大长宽,不扩大正方体的厚度),左右再多移动100px</p>        </div>        <p></p>        <div class="list" id="s10">            <h2>10.媒体查询</h2>            <p></p>            <p>@media 查询可以针对不同的媒体类型或者不同的屏幕尺寸设置不同的样式 ,@media常用于响应式页面的布局 @media在对媒体类型设置的时候一般都是screen,用于电脑屏幕,平板电脑,智能手机等，同时在设计screen尺寸样式的时候也是一般通过max-width和min-width来设置</p>            <p></p>            <p></p>            <p></p>            <p>max-width可以理解为宽度小于等于最大宽度的时候样式才生效,min-width可以理解为宽度大于等于最小宽度 的时候样式才生效</p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><code>@media screen and (min-width:300px) and (max-width:799px)&#123;    body&#123;        background:red;    &#125;&#125;@media screen and (min-width:800px) and (max-width:799px)&#123;    body&#123;        background:green;    &#125;&#125;@media screen and (min-width:1200px)&#123;    body&#123;        background:blue;    &#125;&#125;/*一般设置响应式的时候都是只设置最小或者最大宽度,并两个都设置,所以在这里后面的max-width可以舍去,效果还是一样的*/ </code></pre>            </div>            <p></p>            <p>注意:</p>            <p></p>            <p>在都设置的是最小宽度的时候,min-width按照从小到大的顺序写,在都设置的是最大宽度的时候,max-width按照从 大到小的顺序写,这样写是为了后面写的到了合适的时候会覆盖前面的内容,如果写反了就会只有一种样式</p>            <p></p>            <p></p>            <h3 id="s10.1">10.1 引入资源</h3>            <p></p>            <p>媒体查询还可以根据不同的大小引入不同的资源文件</p>            <p></p>            <div class="codeMirror">                <pre><code>&lt;!DOCTYPE html>&lt;!DOCTYPE html>&lt;html lang="en">    &lt;head>    &lt;meta charset="UTF-8">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge">    &lt;link rel="stylesheet" href="a.css" modia="screen and (min-width:320px)"/>    &lt;link rel="stylesheet" href="b.css" modia="screen and (min-width:640px)"/>    &lt;title>Document</title>    &lt;/head>    &lt;body>        &lt;div>           &lt;!-- coding... -->        &lt;/div>    &lt;/body>                        &lt;/html></code></pre>            </div>        </div>        <p></p>        <div class="list" id="s11">            <h2>11.布局思路</h2>            <p></p>            <ul>                <li>圣杯布局<br/>一个大盒子要设置最小宽度min-width，大盒子中间写在最上面，宽度为100%,大盒子设置左右padding分别留出左右部分的位置大小，然后左右中三者都要浮动，然后左右设置margin跑到上中间里，通过相对定位达到响应式布局</li>                <li>双飞翼布局<br/>也是一个大盒子设置最小宽度，中间部分外面多了一层设置宽度为100%，然后中间部分设置margin刚好是左右的宽度，左右部分和中间部分外面都要浮动，然后通过外边距设置调到上方</li>            </ul>            <p></p>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/BOM/"/>
    <url>/CodeNote/2020/10/23/zone/html/BOM/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title">            <h1>BOM</h1>            <p></p>            <p>BOM全称Browser Object Model(浏览器对象模型),是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构，BOM可以使我们通过JS来操作浏览器</p>            <p></p>            <p>BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象</p>            <p></p>            <ul>                <li>Window-代表的是整个浏览器的窗口，同时window也是网页中的全局对象</li>                <li>Navigator-代表当前浏览器的信息，通过该对象可以来识别不同的浏览器</li>                <li>Location-代表当前浏览的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面</li>                <li>History-代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录，由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前和向翻页，而且该操作只在当次访问时游戏</li>                <li>Screen-代表用户的屏幕信息，通过该对象可以获取到用户的显示器的相关信息</li>            </ul>            <p></p>            <p>Window下方的BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用navigator location history screen</p>            <p></p>        </div>        <div class="list" id="s1">            <h2>1.Navigator</h2>            <p></p>            <p>Navigator代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器，由于历史原因，Navigator对象中的大部分属性已经不能帮助我们识别浏览器了</p>            <p></p>            <p>一般我们只会使用userAgent属性来判断浏览器的信息,userAgent是一个字符串，这个字符串包含有用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent，usetAgent里面会有与浏览器相关的标识，但在IE11中已经将微软和IE相关的标识都已经取消了，所以我们基本已经不能通过UserAgent识别一个浏览器是否是IE浏览器</p>            <p></p>            <p></p>            <p></p>            <div class="codeMirror">                <pre><code>//chrome浏览器console.log(navigator.userAgent);//Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36</code></pre>            </div>            <p></p>            <div class="codeMirror">                <pre><code>if(navigator.userAgent.indexOf("MSIE")!==-1)&#123;    alert("IE");&#125;else&#123;    alert("not IE")&#125;</code></pre>            </div>            <p></p>            <p>如果通过userAgent属性不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息，比如：通过ActiveXObject属性判断是否为IE浏览器</p>            <p></p>            <div class="codeMirror">                <pre><code>//通过"ActiveXObject" in window来判断是不是IE浏览器console.log("ActiveXObject" in window);</code></pre>            </div>        </div>        <div class="list" id="s2">            <h2>2.History</h2>            <p></p>            <p>History对象可以用来操作浏览器向前或向后翻页</p>            <p></p>            <ul>                <li>length属性，可以获取到当次访问的链接数量</li>                <li>back()方法可以用来退到上一个页面，作用和浏览器的回退按钮一样                    <div class="codeMirror">                        <pre><code> history.back();</code></pre>                    </div>                </li>                <li>forward()方法可以跳转下一个页面，作用和浏览器的前进按钮一样                    <div class="codeMirror">                        <pre><code>history.forward()</code></pre>                    </div>                </li>                <li>go()方法可以用来跳转到指定页面，该方需要一个整数作为参数                    <br/>参数用法:1表示向前跳转一个页面，2表示向前跳转2个页面，-1表示向后跳转一个页面，-2表示向后跳转2个页面                    <div class="codeMirror">                        <pre><code>history.go(1);history.go(-1); </code></pre>                    </div>                </li>            </ul>        </div>        <div class="list" id="s3">            <h2>3.Location</h2>            <p></p>            <p>Location对象中封装了浏览器的地址栏信息</p>            <p></p>            <ul>                <li>直接打印location对象可以获取到地址栏的信息(当前页面的完整路径)</li>                <li>如果直接将location属性修改为一个完整的路径，或相对路径，则页面会自动跳转到该路径，并且会生成相应的历史记录                    <div class="codeMirror">                        <pre><code>location="https://www.baidu.com";</code></pre>                    </div>                </li>            </ul>            <p></p>            <p>Location对象的属性</p>            <p></p>            <table>                <tr>                    <td>属性</td>                    <td>描述</td>                </tr>                <tr>                    <td>hash</td>                    <td>返回一个URL的锚部分</td>                </tr>                <tr>                    <td>host</td>                    <td>返回一个URL的主机名和端口</td>                </tr>                <tr>                    <td>hostname</td>                    <td>返回URL的主机名</td>                </tr>                <tr>                    <td>href</td>                    <td>返回完整的URL</td>                </tr>                <tr>                    <td>pathname</td>                    <td>返回的URL路径名</td>                </tr>                <tr>                    <td>port</td>                    <td>返回一个URL服务器使用的端口号</td>                </tr>                <tr>                    <td>protocol</td>                    <td>返回一个URL协议</td>                </tr>                <tr>                    <td>search</td>                    <td>返回一个URL的查询部分</td>                </tr>            </table>            <p></p>            <p>Location对象的方法</p>            <p></p>            <ul>                <li>assign()方法用来跳转到其他页面，作用和直接修改location一样                    <div class="codeMirror">                        <pre><code>location.assign("https://www.baidu.com");</code></pre>                    </div>                </li>                <li>reload()方法会重新加载当前页面，作用和刷新按钮一样，该方法可以接受一个布尔值参数,默认是flase,代表只刷新当前页面,不清除页面的缓存内容(一般的刷新都会有缓存留着input标签里面的文字),如果传入true则会强制清空页面缓存内容<br/>注意:如果要通过刷新按钮清空页面缓存,需要同时按住ctrl和F5                    <div class="codeMirror">                        <pre><code>location.reload();//不清除缓存location.reload(true);//清除缓存</code></pre>                    </div>                </li>                <li>replace()方法可以使用一个新的页面替换当前页面，调用完毕也会跳转页面，不会生成历史记录，所以不能使用回退按钮回退                    <div class="codeMirror">                        <pre><code>location.replace("https://www.baidu.com");</code></pre>                    </div>                </li>            </ul>        </div>        <div class="list" id="s4">            <h2>4.Window</h2>            <p></p>            <ul>                <li>open()方法打开一个新的浏览器窗口或查找一个已命名的窗口,该方法的返回值是新窗口的window对象                    <div class="codeMirror">                        <pre><code>window.open(url,target);//url默认是打开一个新的空白页面,target默认是打开新窗口window.open("https://www.baidu.com","_self");//在自身页面打开,域名必须要加上协议</code></pre>                    </div>                </li>                <li>close()方法关闭浏览器窗口                    <div class="codeMirror">                        <pre><code>window.close();</code></pre>                    </div>                </li>                <li>setInterval()方法按照指定的周期(以毫秒计)来调用函数或计算表达式</li>                <li>setTimeout()方法在指定的毫秒数后调用函数偶计算表达式</li>                <li>clearInterval()方法取消由setInterval()设置的定时器</li>                <li>clearTimeout()方法取消由setTimeout()方法设置的定时器</li>                <li>scrollTo()方法把内容滚动到指定坐标                    <div class="codeMirror">                        <pre><code>document.onclick=function()&#123;    window.scrollTo(0,500);&#125;</code></pre>                    </div>                </li>                <li>scrollBy()方法按照指定像素来滚动内容,不带px单位<br/>参数                    <ul>                        <li>xnum,把文档向右滚动的像素数</li>                        <li>ynum,把文档向下滚动的像素数</li>                    </ul>                    <div class="codeMirror">                        <pre><code>document.onclick=function()&#123;    window.scrollBy(0,500);&#125;</code></pre>                    </div>                </li>                <li>alert("内容")警告框</li>                <li>confirm("文本")确认框</li>                <li>prompt("文本","默认值")提示框</li>            </ul>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/CodeNote/2020/10/23/zone/html/Ajax/"/>
    <url>/CodeNote/2020/10/23/zone/html/Ajax/</url>
    
    <content type="html"><![CDATA[<div class="content">    <div class="main">        <div class="title">            <h1>Ajax</h1>            <p></p>            <p>Ajax全称 Asynchronous JavaScript and XML(异步的JavaScript和XML),既是一个对象,也是一种方法模式</p>            <p></p>            <p>AJAX是一种用于创建快速动态网页的技术,通过在后台与服务器进行少量数据交换,Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新,传统的不使用Ajax的网页如果需要更新内容,必需重载整个网页面</p>        </div>        <p></p>        <div class="list" id="s1">            <h2>1. 原生Ajax</h2>            <p></p>            <h3 id="s1.1">1.1 用法</h3>            <p></p>            <h4 id="s1.1.1">1.1.1 创建Ajax对象</h4>            <p></p>            <ul>                <li>通过XMLHttpRequest()类创建一个Ajax对象(此方法不兼容IE6以下浏览器)                    <div class="codeMirror">                        <pre><code>var Ajax=new XMLHttpRequest();</code></pre>                    </div>                </li>                <li>在IE6以下浏览器通过ActiveXObject("Microsoft.XMLHTTP")创建一个Ajax对象                    <div class="codeMirror">                        <pre><code>var Ajax=new ActiveXObject("Microsoft.XMLHTTP")</code></pre>                    </div>                </li>            </ul>            <p></p>            <h4 id="s1.1.2">1.1.2 连接服务器></h4>            <p></p>            <p>通过open()方法,可以设置跟后台交互的一些行为,该方法有三个参数</p>            <p></p>            <p>参数:</p>            <p></p>            <ul>                <li>请求方式,一个包含具体请求方式的字符串<br/>主要请求方式</li>                <ul>                    <li>POST,建议在添加数据时使用</li>                    <li>GET,建议在查询数据时使用</li>                    <li>PUT,建议在修改数据时使用</li>                    <li>DELETE,建议在删除数据时使用</li>                </ul>                <li>url,要请求数据的具体地址</li>                <li>bool,进行同步或异步传输,true为异步,false为同步</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><code>//请求方式可以用大写也可以用小写    Ajax.open("GET","a.txt",true);</code></pre>            </div>            <p></p>            <p>注意:在IE浏览器中,如果通过Ajax发生GET请求,那么IE浏览器认为同一个url只有一个结果，修改文件内容浏览器中显示的值也不会发生改变</p>            <p></p>            <div class="codeMirror">                <pre><code>//一般按照如下格式写    Ajax.open("GET","a.txt?t="+newDate().getTime(),true);</code></pre>            </div>            <p></p>            <p>设置需求</p>            <p></p>            <ul>                <li>如果想用GET的时候直接添加需求,可以在url后面加上?再写具体的需求,多个需求通过&符号连接                    <div class="codeMirror">                        <pre><code>/Ajax.open("GET","https://www.baidu.com?user=zhangsan&pwd=123456",true);</code></pre>                    </div>                </li>                <li>如果是POST请求,需要设置请求头信息,如:                    <div class="codeMirror">                        <pre><code>//表单格式请求头信息的写法    Ajax.setRequestHeader("Content-Type","application/x-www-form-urlencoded");    //在下一步的send()方法中传入需求    Ajax.send(“user=zhangsan&pwd=123456");</code></pre>                    </div>                </li>            </ul>            <p></p>            <h4 id="s1.1.3">1.1.3 发送请求</h4>            <p></p>            <p>通过send()方法正式发送请求</p>            <p></p>            <div class="codeMirror">                <pre><code>Ajax.send();</code></pre>            </div>            <p></p>            <h4 id="s1.1.4">1.1.4 返回请求结果</h4>            <p></p>            <ul>                <li>通过readyState(Ajax自身的状态码)属性来返回请求进行到了某一步,该属性存有请求的状态<br/>请求状态</li>                <ul>                    <li>0: 请求未初始化</li>                    <li>1: 服务器连接已建立</li>                    <li>2: 请求已接收</li>                    <li>3: 请求处理中</li>                    <li>4: 请求已完成，且响应已就绪</li>                </ul>                <li>通过onreadystatechange事件(在状态码发生改变时就会执行此事件)或onload事件来对状态码发生改变时进行操作</li>                <li>通过status(http的状态码)属性的值判断请求后的结果从而得到请求信息,一般该值为200到300直接和等于304时代表请求成功,值为404代表请求失败</li>                <li>response属性保留着后台返回到前端的数据</li>            </ul>            <p></p>            <div class="codeMirror">                <pre><code>Ajax.onreadystatechange=function()&#123;        if(Ajax.readyState===4)&#123;            //确定http的状态码            if(Ajax.status>=200&&Ajax.status<300||Ajax.status===304)&#123;                console.log(Ajax.response);            &#125;        &#125;    &#125;</code></pre>            </div>            <p></p>            <h3 id="s1.2">1.2 超时请求</h3>            <p></p>            <p>如果请求事件太长就是请求超时,如果事件过长则可能内部出现了错了,可以设置超过一定时间结束请求</p>            <p></p>            <div class="codeMirror">                <pre><code>//可以通过定时器进行结束请求    setTimeout(function()&#123;        Ajax.abort();    &#125;,3000)    //低版本IE可以使用    Ajax.timeout=3000;</code></pre>            </div>            <p></p>            <h3 id="s1.3">1.3 跨域请求</h3>            <p></p>            <p>如果通过Ajax跨域传输一个请求,浏览器会自动将该请求阻止并返回报错信息。如果要进行跨域就要进行特殊方法进行实现</p>            <p></p>            <p>实现跨域</p>            <p></p>            <ul>                <li>JOSNP方式,通过script标签中的src属性传输请求</li>                <li>CORS方式,在后台中设置可以让对应的域进行访问</li>                <li>通过信任服务器代理请求进入(翻墙)</li>            </ul>            <p></p>            <h3 id="s1.4">1.4 封装Ajax</h3>            <p></p>            <div class="codeMirror">                <pre><code>/function request()&#123;        ajax(&#123;            type:'POST',//请求类型            url:'data.json',//请求路径            asyn:true,//是否异步            data:&#123;//数据                username:'千寻',                password:'888'            &#125;,            dataType:'text',//请求数据类型            success:function(response)&#123;//请求成功处理函数                console.log( response );                var response = JSON.parse(response);                console.log( response[2].name );            &#125;,            error:function(status)&#123;//请求失败处理函数                console.log(status);                &#125;            &#125;)        &#125;        //Ajax 封装    function ajax(obj)&#123;        var type = obj.type||'GET',//请求类型            url = obj.url,//url处理            asny = obj.asny!==true,//异步处理            data = '',//预设写入数据            dataType = obj.dataType||'json',//请求类型            success = obj.success,//回调函数            error = obj.error;//错误处理函数        for(key in obj.data)&#123;//数据处理            data += key+'='+obj.data[key]+'&';        &#125;        data = encodeURI(data);        //console.log(data);        var xhr=new XMLHttpRequest();        //console.log(xhr);        if(window.XMLHttpRequest)&#123;            xhr = new XMLHttpRequest();        &#125;else&#123;            try&#123;                xhr = new ActiveXObject('Msxml2.XMLHTTP.6.0');            &#125;catch(e)&#123;                xhr = new ActiveXObject('Msxml2.XMLHTTP.3.0');            &#125;        &#125;        //如果是GET请求方式,设置数据        if(type.toUpperCase() == 'GET')&#123;            var date = new Date().getTime();//添加一个时间用来处理，GET方式缓存的问题            //console.log(date);            url = url+'?'+data+date;            data =null;        &#125;else if(dataType.toUpperCase() == 'XML')&#123;            data =null;        &#125;        xhr.open(type,url,asny);//请求架设        xhr.setRequestHeader('content-Type','application/x-www-form-urlencoded');        //设置请求头信息        //console.log(data);        xhr.send(data);//发送数据        xhr.onreadystatechange= function()&#123;//监听请求            //readyState 为XMLHttpRequest对象的状态            //status 为服务器返回的http状态码                if(xhr.readyState== 4 && xhr.status==200)&#123;                var response;                if(dataType === 'json' || dataType === 'text')&#123;                    if(dataType === 'json')&#123;                        //解析json数据                        response = JSON.parse(xhr.responseText);                    &#125;else&#123;                        //普通数据                        response = xhr.responseText;                    &#125;                    &#125;else&#123;                    response = xhr.responseXML;                &#125;                success&&success(response);            &#125;else&#123;                error&&error(xhr.status);            &#125;        &#125;        &#125;</code></pre>            </div>        </div>        <p></p>        <div class="list" id="s2">            <h2>2.Fetch</h2>            <p></p>            <p>传统的Ajax指的是XMLHttpResquest(XHR),现在已经已经可以用fetch来代替</p>            <p></p>            <p>注意:</p>            <p></p>            <ul>                <li>Fetch是全局对象的方法,可以直接使用</li>                <li>Fetch是基于Promise设计的,所以值能在支持ES6版本的浏览器使用</li>            </ul>            <p></p>            <h3 id="s2.1">2.1 用法</h3>            <p></p>            <h4 id="s2.1.1">2.1.1 Fetch的参数</h4>            <p></p>            <ul>                <li>url,该参数定义要获取的资源,可以是一个url字符串,也可以是一个Request对象</li>                <li>options,该参数可选,为一个对象,内部含有一些对请求的设置属性<br/>内部属性</li>                <ul>                    <li>method:请求使用的方法。如:GET、POST等</li>                    <li>headers:请求头信息。形式为Headers对象或ByteString</li>                    <li>body:请求的body信息,可能是一个Blob、BufferSource、FormData、URLSearchParams或者USVString对象。注意GET或HEAD方法的请求不能包含body信息</li>                    <li>mode:请求的模式。如cors、no-cors或者same-origin</li>                    <li>credentiala:请求的credentials。如omit、same-origin或者include</li>                    <li>cache:请求的cache模式:default,no-store,reload,no-cache或者only-if-cached</li>                </ul>            </ul>            <p></p>            <h4 id="s2.1.2">2.1.2 response</h4>            <p></p>            <p>response为一个Promise对象成功时传回的对象,该属性含有对应返回数据的属性和方法</p>            <p></p>            <ul>                <li>属性</li>                <ul>                    <li>status (number),HTTP请求结果参数,在100-599范围</li>                    <li>statusText (string),服务器返回的状态报告</li>                    <li>ok (boolean),如果返回200表示请求成功则为true</li>                    <li>headers (Headers),返回头部信息,该属性后面也有对应的方法</li>                    <ul>                        <li>has(name) (boolean),判断是否存在该信息头</li>                        <li>get(name) (string),获取信息头的数据</li>                        <li>getAll(name) (Array),获取所有头部数据</li>                        <li>set(name,value),设置请求头信息</li>                        <li>append(name,value),添加header的内容</li>                        <li>delete(name),删除header的信息</li>                        <li>forEach(function(value,name){...},[thisContext]),循环读取header的信息</li>                    </ul>                    <li>url (string),详细的地址</li>                </ul>                <li>方法</li>                <ul>                    <li>text(),以string的形式生成请求text</li>                    <li>json(),生成JSON.parse(responseText)的结果</li>                    <li>blob(),生成一个Blob</li>                    <li>arrayBuffer(),生成一个ArrayBuffer</li>                    <li>formData(),生成格式化数据,可用于其它的请求</li>                </ul>                <li>其他方法</li>                <ul>                    <li>clone(),创建一个Response对象的克隆</li>                    <li>Response.error(),返回一个绑定了网络错误的新的Response对象</li>                    <li>Response.redirect(),用另一个URL创建一个新的Resonse对象</li>                </ul>            </ul>            <p></p>            <h4 id="s2.1.3">2.1.3 使用案例</h4>            <p></p>            <ul>                <li>get                    <div class="codeMirror">                        <pre><code>fetch("a.html").then(function(response)&#123;        return response.text();    &#125;).then(function(body)&#123;        document.body.innerHTML=body;    &#125;);</code></pre>                    </div>                </li>                <li>post                    <div class="codeMirror">                        <pre><code>fetch("a.html",&#123;        method:"POST",        headers:&#123;            "Accept":"application/json",            "Content-Type":"application/json";        &#125;,        body:JSON.stringify(&#123;            user:"zhangsan",            pwd:123456;        &#125;)    &#125;)</code></pre>                    </div>                </li>            </ul>            <p></p>            <h3 id="s2.2">2.2 与原生Ajax的比较</h3>            <p></p>            <ul>                <li>原生Ajax                    <div class="codeMirror">                        <pre><code>var Ajax=new XMLHttpRequest();    Ajax.open("GET",url);    Ajax.responseType="json";    Ajax.send();    Ajax.onreadystatechange=function()&#123;        console.log(Ajax.response);    &#125;;    Ajax.onerror=function()&#123;        console.log("error");    &#125;;</code></pre>                    </div>                </li>                <li>Fetch                    <div class="codeMirror">                        <pre><code>fetch(url).then(function(response)&#123;        return response.json();//相当于JSON.parse(response);    &#125;).then(function(data)&#123;        console.log(data);    &#125;).catch(function(err)&#123;        console.log("error",err);    &#125;);        //使用箭头函数    fetch(url).then(        response=>response.json();    ).then(        data=>console.log(data);    ).catch(        err=>console.log("error",err);    );    //使用async函数    let Fetch=async function()&#123;        try&#123;            let response=await fetch(url);            let data=await response.json();            console.log(data);           &#125;catch(err)&#123;            console.log("error",err);        &#125;    &#125;</code></pre>                    </div>                </li>            </ul>        </div>    </div></div>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
